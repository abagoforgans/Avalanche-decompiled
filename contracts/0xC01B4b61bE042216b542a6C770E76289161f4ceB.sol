contract main {




// =====================  Runtime code  =====================


#
#  - sub_0081a21f(?)
#  - claim(uint256[] arg1)
#  - sub_a633b2f2(?)
#  - sub_aff63b7d(?)
#
address owner;
array of uint256 stor1;
array of uint256 stor2;
array of uint256 stor3;
array of uint256 stor4;
array of uint256 stor5;
array of uint256 stor6;
array of struct stor7;
address stor8;
address stor9;
address stor10;
mapping of uint8 stor11;
mapping of uint256 sub_ded2abc3;
mapping of struct stor13;

function sub_222d9d4a(?) payable {
    return stor2.length
}

function WhiteListed(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor11[arg1])
}

function sub_7e953ee7(?) payable {
    return stor5.length
}

function owner() payable {
    return owner
}

function sub_b49bb8f3(?) payable {
    return stor1.length
}

function sub_ded2abc3(?) payable {
    require calldata.size - 4 >= 32
    return sub_ded2abc3[arg1]
}

function sub_f5597032(?) payable {
    return stor4.length
}

function sub_fb0ecf68(?) payable {
    return stor3.length
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_9d041475(?) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor1.length = arg1
    stor2.length = arg2
    stor3.length = arg3
}

function sub_164af651(?) payable {
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    require ext_code.size(stor10)
    staticcall stor10.0x164af651 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_61c873f5(?) payable {
    require calldata.size - 4 >= 64
    require arg1 < 6
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 5:
        revert with 0, 33
    if arg1 == 4:
        stor5.length = arg2
    else:
        if arg1 > 5:
            revert with 0, 33
        if arg1 != 5:
            stor4.length = arg2
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setAddress(address arg1, address arg2, address arg3, address arg4, address arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(stor6.length) = arg2
    address(stor7.length) = arg1
    stor9 = arg5
    stor8 = arg3
    stor10 = arg4
}

function setWhitelist(address[] arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 11
        stor11[address(cd[((32 * idx) + arg1 + 36)])] = uint8(arg2)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_e31b17ab(?) payable {
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    require arg3 == bool(arg3)
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    sub_ded2abc3[arg1] = 0
    if bool(stor13[arg1].field_0):
        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        uint256(stor13[arg1].field_0) = 0
        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
            idx = 0
            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor13[arg1][idx].field_0) = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
            revert with 0, 34
        uint256(stor13[arg1].field_0) = 0
        if 31 < stor13[arg1].field_1 % 128:
            idx = 0
            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                uint256(stor13[arg1][idx].field_0) = 0
                idx = idx + 1
                continue 
    uint256(stor13[arg1].field_256) = 0
    uint256(stor13[arg1].field_512) = 0
    uint256(stor13[arg1].field_768) = 0
    uint256(stor13[arg1].field_1024) = 0
    uint256(stor13[arg1].field_1280) = 0
    uint256(stor13[arg1].field_1536) = 0
    uint16(stor13[arg1].field_1792) = 0
    if arg3:
        require ext_code.size(stor8)
        call stor8.0x37c14e70 with:
             gas gas_remaining wei
            args arg1, address(arg2)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function sub_c4d4c5f0(?) payable {
    require calldata.size - 4 >= 64
    require cd[36] <= test266151307()
    require calldata.size + -cd[36] - 4 >= 288
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    require ('cd', 36).length < calldata.size + -cd[36] - 35
    require cd[(cd[36] + ('cd', 36).length + 4)] <= test266151307()
    require cd[36] + ('cd', 36).length + 36 <= calldata.size - cd[(cd[36] + ('cd', 36).length + 4)]
    if cd[(cd[36] + ('cd', 36).length + 4)] > test266151307():
        revert with 0, 65
    if bool(stor13[cd[4]].field_0):
        if bool(stor13[cd[4]].field_0) == uint255(uint256(stor13[cd[4]].field_0)) * 0.5 < 32:
            revert with 0, 34
        if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 <= 31 and cd[(cd[36] + ('cd', 36).length + 4)] <= 31:
            if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor[s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor[Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
        else:
            if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor13[cd[4]][s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]][Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
    else:
        if bool(stor13[cd[4]].field_0) == stor13[cd[4]].field_1 % 128 < 32:
            revert with 0, 34
        if stor13[cd[4]].field_1 % 128 <= 31 and cd[(cd[36] + ('cd', 36).length + 4)] <= 31:
            if stor13[cd[4]].field_1 % 128 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor[s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor[Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
        else:
            if stor13[cd[4]].field_1 % 128 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor13[cd[4]][s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]][Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
    uint256(stor13[cd[4]].field_256) = ('cd', 36)[0]
    uint256(stor13[cd[4]].field_512) = ('cd', 36)[1]
    uint256(stor13[cd[4]].field_768) = ('cd', 36)[2]
    uint256(stor13[cd[4]].field_1024) = ('cd', 36)[3]
    uint256(stor13[cd[4]].field_1280) = ('cd', 36)[4]
    uint256(stor13[cd[4]].field_1536) = ('cd', 36)[5]
    require ('cd', 36)[6] < 6
    uint8(stor13[cd[4]].field_1792) = uint8(('cd', 36)[6])
    require ('cd', 36)[7] < 6
    uint8(stor13[cd[4]].field_1800) = uint8(('cd', 36)[7])
}

function getMeta(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[96] = 96
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if bool(stor13[arg1].field_0):
                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, uint256(stor13[arg1].field_0)):
                    if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                        mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[704] = uint256(stor13[arg1].field_0)
                        idx = 704
                        s = 0
                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            else:
                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                if stor13[arg1].field_1 % 128:
                    if 31 >= stor13[arg1].field_1 % 128:
                        mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[704] = uint256(stor13[arg1].field_0)
                        idx = 704
                        s = 0
                        while stor13[arg1].field_1 % 128 + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            if uint8(stor13[arg1].field_1792) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1792) >= 6:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) >= 6:
                revert with 0, 33
            return 32, 288, 
                   uint256(stor13[arg1].field_256),
                   uint256(stor13[arg1].field_512),
                   uint256(stor13[arg1].field_768),
                   uint256(stor13[arg1].field_1024),
                   uint256(stor13[arg1].field_1280),
                   uint256(stor13[arg1].field_1536),
                   uint8(stor13[arg1].field_1792),
                   uint8(stor13[arg1].field_1800),
                   2 * Mask(256, -1, uint256(stor13[arg1].field_0)),
                   mem[704 len ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5)]
        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                else:
                    mem[704] = uint256(stor13[arg1].field_0)
                    idx = 704
                    s = 0
                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 >= stor13[arg1].field_1 % 128:
                    mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                else:
                    mem[704] = uint256(stor13[arg1].field_0)
                    idx = 704
                    s = 0
                    while stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1792) >= 6:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) >= 6:
            revert with 0, 33
        return 32, 288, 
               uint256(stor13[arg1].field_256),
               uint256(stor13[arg1].field_512),
               uint256(stor13[arg1].field_768),
               uint256(stor13[arg1].field_1024),
               uint256(stor13[arg1].field_1280),
               uint256(stor13[arg1].field_1536),
               uint8(stor13[arg1].field_1792),
               uint8(stor13[arg1].field_1800),
               stor13[arg1].field_0 % 128,
               mem[704 len ceil32(stor13[arg1].field_1 % 128)]
    mem[384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _9 = mem[384 len 4], Mask(224, 32, arg1) >> 32
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool(ceil32(return_data.size) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + 672
    _12 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < return_data.size + 384
    _17 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[ceil32(return_data.size) + 672] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + _17 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 704 len ceil32(_17)] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + 416 len ceil32(_17)]
    if ceil32(_17) <= _17:
        mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
        mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
        mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
        mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
        mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
        mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
        mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
        require mem[_9 + 608] < 6
        mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
        require mem[_9 + 640] < 6
        mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = 288
        _597 = mem[ceil32(return_data.size) + 672]
        mem[mem[64] + 320] = mem[ceil32(return_data.size) + 672]
        mem[mem[64] + 352 len ceil32(_597)] = mem[ceil32(return_data.size) + 704 len ceil32(_597)]
        if ceil32(_597) > _597:
            mem[_597 + mem[64] + 352] = 0
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 416]
        mem[mem[64] + 96] = mem[ceil32(return_data.size) + 448]
        mem[mem[64] + 128] = mem[ceil32(return_data.size) + 480]
        mem[mem[64] + 160] = mem[ceil32(return_data.size) + 512]
        mem[mem[64] + 192] = mem[ceil32(return_data.size) + 544]
        mem[mem[64] + 224] = mem[ceil32(return_data.size) + 576]
        if mem[ceil32(return_data.size) + 608] >= 6:
            revert with 0, 33
        mem[mem[64] + 256] = mem[ceil32(return_data.size) + 608]
        if mem[ceil32(return_data.size) + 640] >= 6:
            revert with 0, 33
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 640]
        return 32, 288, mem[mem[64] + 64 len ceil32(_597) + 288]
    mem[_17 + ceil32(return_data.size) + 704] = 0
    mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
    mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
    mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
    mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
    mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
    mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
    mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
    require mem[_9 + 608] < 6
    mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
    require mem[_9 + 640] < 6
    mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
    _586 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = 288
    _598 = mem[ceil32(return_data.size) + 672]
    mem[mem[64] + 320] = mem[ceil32(return_data.size) + 672]
    mem[mem[64] + 352 len ceil32(_598)] = mem[ceil32(return_data.size) + 704 len ceil32(_598)]
    if ceil32(_598) <= _598:
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 416]
        mem[mem[64] + 96] = mem[ceil32(return_data.size) + 448]
        mem[mem[64] + 128] = mem[ceil32(return_data.size) + 480]
        mem[mem[64] + 160] = mem[ceil32(return_data.size) + 512]
        mem[mem[64] + 192] = mem[ceil32(return_data.size) + 544]
        mem[mem[64] + 224] = mem[ceil32(return_data.size) + 576]
        if mem[ceil32(return_data.size) + 608] >= 6:
            revert with 0, 33
        mem[mem[64] + 256] = mem[ceil32(return_data.size) + 608]
        if mem[ceil32(return_data.size) + 640] >= 6:
            revert with 0, 33
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 640]
        return 32, 288, mem[mem[64] + 64 len ceil32(_598) + 288]
    mem[_598 + mem[64] + 352] = 0
    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 416]
    mem[_586 + 96] = mem[ceil32(return_data.size) + 448]
    mem[_586 + 128] = mem[ceil32(return_data.size) + 480]
    mem[_586 + 160] = mem[ceil32(return_data.size) + 512]
    mem[_586 + 192] = mem[ceil32(return_data.size) + 544]
    mem[_586 + 224] = mem[ceil32(return_data.size) + 576]
    if mem[ceil32(return_data.size) + 608] >= 6:
        revert with 0, 33
    mem[_586 + 256] = mem[ceil32(return_data.size) + 608]
    if mem[ceil32(return_data.size) + 640] >= 6:
        revert with 0, 33
    mem[_586 + 288] = mem[ceil32(return_data.size) + 640]
    return memory
      from mem[64]
       len ceil32(_598) + _586 + -mem[64] + 352
}

function sub_cc72ba0f(?) payable {
    require calldata.size - 4 >= 64
    mem[0] = msg.sender
    mem[32] = 11
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    if arg2 <= arg1:
        mem[96] = 1
        mem[64] = 160
        mem[128] = 96
        mem[160] = 32
        mem[192] = 1
        idx = 0
        s = 128
        t = 224
        u = (32 * mem[96]) + 224
        while idx < 1:
            mem[t] = u - 224
            _63 = mem[s]
            _66 = mem[mem[s]]
            mem[u] = mem[mem[s]]
            v = 0
            while v < _66:
                mem[v + u + 32] = mem[v + _63 + 32]
                v = v + 32
                continue 
            if ceil32(_66) > _66:
                mem[_66 + u + 32] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_66) + u + 32
            continue 
    else:
        if arg2 < arg1:
            revert with 0, 17
        if 1 > !(arg2 - arg1):
            revert with 0, 17
        if arg2 + -arg1 + 1 > test266151307():
            revert with 0, 65
        mem[96] = arg2 + -arg1 + 1
        mem[64] = (32 * arg2 + -arg1 + 1) + 128
        if not arg2 + -arg1 + 1:
            idx = arg1
            while idx <= arg2:
                mem[0] = idx
                mem[32] = 13
                if bool(stor13[idx].field_0):
                    if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _70 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[idx].field_0)) * 0.5) + 32
                    mem[_70] = uint255(uint256(stor13[idx].field_0)) * 0.5
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_70 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_70 + 32] = uint256(stor13[idx].field_0)
                                s = _70 + 32
                                t = sha3(sha3(idx, 13))
                                while _70 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_70 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_70 + 32] = uint256(stor13[idx].field_0)
                                s = _70 + 32
                                t = sha3(sha3(idx, 13))
                                while _70 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _70
                else:
                    if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _75 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[idx].field_1 % 128) + 32
                    mem[_75] = stor13[idx].field_1 % 128
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_75 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_75 + 32] = uint256(stor13[idx].field_0)
                                s = _75 + 32
                                t = sha3(sha3(idx, 13))
                                while _75 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_75 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_75 + 32] = uint256(stor13[idx].field_0)
                                s = _75 + 32
                                t = sha3(sha3(idx, 13))
                                while _75 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _75
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _64 = mem[64]
            mem[mem[64]] = 32
            _67 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 64
            u = mem[64] + (32 * mem[96]) + 64
            while idx < _67:
                mem[t] = u + -_64 - 64
                _116 = mem[s]
                _120 = mem[mem[s]]
                mem[u] = mem[mem[s]]
                v = 0
                while v < _120:
                    mem[v + u + 32] = mem[v + _116 + 32]
                    v = v + 32
                    continue 
                if ceil32(_120) > _120:
                    mem[_120 + u + 32] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_120) + u + 32
                continue 
        else:
            mem[128] = 96
            s = 128
            idx = arg2 + -arg1 + 1
            while idx - 1:
                mem[s + 32] = 96
                s = s + 32
                idx = idx - 1
                continue 
            idx = arg1
            while idx <= arg2:
                mem[0] = idx
                mem[32] = 13
                if bool(stor13[idx].field_0):
                    if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _129 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[idx].field_0)) * 0.5) + 32
                    mem[_129] = uint255(uint256(stor13[idx].field_0)) * 0.5
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_129 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_129 + 32] = uint256(stor13[idx].field_0)
                                s = _129 + 32
                                t = sha3(sha3(idx, 13))
                                while _129 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_129 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_129 + 32] = uint256(stor13[idx].field_0)
                                s = _129 + 32
                                t = sha3(sha3(idx, 13))
                                while _129 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _129
                else:
                    if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _132 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[idx].field_1 % 128) + 32
                    mem[_132] = stor13[idx].field_1 % 128
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_132 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_132 + 32] = uint256(stor13[idx].field_0)
                                s = _132 + 32
                                t = sha3(sha3(idx, 13))
                                while _132 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_132 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_132 + 32] = uint256(stor13[idx].field_0)
                                s = _132 + 32
                                t = sha3(sha3(idx, 13))
                                while _132 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _132
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _121 = mem[64]
            mem[mem[64]] = 32
            _122 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 64
            u = mem[64] + (32 * mem[96]) + 64
            while idx < _122:
                mem[t] = u + -_121 - 64
                _151 = mem[s]
                _153 = mem[mem[s]]
                mem[u] = mem[mem[s]]
                v = 0
                while v < _153:
                    mem[v + u + 32] = mem[v + _151 + 32]
                    v = v + 32
                    continue 
                if ceil32(_153) > _153:
                    mem[_153 + u + 32] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_153) + u + 32
                continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function updateName(uint256 arg1, string arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    mem[ceil32(ceil32(arg2.length)) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(ceil32(arg2.length)) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    mem[ceil32(ceil32(arg2.length)) + ceil32(return_data.size) + 101] = arg1
    require ext_code.size(stor8)
    staticcall stor8.ownerOf(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(ceil32(arg2.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'Not owner'
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 97] = 96
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 129] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 161] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 193] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 225] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 257] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 289] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 321] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 353] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 705
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 673 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 705
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + stor13[arg1].field_1 % 128 + 673 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        uint8(stor13[arg1].field_1792) = uint8(stor13[arg1].field_1792)
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = uint8(stor13[arg1].field_1800)
    else:
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 389] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0x36dac2cc with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require return_data.size - mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 >= 288
        if not bool(ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673 <= test266151307()):
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673
        _25 = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] <= test266151307()
        require ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 416 < ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + return_data.size + 385
        _30 = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385]
        if mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 289 < 288 or ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 674 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 674
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + _25 + _30 + 32 <= return_data.size
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 705 len ceil32(_30)] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + _25 + 417 len ceil32(_30)]
        if ceil32(_30) > _30:
            mem[_30 + ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 705] = 0
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 417]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 449]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 481] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 481]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 513] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 513]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 545] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 545]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 577] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 577]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 609] < 6
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 609]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 641] < 6
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 641] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 641]
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        uint256(stor13[arg1].field_256) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417]
        uint256(stor13[arg1].field_512) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449]
        uint256(stor13[arg1].field_768) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 481]
        uint256(stor13[arg1].field_1024) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 513]
        uint256(stor13[arg1].field_1280) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 545]
        uint256(stor13[arg1].field_1536) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 577]
        if mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609] > 5:
            revert with 0, 33
        uint256(stor13[arg1].field_1792) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609]
        if mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 641] > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 642 len 31]
}

function getPendingReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[100] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    mem[ceil32(return_data.size) + 96] = 96
    mem[ceil32(return_data.size) + 128] = 0
    mem[ceil32(return_data.size) + 160] = 0
    mem[ceil32(return_data.size) + 192] = 0
    mem[ceil32(return_data.size) + 224] = 0
    mem[ceil32(return_data.size) + 256] = 0
    mem[ceil32(return_data.size) + 288] = 0
    mem[ceil32(return_data.size) + 320] = 0
    mem[ceil32(return_data.size) + 352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = ceil32(return_data.size) + 704
                    s = 0
                    while ceil32(return_data.size) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = ceil32(return_data.size) + 704
                    s = 0
                    while ceil32(return_data.size) + stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 4:
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600))
        if uint8(stor13[arg1].field_1800) != 5:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600))
        if sub_ded2abc3[arg1]:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if block.timestamp < uint256(stor13[arg1].field_768):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) == 5:
            if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                revert with 0, 17
            if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600))
        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
            revert with 0, 17
        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
            revert with 0, 17
        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
        else:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if uint8(stor13[arg1].field_1800) != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint256(stor13[arg1].field_768) > !stor3.length:
            revert with 0, 17
        return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600))
    mem[ceil32(return_data.size) + 384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _15 = mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32
    require mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool((2 * ceil32(return_data.size)) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + 672
    _18 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < ceil32(return_data.size) + return_data.size + 384
    _23 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[(2 * ceil32(return_data.size)) + 672] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    require mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + _18 + _23 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 704 len ceil32(_23)] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + _18 + 416 len ceil32(_23)]
    if ceil32(_23) <= _23:
        mem[(2 * ceil32(return_data.size)) + 384] = (2 * ceil32(return_data.size)) + 672
        mem[(2 * ceil32(return_data.size)) + 416] = mem[ceil32(return_data.size) + _15 + 416]
        mem[(2 * ceil32(return_data.size)) + 448] = mem[ceil32(return_data.size) + _15 + 448]
        mem[(2 * ceil32(return_data.size)) + 480] = mem[ceil32(return_data.size) + _15 + 480]
        mem[(2 * ceil32(return_data.size)) + 512] = mem[ceil32(return_data.size) + _15 + 512]
        mem[(2 * ceil32(return_data.size)) + 544] = mem[ceil32(return_data.size) + _15 + 544]
        mem[(2 * ceil32(return_data.size)) + 576] = mem[ceil32(return_data.size) + _15 + 576]
        require mem[ceil32(return_data.size) + _15 + 608] < 6
        mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + _15 + 608]
        require mem[ceil32(return_data.size) + _15 + 640] < 6
        mem[(2 * ceil32(return_data.size)) + 640] = mem[ceil32(return_data.size) + _15 + 640]
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 4:
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3147 = mem[(2 * ceil32(return_data.size)) + 544]
                _3159 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor5.length:
                    revert with 0, 17
                _3267 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3643 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3643] > -1 / _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3703 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3703] > -1 / _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3704 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3704] > -1 / _3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3267 + ((block.timestamp * _3147 * stor5.length) - (_3159 * _3147 * stor5.length) / 10000 / 24 * 3600))
            _3148 = mem[(2 * ceil32(return_data.size)) + 448]
            _3160 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor5.length:
                revert with 0, 17
            _3268 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3648 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3648] > -1 / _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3706 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3706] > -1 / _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3707 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3707] > -1 / _3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3268 + ((block.timestamp * _3148 * stor5.length) - (_3160 * _3148 * stor5.length) / 10000 / 24 * 3600))
        if mem[(2 * ceil32(return_data.size)) + 640] != 5:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3166 = mem[(2 * ceil32(return_data.size)) + 544]
                _3173 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor4.length:
                    revert with 0, 17
                _3351 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3713 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600) and mem[_3713] > -1 / _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3791 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600) and mem[_3791] > -1 / _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3792 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600) and mem[_3792] > -1 / _3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3351 + ((block.timestamp * _3166 * stor4.length) - (_3173 * _3166 * stor4.length) / 10000 / 24 * 3600))
            _3167 = mem[(2 * ceil32(return_data.size)) + 448]
            _3174 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor4.length:
                revert with 0, 17
            _3352 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3718 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600) and mem[_3718] > -1 / _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3794 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600) and mem[_3794] > -1 / _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3795 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600) and mem[_3795] > -1 / _3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3352 + ((block.timestamp * _3167 * stor4.length) - (_3174 * _3167 * stor4.length) / 10000 / 24 * 3600))
        mem[0] = arg1
        mem[32] = 12
        if sub_ded2abc3[arg1]:
            mem[0] = arg1
            mem[32] = 12
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3171 = mem[(2 * ceil32(return_data.size)) + 544]
                _3179 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                    revert with 0, 17
                _3421 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3763 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3763] > -1 / _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3823 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3823] > -1 / _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3824 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3824] > -1 / _3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3421 + ((block.timestamp * _3171 * sub_ded2abc3[arg1]) - (_3179 * _3171 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
            _3172 = mem[(2 * ceil32(return_data.size)) + 448]
            _3180 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3422 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3768 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3768] > -1 / _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3826 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3826] > -1 / _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3827 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3827] > -1 / _3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3422 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3180 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        mem[mem[64] + 4] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3165 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3181 = mem[_3165]
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3195 = mem[(2 * ceil32(return_data.size)) + 544]
            _3207 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and mem[_3165] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * mem[_3165] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * mem[_3165]:
                revert with 0, 17
            _3591 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3165]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3165]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3911 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600) and mem[_3911] > -1 / _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600) and mem[_3967] > -1 / _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3968 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600) and mem[_3968] > -1 / _3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3591 + ((block.timestamp * _3195 * _3181) - (_3207 * _3195 * _3181) / 10000 / 24 * 3600))
        _3196 = mem[(2 * ceil32(return_data.size)) + 448]
        _3208 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and mem[_3165] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * mem[_3165] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * mem[_3165]:
            revert with 0, 17
        _3592 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3165]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3165]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3916 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600) and mem[_3916] > -1 / _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3970 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600) and mem[_3970] > -1 / _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3971 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600) and mem[_3971] > -1 / _3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3592 + ((block.timestamp * _3196 * _3181) - (_3208 * _3196 * _3181) / 10000 / 24 * 3600))
    mem[_23 + (2 * ceil32(return_data.size)) + 704] = 0
    mem[(2 * ceil32(return_data.size)) + 384] = (2 * ceil32(return_data.size)) + 672
    mem[(2 * ceil32(return_data.size)) + 416] = mem[ceil32(return_data.size) + _15 + 416]
    mem[(2 * ceil32(return_data.size)) + 448] = mem[ceil32(return_data.size) + _15 + 448]
    mem[(2 * ceil32(return_data.size)) + 480] = mem[ceil32(return_data.size) + _15 + 480]
    mem[(2 * ceil32(return_data.size)) + 512] = mem[ceil32(return_data.size) + _15 + 512]
    mem[(2 * ceil32(return_data.size)) + 544] = mem[ceil32(return_data.size) + _15 + 544]
    mem[(2 * ceil32(return_data.size)) + 576] = mem[ceil32(return_data.size) + _15 + 576]
    require mem[ceil32(return_data.size) + _15 + 608] < 6
    mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + _15 + 608]
    require mem[ceil32(return_data.size) + _15 + 640] < 6
    mem[(2 * ceil32(return_data.size)) + 640] = mem[ceil32(return_data.size) + _15 + 640]
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 4:
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3153 = mem[(2 * ceil32(return_data.size)) + 544]
            _3162 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor5.length:
                revert with 0, 17
            _3269 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3657 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600) and mem[_3657] > -1 / _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3719 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600) and mem[_3719] > -1 / _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3720 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600) and mem[_3720] > -1 / _3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3269 + ((block.timestamp * _3153 * stor5.length) - (_3162 * _3153 * stor5.length) / 10000 / 24 * 3600))
        _3154 = mem[(2 * ceil32(return_data.size)) + 448]
        _3163 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor5.length:
            revert with 0, 17
        _3270 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3662 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600) and mem[_3662] > -1 / _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3722 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600) and mem[_3722] > -1 / _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3723 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600) and mem[_3723] > -1 / _3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3270 + ((block.timestamp * _3154 * stor5.length) - (_3163 * _3154 * stor5.length) / 10000 / 24 * 3600))
    if mem[(2 * ceil32(return_data.size)) + 640] != 5:
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3169 = mem[(2 * ceil32(return_data.size)) + 544]
            _3177 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor4.length:
                revert with 0, 17
            _3353 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3729 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600) and mem[_3729] > -1 / _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3801 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600) and mem[_3801] > -1 / _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3802 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600) and mem[_3802] > -1 / _3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3353 + ((block.timestamp * _3169 * stor4.length) - (_3177 * _3169 * stor4.length) / 10000 / 24 * 3600))
        _3170 = mem[(2 * ceil32(return_data.size)) + 448]
        _3178 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor4.length:
            revert with 0, 17
        _3354 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3734 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600) and mem[_3734] > -1 / _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3804 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600) and mem[_3804] > -1 / _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3805 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600) and mem[_3805] > -1 / _3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3354 + ((block.timestamp * _3170 * stor4.length) - (_3178 * _3170 * stor4.length) / 10000 / 24 * 3600))
    mem[0] = arg1
    mem[32] = 12
    if sub_ded2abc3[arg1]:
        mem[0] = arg1
        mem[32] = 12
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3175 = mem[(2 * ceil32(return_data.size)) + 544]
            _3182 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3425 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3773 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3773] > -1 / _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3829 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3829] > -1 / _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3830 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3830] > -1 / _3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3425 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3182 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        _3176 = mem[(2 * ceil32(return_data.size)) + 448]
        _3183 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
            revert with 0, 17
        _3426 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3778 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3778] > -1 / _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3832 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3832] > -1 / _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3833 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3833] > -1 / _3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3426 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3183 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
    mem[mem[64] + 4] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0xded2abc3 with:
            gas gas_remaining wei
           args arg1
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3168 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3184 = mem[_3168]
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 5:
        _3197 = mem[(2 * ceil32(return_data.size)) + 544]
        _3209 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 544] and mem[_3168] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]:
            revert with 0, 17
        _3597 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3921 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600) and mem[_3921] > -1 / _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3973 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600) and mem[_3973] > -1 / _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600) and mem[_3974] > -1 / _3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3597 + ((block.timestamp * _3197 * _3184) - (_3209 * _3197 * _3184) / 10000 / 24 * 3600))
    _3198 = mem[(2 * ceil32(return_data.size)) + 448]
    _3210 = mem[(2 * ceil32(return_data.size)) + 480]
    if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 448] and mem[_3168] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]:
        revert with 0, 17
    _3598 = mem[(2 * ceil32(return_data.size)) + 512]
    if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 5:
        require ext_code.size(stor8)
        staticcall stor8.0xe5d76232 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3926 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600) and mem[_3926] > -1 / _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600):
            revert with 0, 17
    else:
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[(2 * ceil32(return_data.size)) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3976 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600) and mem[_3976] > -1 / _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3977 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600) and mem[_3977] > -1 / _3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600):
                revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
        revert with 0, 17
    return (_3598 + ((block.timestamp * _3198 * _3184) - (_3210 * _3198 * _3184) / 10000 / 24 * 3600))
}

function sub_d34db045(?) payable {
    require calldata.size - 4 >= 32
    mem[96] = 96
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = 704
                    s = 0
                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = 704
                    s = 0
                    while stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 4:
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
        if uint8(stor13[arg1].field_1800) != 5:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
            if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
        if sub_ded2abc3[arg1]:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
            if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if block.timestamp < uint256(stor13[arg1].field_768):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) == 5:
            if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                revert with 0, 17
            if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
            revert with 0, 17
        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
            revert with 0, 17
        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
        else:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if uint8(stor13[arg1].field_1800) != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint256(stor13[arg1].field_768) > !stor3.length:
            revert with 0, 17
        return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600), 
               (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
               uint256(stor13[arg1].field_768) + stor3.length >= block.timestamp
    mem[384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _9 = mem[384 len 4], Mask(224, 32, arg1) >> 32
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool(ceil32(return_data.size) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + 672
    _12 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < return_data.size + 384
    _17 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[ceil32(return_data.size) + 672] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + _17 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 704 len ceil32(_17)] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + 416 len ceil32(_17)]
    if ceil32(_17) <= _17:
        mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
        mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
        mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
        mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
        mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
        mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
        mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
        require mem[_9 + 608] < 6
        mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
        require mem[_9 + 640] < 6
        mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 4:
            if mem[ceil32(return_data.size) + 640] == 5:
                _3141 = mem[ceil32(return_data.size) + 544]
                _3153 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and stor5.length > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor5.length:
                    revert with 0, 17
                _3261 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3637 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600) and mem[_3637] > -1 / _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600), 
                           (_3261 * mem[_3637]) + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600 * mem[_3637]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3697 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600) and mem[_3697] > -1 / _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600), 
                           (_3261 * mem[_3697]) + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600 * mem[_3697]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3698 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600) and mem[_3698] > -1 / _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3261 + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600), 
                       (_3261 * mem[_3698]) + ((block.timestamp * _3141 * stor5.length) - (_3153 * _3141 * stor5.length) / 10000 / 24 * 3600 * mem[_3698]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            _3142 = mem[ceil32(return_data.size) + 448]
            _3154 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and stor5.length > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor5.length:
                revert with 0, 17
            _3262 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3642 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600) and mem[_3642] > -1 / _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600), 
                       (_3262 * mem[_3642]) + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600 * mem[_3642]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3700 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600) and mem[_3700] > -1 / _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600), 
                       (_3262 * mem[_3700]) + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600 * mem[_3700]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3701 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600) and mem[_3701] > -1 / _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3262 + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600), 
                   (_3262 * mem[_3701]) + ((block.timestamp * _3142 * stor5.length) - (_3154 * _3142 * stor5.length) / 10000 / 24 * 3600 * mem[_3701]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] != 5:
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                _3160 = mem[ceil32(return_data.size) + 544]
                _3167 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and stor4.length > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor4.length:
                    revert with 0, 17
                _3345 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3707 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600) and mem[_3707] > -1 / _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600), 
                           (_3345 * mem[_3707]) + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600 * mem[_3707]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600) and mem[_3785] > -1 / _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600), 
                           (_3345 * mem[_3785]) + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600 * mem[_3785]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3786 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600) and mem[_3786] > -1 / _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3345 + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600), 
                       (_3345 * mem[_3786]) + ((block.timestamp * _3160 * stor4.length) - (_3167 * _3160 * stor4.length) / 10000 / 24 * 3600 * mem[_3786]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            _3161 = mem[ceil32(return_data.size) + 448]
            _3168 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and stor4.length > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor4.length:
                revert with 0, 17
            _3346 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3712 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600) and mem[_3712] > -1 / _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600), 
                       (_3346 * mem[_3712]) + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600 * mem[_3712]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3788 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600) and mem[_3788] > -1 / _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600), 
                       (_3346 * mem[_3788]) + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600 * mem[_3788]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3789 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600) and mem[_3789] > -1 / _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3346 + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600), 
                   (_3346 * mem[_3789]) + ((block.timestamp * _3161 * stor4.length) - (_3168 * _3161 * stor4.length) / 10000 / 24 * 3600 * mem[_3789]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        mem[0] = arg1
        mem[32] = 12
        if sub_ded2abc3[arg1]:
            mem[0] = arg1
            mem[32] = 12
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                _3165 = mem[ceil32(return_data.size) + 544]
                _3173 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]:
                    revert with 0, 17
                _3415 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3757 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3757] > -1 / _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                           (_3415 * mem[_3757]) + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3757]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3817 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3817] > -1 / _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                           (_3415 * mem[_3817]) + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3817]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3818 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3818] > -1 / _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3415 + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3415 * mem[_3818]) + ((block.timestamp * _3165 * sub_ded2abc3[arg1]) - (_3173 * _3165 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3818]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            _3166 = mem[ceil32(return_data.size) + 448]
            _3174 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3416 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3762 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3762] > -1 / _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3416 * mem[_3762]) + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3762]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3820 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3820] > -1 / _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3416 * mem[_3820]) + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3820]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3821 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3821] > -1 / _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3416 + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3416 * mem[_3821]) + ((block.timestamp * _3166 * sub_ded2abc3[arg1]) - (_3174 * _3166 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3821]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        mem[mem[64] + 4] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3159 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3175 = mem[_3159]
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3189 = mem[ceil32(return_data.size) + 544]
            _3201 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and mem[_3159] > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * mem[_3159] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * mem[_3159]:
                revert with 0, 17
            _3585 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * mem[_3159]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * mem[_3159]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3921 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600) and mem[_3921] > -1 / _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600), 
                       (_3585 * mem[_3921]) + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600 * mem[_3921]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3993 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600) and mem[_3993] > -1 / _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600), 
                       (_3585 * mem[_3993]) + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600 * mem[_3993]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3994 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600) and mem[_3994] > -1 / _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3585 + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600), 
                   (_3585 * mem[_3994]) + ((block.timestamp * _3189 * _3175) - (_3201 * _3189 * _3175) / 10000 / 24 * 3600 * mem[_3994]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        _3190 = mem[ceil32(return_data.size) + 448]
        _3202 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and mem[_3159] > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * mem[_3159] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * mem[_3159]:
            revert with 0, 17
        _3586 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * mem[_3159]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * mem[_3159]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3926 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600) and mem[_3926] > -1 / _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600), 
                   (_3586 * mem[_3926]) + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600 * mem[_3926]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3996 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600) and mem[_3996] > -1 / _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600), 
                   (_3586 * mem[_3996]) + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600 * mem[_3996]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3997 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600) and mem[_3997] > -1 / _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3586 + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600), 
               (_3586 * mem[_3997]) + ((block.timestamp * _3190 * _3175) - (_3202 * _3190 * _3175) / 10000 / 24 * 3600 * mem[_3997]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    mem[_17 + ceil32(return_data.size) + 704] = 0
    mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
    mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
    mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
    mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
    mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
    mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
    mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
    require mem[_9 + 608] < 6
    mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
    require mem[_9 + 640] < 6
    mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 4:
        if mem[ceil32(return_data.size) + 640] == 5:
            _3147 = mem[ceil32(return_data.size) + 544]
            _3156 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and stor5.length > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor5.length:
                revert with 0, 17
            _3263 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3651 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3651] > -1 / _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600), 
                       (_3263 * mem[_3651]) + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600 * mem[_3651]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3713 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3713] > -1 / _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600), 
                       (_3263 * mem[_3713]) + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600 * mem[_3713]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3714 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600) and mem[_3714] > -1 / _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3263 + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600), 
                   (_3263 * mem[_3714]) + ((block.timestamp * _3147 * stor5.length) - (_3156 * _3147 * stor5.length) / 10000 / 24 * 3600 * mem[_3714]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        _3148 = mem[ceil32(return_data.size) + 448]
        _3157 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and stor5.length > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor5.length:
            revert with 0, 17
        _3264 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3656 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3656] > -1 / _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600), 
                   (_3264 * mem[_3656]) + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600 * mem[_3656]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3716 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3716] > -1 / _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600), 
                   (_3264 * mem[_3716]) + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600 * mem[_3716]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3717 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600) and mem[_3717] > -1 / _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3264 + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600), 
               (_3264 * mem[_3717]) + ((block.timestamp * _3148 * stor5.length) - (_3157 * _3148 * stor5.length) / 10000 / 24 * 3600 * mem[_3717]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    if mem[ceil32(return_data.size) + 640] != 5:
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3163 = mem[ceil32(return_data.size) + 544]
            _3171 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and stor4.length > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor4.length:
                revert with 0, 17
            _3347 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3723 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600) and mem[_3723] > -1 / _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600), 
                       (_3347 * mem[_3723]) + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600 * mem[_3723]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3795 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600) and mem[_3795] > -1 / _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600), 
                       (_3347 * mem[_3795]) + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600 * mem[_3795]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3796 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600) and mem[_3796] > -1 / _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3347 + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600), 
                   (_3347 * mem[_3796]) + ((block.timestamp * _3163 * stor4.length) - (_3171 * _3163 * stor4.length) / 10000 / 24 * 3600 * mem[_3796]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        _3164 = mem[ceil32(return_data.size) + 448]
        _3172 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and stor4.length > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor4.length:
            revert with 0, 17
        _3348 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3728 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600) and mem[_3728] > -1 / _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600), 
                   (_3348 * mem[_3728]) + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600 * mem[_3728]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3798 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600) and mem[_3798] > -1 / _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600), 
                   (_3348 * mem[_3798]) + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600 * mem[_3798]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3799 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600) and mem[_3799] > -1 / _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3348 + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600), 
               (_3348 * mem[_3799]) + ((block.timestamp * _3164 * stor4.length) - (_3172 * _3164 * stor4.length) / 10000 / 24 * 3600 * mem[_3799]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    mem[0] = arg1
    mem[32] = 12
    if sub_ded2abc3[arg1]:
        mem[0] = arg1
        mem[32] = 12
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3169 = mem[ceil32(return_data.size) + 544]
            _3176 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3419 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3767 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3767] > -1 / _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3419 * mem[_3767]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3767]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3823 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3823] > -1 / _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3419 * mem[_3823]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3823]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3824 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3824] > -1 / _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3419 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3419 * mem[_3824]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3176 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3824]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        _3170 = mem[ceil32(return_data.size) + 448]
        _3177 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]:
            revert with 0, 17
        _3420 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3772 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3772] > -1 / _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3420 * mem[_3772]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3772]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3826 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3826] > -1 / _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3420 * mem[_3826]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3826]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3827 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3827] > -1 / _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3420 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
               (_3420 * mem[_3827]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3177 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3827]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    mem[mem[64] + 4] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0xded2abc3 with:
            gas gas_remaining wei
           args arg1
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3162 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3178 = mem[_3162]
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 5:
        _3191 = mem[ceil32(return_data.size) + 544]
        _3203 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 544] and mem[_3162] > -1 / mem[ceil32(return_data.size) + 544]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 544] * mem[_3162] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * mem[_3162]:
            revert with 0, 17
        _3591 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * mem[_3162]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * mem[_3162]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3931 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600) and mem[_3931] > -1 / _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600), 
                   (_3591 * mem[_3931]) + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600 * mem[_3931]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3999 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600) and mem[_3999] > -1 / _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600), 
                   (_3591 * mem[_3999]) + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600 * mem[_3999]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4000 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600) and mem[_4000] > -1 / _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3591 + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600), 
               (_3591 * mem[_4000]) + ((block.timestamp * _3191 * _3178) - (_3203 * _3191 * _3178) / 10000 / 24 * 3600 * mem[_4000]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    _3192 = mem[ceil32(return_data.size) + 448]
    _3204 = mem[ceil32(return_data.size) + 480]
    if block.timestamp < mem[ceil32(return_data.size) + 480]:
        revert with 0, 17
    if mem[ceil32(return_data.size) + 448] and mem[_3162] > -1 / mem[ceil32(return_data.size) + 448]:
        revert with 0, 17
    if mem[ceil32(return_data.size) + 448] * mem[_3162] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * mem[_3162]:
        revert with 0, 17
    _3592 = mem[ceil32(return_data.size) + 512]
    if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * mem[_3162]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * mem[_3162]) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 5:
        require ext_code.size(stor8)
        staticcall stor8.0xe5d76232 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3936 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600) and mem[_3936] > -1 / _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600), 
               (_3592 * mem[_3936]) + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600 * mem[_3936]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    require ext_code.size(stor8)
    if mem[ceil32(return_data.size) + 640] != 4:
        staticcall stor8.0xae55ae5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4002 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600) and mem[_4002] > -1 / _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600), 
               (_3592 * mem[_4002]) + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600 * mem[_4002]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
    staticcall stor8.0x1ec4a4a8 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _4003 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600) and mem[_4003] > -1 / _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[ceil32(return_data.size) + 480] > !stor3.length:
        revert with 0, 17
    return _3592 + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600), 
           (_3592 * mem[_4003]) + ((block.timestamp * _3192 * _3178) - (_3204 * _3192 * _3178) / 10000 / 24 * 3600 * mem[_4003]) / 10000,
           mem[ceil32(return_data.size) + 480] + stor3.length >= block.timestamp
}

function sub_162c3e16(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + ('cd', 4).length + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    s = cd[36] + 36
    t = 128
    idx = 0
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    mem[ceil32(32 * ('cd', 36).length) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(32 * ('cd', 36).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    if ('cd', 36).length != 4:
        revert with 0, 'Invalid array'
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 128] = call.data[calldata.size len 128]
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 641
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 353] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 417] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 449] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 481] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 513] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 545] = 0
    mem[var43002] = 0
    mem[var43002 + 32] = 0
    mem[var45002] = var45001
    if not var45003 - 1:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _710 = mem[(32 * uint8(idx)) + 128]
            _712 = mem[64]
            mem[64] = mem[64] + 288
            mem[_712] = 96
            mem[_712 + 32] = 0
            mem[_712 + 64] = 0
            mem[_712 + 96] = 0
            mem[_712 + 128] = 0
            mem[_712 + 160] = 0
            mem[_712 + 192] = 0
            mem[_712 + 224] = 0
            mem[_712 + 256] = 0
            mem[0] = _710
            mem[32] = 13
            if uint256(stor13[_710].field_512):
                mem[0] = _710
                mem[32] = 13
                _722 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_710].field_0):
                    if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _732 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_710].field_0)) * 0.5) + 32
                    mem[_732] = uint255(uint256(stor13[_710].field_0)) * 0.5
                    if bool(stor13[_710].field_0):
                        if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_710].field_0)):
                            if 31 >= uint255(uint256(stor13[_710].field_0)) * 0.5:
                                mem[_732 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_732 + 32] = uint256(stor13[_710].field_0)
                                s = _732 + 32
                                t = sha3(sha3(_710, 13))
                                while _732 + (uint255(uint256(stor13[_710].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_710].field_1 % 128:
                            if 31 >= stor13[_710].field_1 % 128:
                                mem[_732 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_732 + 32] = uint256(stor13[_710].field_0)
                                s = _732 + 32
                                t = sha3(sha3(_710, 13))
                                while _732 + stor13[_710].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_722] = _732
                else:
                    if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                        revert with 0, 34
                    _735 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_710].field_1 % 128) + 32
                    mem[_735] = stor13[_710].field_1 % 128
                    if bool(stor13[_710].field_0):
                        if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_710].field_0)):
                            if 31 >= uint255(uint256(stor13[_710].field_0)) * 0.5:
                                mem[_735 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_735 + 32] = uint256(stor13[_710].field_0)
                                s = _735 + 32
                                t = sha3(sha3(_710, 13))
                                while _735 + (uint255(uint256(stor13[_710].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_710].field_1 % 128:
                            if 31 >= stor13[_710].field_1 % 128:
                                mem[_735 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_735 + 32] = uint256(stor13[_710].field_0)
                                s = _735 + 32
                                t = sha3(sha3(_710, 13))
                                while _735 + stor13[_710].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_722] = _735
                mem[_722 + 32] = uint256(stor13[_710].field_256)
                mem[_722 + 64] = uint256(stor13[_710].field_512)
                mem[_722 + 96] = uint256(stor13[_710].field_768)
                mem[_722 + 128] = uint256(stor13[_710].field_1024)
                mem[_722 + 160] = uint256(stor13[_710].field_1280)
                mem[_722 + 192] = uint256(stor13[_710].field_1536)
                if uint8(stor13[_710].field_1792) > 5:
                    revert with 0, 33
                mem[_722 + 224] = uint8(stor13[_710].field_1792)
                if uint8(stor13[_710].field_1800) > 5:
                    revert with 0, 33
                mem[_722 + 256] = uint8(stor13[_710].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _722
                if uint256(stor13[_710].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_710].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_710].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _710
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _710
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _730 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _733 = mem[_730]
                require mem[_730] <= test266151307()
                require return_data.size - mem[_730] >= 288
                if not bool(_730 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _730 + ceil32(return_data.size) + 288
                _744 = mem[_730 + _733]
                require mem[_730 + _733] <= test266151307()
                require _730 + _733 + mem[_730 + _733] + 31 < _730 + return_data.size
                _754 = mem[_730 + _733 + mem[_730 + _733]]
                if mem[_730 + _733 + mem[_730 + _733]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289 < 288 or _730 + ceil32(return_data.size) + ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _730 + ceil32(return_data.size) + ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289
                mem[_730 + ceil32(return_data.size) + 288] = _754
                require _733 + _744 + _754 + 32 <= return_data.size
                s = 0
                while s < _754:
                    mem[s + _730 + ceil32(return_data.size) + 320] = mem[s + _730 + _733 + _744 + 32]
                    s = s + 32
                    continue 
                if ceil32(_754) > _754:
                    mem[_754 + _730 + ceil32(return_data.size) + 320] = 0
                mem[_730 + ceil32(return_data.size)] = _730 + ceil32(return_data.size) + 288
                mem[_730 + ceil32(return_data.size) + 32] = mem[_730 + _733 + 32]
                mem[_730 + ceil32(return_data.size) + 64] = mem[_730 + _733 + 64]
                mem[_730 + ceil32(return_data.size) + 96] = mem[_730 + _733 + 96]
                mem[_730 + ceil32(return_data.size) + 128] = mem[_730 + _733 + 128]
                mem[_730 + ceil32(return_data.size) + 160] = mem[_730 + _733 + 160]
                mem[_730 + ceil32(return_data.size) + 192] = mem[_730 + _733 + 192]
                require mem[_730 + _733 + 224] < 6
                mem[_730 + ceil32(return_data.size) + 224] = mem[_730 + _733 + 224]
                require mem[_730 + _733 + 256] < 6
                mem[_730 + ceil32(return_data.size) + 256] = mem[_730 + _733 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _730 + ceil32(return_data.size)
                if mem[_730 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_730 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_730 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _728 = mem[64]
        mem[64] = mem[64] + 128
        mem[_728 len 128] = call.data[calldata.size len 128]
        idx = 0
        s = 0
        t = 0
        while uint8(idx) < 4:
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            mem[(32 * uint8(idx)) + _728] = uint8(mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _1380 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if t > !mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            _1415 = mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _1431 = mem[(32 * uint8(idx)) + 128]
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1445 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1457 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _1580 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1819 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1819] > -1 / _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2016 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2016
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2016, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1843 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1843] > -1 / _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2021 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2021
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2021, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1844 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1844] > -1 / _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2032 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2032
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2032, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _1580 + ((block.timestamp * _1445 * stor5.length) - (_1457 * _1445 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                _1446 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1458 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _1581 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1824 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600) and mem[_1824] > -1 / _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2019 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2019
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2019, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1846 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600) and mem[_1846] > -1 / _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2025 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2025
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2025, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1847 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600) and mem[_1847] > -1 / _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _2035 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _2035
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _2035, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                    uint256(stor[u].field_0) = 0
                    u = u + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                s = s + _1581 + ((block.timestamp * _1446 * stor5.length) - (_1458 * _1446 * stor5.length) / 10000 / 24 * 3600)
                t = t + _1380
                continue 
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1464 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1477 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _1624 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1853 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600) and mem[_1853] > -1 / _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2040 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2040
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2040, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1877 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600) and mem[_1877] > -1 / _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2055 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2055
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2055, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                                t = t + _1380
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1878 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600) and mem[_1878] > -1 / _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2078 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2078
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2078, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1624 + ((block.timestamp * _1464 * stor4.length) - (_1477 * _1464 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                _1465 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1478 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _1625 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1858 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600) and mem[_1858] > -1 / _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2043 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2043
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2043, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1880 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600) and mem[_1880] > -1 / _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2059 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2059
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2059, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1881 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600) and mem[_1881] > -1 / _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2081 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2081
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2081, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _1625 + ((block.timestamp * _1465 * stor4.length) - (_1478 * _1465 * stor4.length) / 10000 / 24 * 3600)
                t = t + _1380
                continue 
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 12
                _1447 = sha3(mem[(32 * uint8(idx)) + 128], 12)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1475 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1481 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                        revert with 0, 17
                    _1676 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1865 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1865] > -1 / _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2050 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2050
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2050, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                                t = t + _1380
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1889 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1889] > -1 / _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _2069 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _2069
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _2069, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1890 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1890] > -1 / _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _2090 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _2090
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _2090, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _1676 + ((block.timestamp * _1475 * uint256(stor[_1447].field_0)) - (_1481 * _1475 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                    t = t + _1380
                    continue 
                _1476 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1482 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                    revert with 0, 17
                _1677 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1870 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1870] > -1 / _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2053 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2053
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2053, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                            t = t + _1380
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                        t = t + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1892 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1892] > -1 / _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2073 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2073
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2073, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1893 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600) and mem[_1893] > -1 / _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2093 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2093
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2093, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _1677 + ((block.timestamp * _1476 * uint256(stor[_1447].field_0)) - (_1482 * _1476 * uint256(stor[_1447].field_0)) / 10000 / 24 * 3600)
                t = t + _1380
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(idx)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _1431
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1463 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1483 = mem[_1463]
            if mem[_1415 + 256] > 5:
                revert with 0, 33
            if mem[_1415 + 256] == 5:
                _1497 = mem[_1415 + 160]
                _1500 = mem[_1415 + 96]
                if block.timestamp < mem[_1415 + 96]:
                    revert with 0, 17
                if mem[_1415 + 160] and mem[_1463] > -1 / mem[_1415 + 160]:
                    revert with 0, 17
                if mem[_1415 + 160] * mem[_1463] and block.timestamp - mem[_1415 + 96] > -1 / mem[_1415 + 160] * mem[_1463]:
                    revert with 0, 17
                _1795 = mem[_1415 + 128]
                if mem[_1415 + 128] > !((block.timestamp * mem[_1415 + 160] * mem[_1463]) - (mem[_1415 + 96] * mem[_1415 + 160] * mem[_1463]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_1415 + 256] > 5:
                    revert with 0, 33
                if mem[_1415 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600) and mem[_1955] > -1 / _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2134 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2134
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2134, msg.sender
                else:
                    if mem[_1415 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_1415 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1993 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600) and mem[_1993] > -1 / _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2147 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2147
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2147, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1994 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600) and mem[_1994] > -1 / _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _2158 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2158
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2158, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _1795 + ((block.timestamp * _1497 * _1483) - (_1500 * _1497 * _1483) / 10000 / 24 * 3600)
                t = t + _1380
                continue 
            _1498 = mem[_1415 + 64]
            _1501 = mem[_1415 + 96]
            if block.timestamp < mem[_1415 + 96]:
                revert with 0, 17
            if mem[_1415 + 64] and mem[_1463] > -1 / mem[_1415 + 64]:
                revert with 0, 17
            if mem[_1415 + 64] * mem[_1463] and block.timestamp - mem[_1415 + 96] > -1 / mem[_1415 + 64] * mem[_1463]:
                revert with 0, 17
            _1796 = mem[_1415 + 128]
            if mem[_1415 + 128] > !((block.timestamp * mem[_1415 + 64] * mem[_1463]) - (mem[_1415 + 96] * mem[_1415 + 64] * mem[_1463]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_1415 + 256] > 5:
                revert with 0, 33
            if mem[_1415 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1960 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600) and mem[_1960] > -1 / _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _2137 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _2137
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _2137, msg.sender
            else:
                if mem[_1415 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_1415 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1996 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600) and mem[_1996] > -1 / _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2151 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2151
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2151, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1997 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600) and mem[_1997] > -1 / _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _2161 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2161
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2161, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            s = s + _1796 + ((block.timestamp * _1498 * _1483) - (_1501 * _1498 * _1483) / 10000 / 24 * 3600)
            t = t + _1380
            continue 
        _1354 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_1354 + 288] = ('cd', 4).length
        mem[_1354 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_1354 + ('cd', 4).length + 320] = 0
        mem[_1354] = _1354 + 288
        mem[_1354 + 32] = 0
        mem[_1354 + 64] = t
        mem[_1354 + 96] = block.timestamp
        mem[_1354 + 128] = s
        mem[_1354 + 160] = t
        mem[_1354 + 192] = 0
        mem[_1354 + 224] = 0
        mem[_1354 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_1354 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var66001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = t
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = s
            mem[mem[64] + 228] = t
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2261 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2264 = mem[_2261]
            mem[0] = mem[_2261]
            mem[32] = 13
            _2266 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_2266)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_2266] = 0
                    stor2[_2266] = t
                    stor3[_2266] = block.timestamp
                    stor4[_2266] = s
                    stor5[_2266] = t
                    uint256(stor6[_2266]) = 0
                    uint256(stor7[_2266].field_0) = 0
                    Mask(248, 0, stor7[_2266].field_8) = 5
                    mem[mem[64] + 4] = _2264
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _2264
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3336 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3336] == mem[_3336 + 12 len 20]
                    if not mem[_3336 + 12 len 20]:
                        sub_ded2abc3[_2264] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2264
                        idx = 0
                        s = _728
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _2264, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4053 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_2264] = mem[_4053]
                else:
                    uint256(stor[_2266].field_0) = 0
                    idx = 0
                    while (uint255(uint256(stor[_2266].field_0)) * 0.5) + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_2266] = 0
                    stor2[_2266] = t
                    stor3[_2266] = block.timestamp
                    stor4[_2266] = s
                    stor5[_2266] = t
                    uint256(stor6[_2266]) = 0
                    uint256(stor7[_2266].field_0) = 0
                    Mask(248, 0, stor7[_2266].field_8) = 5
                    mem[mem[64] + 4] = _2264
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _2264
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2841 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2841] == mem[_2841 + 12 len 20]
                    if not mem[_2841 + 12 len 20]:
                        sub_ded2abc3[_2264] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2264
                        idx = 0
                        s = _728
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _2264, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3287 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_2264] = mem[_3287]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_2266)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_2266] = 0
                    stor2[_2266] = t
                    stor3[_2266] = block.timestamp
                    stor4[_2266] = s
                    stor5[_2266] = t
                    uint256(stor6[_2266]) = 0
                    uint256(stor7[_2266].field_0) = 0
                    Mask(248, 0, stor7[_2266].field_8) = 5
                    mem[mem[64] + 4] = _2264
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _2264
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3340 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3340] == mem[_3340 + 12 len 20]
                    if not mem[_3340 + 12 len 20]:
                        sub_ded2abc3[_2264] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2264
                        idx = 0
                        s = _728
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _2264, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4054 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_2264] = mem[_4054]
                else:
                    uint256(stor[_2266].field_0) = 0
                    idx = 0
                    while stor[_2266].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_2266] = 0
                    stor2[_2266] = t
                    stor3[_2266] = block.timestamp
                    stor4[_2266] = s
                    stor5[_2266] = t
                    uint256(stor6[_2266]) = 0
                    uint256(stor7[_2266].field_0) = 0
                    Mask(248, 0, stor7[_2266].field_8) = 5
                    mem[mem[64] + 4] = _2264
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _2264
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2844 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2844] == mem[_2844 + 12 len 20]
                    if not mem[_2844 + 12 len 20]:
                        sub_ded2abc3[_2264] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2264
                        idx = 0
                        s = _728
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _2264, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3291 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_2264] = mem[_3291]
            return _2264
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = t
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = s
        mem[mem[64] + 228] = t
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2262 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2265 = mem[_2262]
        mem[0] = mem[_2262]
        mem[32] = 13
        _2269 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_2269)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_2269] = 0
                stor2[_2269] = t
                stor3[_2269] = block.timestamp
                stor4[_2269] = s
                stor5[_2269] = t
                uint256(stor6[_2269]) = 0
                uint256(stor7[_2269].field_0) = 0
                Mask(248, 0, stor7[_2269].field_8) = 5
                mem[mem[64] + 4] = _2265
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _2265
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_3344] == mem[_3344 + 12 len 20]
                if not mem[_3344 + 12 len 20]:
                    sub_ded2abc3[_2265] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2265
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _2265, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4055 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2265] = mem[_4055]
            else:
                uint256(stor[_2269].field_0) = 0
                idx = 0
                while (uint255(uint256(stor[_2269].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_2269] = 0
                stor2[_2269] = t
                stor3[_2269] = block.timestamp
                stor4[_2269] = s
                stor5[_2269] = t
                uint256(stor6[_2269]) = 0
                uint256(stor7[_2269].field_0) = 0
                Mask(248, 0, stor7[_2269].field_8) = 5
                mem[mem[64] + 4] = _2265
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _2265
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2847 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2847] == mem[_2847 + 12 len 20]
                if not mem[_2847 + 12 len 20]:
                    sub_ded2abc3[_2265] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2265
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _2265, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3295 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2265] = mem[_3295]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_2269)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_2269] = 0
                stor2[_2269] = t
                stor3[_2269] = block.timestamp
                stor4[_2269] = s
                stor5[_2269] = t
                uint256(stor6[_2269]) = 0
                uint256(stor7[_2269].field_0) = 0
                Mask(248, 0, stor7[_2269].field_8) = 5
                mem[mem[64] + 4] = _2265
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _2265
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3348 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_3348] == mem[_3348 + 12 len 20]
                if not mem[_3348 + 12 len 20]:
                    sub_ded2abc3[_2265] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2265
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _2265, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4056 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2265] = mem[_4056]
            else:
                uint256(stor[_2269].field_0) = 0
                idx = 0
                while stor[_2269].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_2269] = 0
                stor2[_2269] = t
                stor3[_2269] = block.timestamp
                stor4[_2269] = s
                stor5[_2269] = t
                uint256(stor6[_2269]) = 0
                uint256(stor7[_2269].field_0) = 0
                Mask(248, 0, stor7[_2269].field_8) = 5
                mem[mem[64] + 4] = _2265
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _2265
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2850 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2850] == mem[_2850 + 12 len 20]
                if not mem[_2850 + 12 len 20]:
                    sub_ded2abc3[_2265] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2265
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _2265, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3299 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2265] = mem[_3299]
        return _2265
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 929
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 641] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 673] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 705] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 737] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 769] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 801] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 833] = 0
    mem[var51002] = 0
    mem[var51002 + 32] = 0
    mem[var53002] = var53001
    if not var53003 - 1:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _3241 = mem[(32 * uint8(idx)) + 128]
            _3283 = mem[64]
            mem[64] = mem[64] + 288
            mem[_3283] = 96
            mem[_3283 + 32] = 0
            mem[_3283 + 64] = 0
            mem[_3283 + 96] = 0
            mem[_3283 + 128] = 0
            mem[_3283 + 160] = 0
            mem[_3283 + 192] = 0
            mem[_3283 + 224] = 0
            mem[_3283 + 256] = 0
            mem[0] = _3241
            mem[32] = 13
            if uint256(stor13[_3241].field_512):
                mem[0] = _3241
                mem[32] = 13
                _3329 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_3241].field_0):
                    if bool(stor13[_3241].field_0) == uint255(uint256(stor13[_3241].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _3383 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_3241].field_0)) * 0.5) + 32
                    mem[_3383] = uint255(uint256(stor13[_3241].field_0)) * 0.5
                    if bool(stor13[_3241].field_0):
                        if bool(stor13[_3241].field_0) == uint255(uint256(stor13[_3241].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_3241].field_0)):
                            if 31 >= uint255(uint256(stor13[_3241].field_0)) * 0.5:
                                mem[_3383 + 32] = 256 * Mask(248, 0, stor13[_3241].field_8)
                            else:
                                mem[0] = sha3(_3241, 13)
                                mem[_3383 + 32] = uint256(stor13[_3241].field_0)
                                s = _3383 + 32
                                t = sha3(sha3(_3241, 13))
                                while _3383 + (uint255(uint256(stor13[_3241].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_3241].field_0) == stor13[_3241].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_3241].field_1 % 128:
                            if 31 >= stor13[_3241].field_1 % 128:
                                mem[_3383 + 32] = 256 * Mask(248, 0, stor13[_3241].field_8)
                            else:
                                mem[0] = sha3(_3241, 13)
                                mem[_3383 + 32] = uint256(stor13[_3241].field_0)
                                s = _3383 + 32
                                t = sha3(sha3(_3241, 13))
                                while _3383 + stor13[_3241].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_3329] = _3383
                else:
                    if bool(stor13[_3241].field_0) == stor13[_3241].field_1 % 128 < 32:
                        revert with 0, 34
                    _3386 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_3241].field_1 % 128) + 32
                    mem[_3386] = stor13[_3241].field_1 % 128
                    if bool(stor13[_3241].field_0):
                        if bool(stor13[_3241].field_0) == uint255(uint256(stor13[_3241].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_3241].field_0)):
                            if 31 >= uint255(uint256(stor13[_3241].field_0)) * 0.5:
                                mem[_3386 + 32] = 256 * Mask(248, 0, stor13[_3241].field_8)
                            else:
                                mem[0] = sha3(_3241, 13)
                                mem[_3386 + 32] = uint256(stor13[_3241].field_0)
                                s = _3386 + 32
                                t = sha3(sha3(_3241, 13))
                                while _3386 + (uint255(uint256(stor13[_3241].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_3241].field_0) == stor13[_3241].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_3241].field_1 % 128:
                            if 31 >= stor13[_3241].field_1 % 128:
                                mem[_3386 + 32] = 256 * Mask(248, 0, stor13[_3241].field_8)
                            else:
                                mem[0] = sha3(_3241, 13)
                                mem[_3386 + 32] = uint256(stor13[_3241].field_0)
                                s = _3386 + 32
                                t = sha3(sha3(_3241, 13))
                                while _3386 + stor13[_3241].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_3329] = _3386
                mem[_3329 + 32] = uint256(stor13[_3241].field_256)
                mem[_3329 + 64] = uint256(stor13[_3241].field_512)
                mem[_3329 + 96] = uint256(stor13[_3241].field_768)
                mem[_3329 + 128] = uint256(stor13[_3241].field_1024)
                mem[_3329 + 160] = uint256(stor13[_3241].field_1280)
                mem[_3329 + 192] = uint256(stor13[_3241].field_1536)
                if uint8(stor13[_3241].field_1792) > 5:
                    revert with 0, 33
                mem[_3329 + 224] = uint8(stor13[_3241].field_1792)
                if uint8(stor13[_3241].field_1800) > 5:
                    revert with 0, 33
                mem[_3329 + 256] = uint8(stor13[_3241].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _3329
                if uint256(stor13[_3241].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_3241].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_3241].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_3241].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_3241].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_3241].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _3241
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _3241
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3353 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3384 = mem[_3353]
                require mem[_3353] <= test266151307()
                require return_data.size - mem[_3353] >= 288
                if not bool(_3353 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _3353 + ceil32(return_data.size) + 288
                _3399 = mem[_3353 + _3384]
                require mem[_3353 + _3384] <= test266151307()
                require _3353 + _3384 + mem[_3353 + _3384] + 31 < _3353 + return_data.size
                _3421 = mem[_3353 + _3384 + mem[_3353 + _3384]]
                if mem[_3353 + _3384 + mem[_3353 + _3384]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_3353 + _3384 + mem[_3353 + _3384]])) + 289 < 288 or _3353 + ceil32(return_data.size) + ceil32(ceil32(mem[_3353 + _3384 + mem[_3353 + _3384]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _3353 + ceil32(return_data.size) + ceil32(ceil32(mem[_3353 + _3384 + mem[_3353 + _3384]])) + 289
                mem[_3353 + ceil32(return_data.size) + 288] = _3421
                require _3384 + _3399 + _3421 + 32 <= return_data.size
                s = 0
                while s < _3421:
                    mem[s + _3353 + ceil32(return_data.size) + 320] = mem[s + _3353 + _3384 + _3399 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3421) > _3421:
                    mem[_3421 + _3353 + ceil32(return_data.size) + 320] = 0
                mem[_3353 + ceil32(return_data.size)] = _3353 + ceil32(return_data.size) + 288
                mem[_3353 + ceil32(return_data.size) + 32] = mem[_3353 + _3384 + 32]
                mem[_3353 + ceil32(return_data.size) + 64] = mem[_3353 + _3384 + 64]
                mem[_3353 + ceil32(return_data.size) + 96] = mem[_3353 + _3384 + 96]
                mem[_3353 + ceil32(return_data.size) + 128] = mem[_3353 + _3384 + 128]
                mem[_3353 + ceil32(return_data.size) + 160] = mem[_3353 + _3384 + 160]
                mem[_3353 + ceil32(return_data.size) + 192] = mem[_3353 + _3384 + 192]
                require mem[_3353 + _3384 + 224] < 6
                mem[_3353 + ceil32(return_data.size) + 224] = mem[_3353 + _3384 + 224]
                require mem[_3353 + _3384 + 256] < 6
                mem[_3353 + ceil32(return_data.size) + 256] = mem[_3353 + _3384 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _3353 + ceil32(return_data.size)
                if mem[_3353 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_3353 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_3353 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_3353 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_3353 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_3353 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _3351 = mem[64]
        mem[64] = mem[64] + 128
        mem[_3351 len 128] = call.data[calldata.size len 128]
        idx = 0
        s = 0
        t = 0
        while uint8(idx) < 4:
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            mem[(32 * uint8(idx)) + _3351] = uint8(mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _4067 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if t > !mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            _4114 = mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _4130 = mem[(32 * uint8(idx)) + 128]
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _4144 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _4156 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _4279 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4518 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600) and mem[_4518] > -1 / _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4715 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4715
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4715, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4542 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600) and mem[_4542] > -1 / _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4720 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4720
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4720, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4543 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600) and mem[_4543] > -1 / _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4731 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4731
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4731, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _4279 + ((block.timestamp * _4144 * stor5.length) - (_4156 * _4144 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                _4145 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _4157 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _4280 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4523 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600) and mem[_4523] > -1 / _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4718 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4718
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4718, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4545 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600) and mem[_4545] > -1 / _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4724 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4724
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4724, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4546 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600) and mem[_4546] > -1 / _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _4734 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4734
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _4734, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                    uint256(stor[u].field_0) = 0
                    u = u + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                s = s + _4280 + ((block.timestamp * _4145 * stor5.length) - (_4157 * _4145 * stor5.length) / 10000 / 24 * 3600)
                t = t + _4067
                continue 
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _4163 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _4176 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _4323 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4552 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600) and mem[_4552] > -1 / _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4739 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4739
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4739, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4576 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600) and mem[_4576] > -1 / _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4754 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4754
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4754, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                                t = t + _4067
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4577 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600) and mem[_4577] > -1 / _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4777 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4777
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4777, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4323 + ((block.timestamp * _4163 * stor4.length) - (_4176 * _4163 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                _4164 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _4177 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _4324 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4557 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600) and mem[_4557] > -1 / _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4742 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4742
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4742, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4579 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600) and mem[_4579] > -1 / _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4758 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4758
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4758, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4580 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600) and mem[_4580] > -1 / _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4780 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4780
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4780, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _4324 + ((block.timestamp * _4164 * stor4.length) - (_4177 * _4164 * stor4.length) / 10000 / 24 * 3600)
                t = t + _4067
                continue 
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 12
                _4146 = sha3(mem[(32 * uint8(idx)) + 128], 12)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _4174 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _4180 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                        revert with 0, 17
                    _4375 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4564 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4564] > -1 / _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4749 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4749
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4749, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                                t = t + _4067
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4588 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4588] > -1 / _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _4768 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _4768
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _4768, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4589 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4589] > -1 / _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _4789 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _4789
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _4789, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _4375 + ((block.timestamp * _4174 * uint256(stor[_4146].field_0)) - (_4180 * _4174 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                    t = t + _4067
                    continue 
                _4175 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _4181 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                    revert with 0, 17
                _4376 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4569 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4569] > -1 / _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4752 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4752
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4752, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                            t = t + _4067
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                        t = t + _4067
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4591 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4591] > -1 / _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4772 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4772
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4772, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600) and mem[_4592] > -1 / _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4792 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4792
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4792, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _4376 + ((block.timestamp * _4175 * uint256(stor[_4146].field_0)) - (_4181 * _4175 * uint256(stor[_4146].field_0)) / 10000 / 24 * 3600)
                t = t + _4067
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(idx)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _4130
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4162 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _4182 = mem[_4162]
            if mem[_4114 + 256] > 5:
                revert with 0, 33
            if mem[_4114 + 256] == 5:
                _4196 = mem[_4114 + 160]
                _4199 = mem[_4114 + 96]
                if block.timestamp < mem[_4114 + 96]:
                    revert with 0, 17
                if mem[_4114 + 160] and mem[_4162] > -1 / mem[_4114 + 160]:
                    revert with 0, 17
                if mem[_4114 + 160] * mem[_4162] and block.timestamp - mem[_4114 + 96] > -1 / mem[_4114 + 160] * mem[_4162]:
                    revert with 0, 17
                _4494 = mem[_4114 + 128]
                if mem[_4114 + 128] > !((block.timestamp * mem[_4114 + 160] * mem[_4162]) - (mem[_4114 + 96] * mem[_4114 + 160] * mem[_4162]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_4114 + 256] > 5:
                    revert with 0, 33
                if mem[_4114 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4654 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600) and mem[_4654] > -1 / _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4833 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4833
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4833, msg.sender
                else:
                    if mem[_4114 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_4114 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4692 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600) and mem[_4692] > -1 / _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4846 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4846
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4846, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4693 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600) and mem[_4693] > -1 / _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _4857 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4857
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4857, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _4494 + ((block.timestamp * _4196 * _4182) - (_4199 * _4196 * _4182) / 10000 / 24 * 3600)
                t = t + _4067
                continue 
            _4197 = mem[_4114 + 64]
            _4200 = mem[_4114 + 96]
            if block.timestamp < mem[_4114 + 96]:
                revert with 0, 17
            if mem[_4114 + 64] and mem[_4162] > -1 / mem[_4114 + 64]:
                revert with 0, 17
            if mem[_4114 + 64] * mem[_4162] and block.timestamp - mem[_4114 + 96] > -1 / mem[_4114 + 64] * mem[_4162]:
                revert with 0, 17
            _4495 = mem[_4114 + 128]
            if mem[_4114 + 128] > !((block.timestamp * mem[_4114 + 64] * mem[_4162]) - (mem[_4114 + 96] * mem[_4114 + 64] * mem[_4162]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_4114 + 256] > 5:
                revert with 0, 33
            if mem[_4114 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4659 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600) and mem[_4659] > -1 / _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _4836 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4836
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _4836, msg.sender
            else:
                if mem[_4114 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_4114 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4695 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600) and mem[_4695] > -1 / _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4850 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4850
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4850, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4696 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600) and mem[_4696] > -1 / _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _4860 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4860
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4860, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            s = s + _4495 + ((block.timestamp * _4197 * _4182) - (_4200 * _4197 * _4182) / 10000 / 24 * 3600)
            t = t + _4067
            continue 
        _4025 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_4025 + 288] = ('cd', 4).length
        mem[_4025 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_4025 + ('cd', 4).length + 320] = 0
        mem[_4025] = _4025 + 288
        mem[_4025 + 32] = 0
        mem[_4025 + 64] = t
        mem[_4025 + 96] = block.timestamp
        mem[_4025 + 128] = s
        mem[_4025 + 160] = t
        mem[_4025 + 192] = 0
        mem[_4025 + 224] = 0
        mem[_4025 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_4025 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var74001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = t
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = s
            mem[mem[64] + 228] = t
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4960 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _4963 = mem[_4960]
            mem[0] = mem[_4960]
            mem[32] = 13
            _4965 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_4965)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_4965] = 0
                    stor2[_4965] = t
                    stor3[_4965] = block.timestamp
                    stor4[_4965] = s
                    stor5[_4965] = t
                    uint256(stor6[_4965]) = 0
                    uint256(stor7[_4965].field_0) = 0
                    Mask(248, 0, stor7[_4965].field_8) = 5
                    mem[mem[64] + 4] = _4963
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _4963
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6035 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_6035] == mem[_6035 + 12 len 20]
                    if not mem[_6035 + 12 len 20]:
                        sub_ded2abc3[_4963] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4963
                        idx = 0
                        s = _3351
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _4963, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6752 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_4963] = mem[_6752]
                else:
                    uint256(stor[_4965].field_0) = 0
                    idx = 0
                    while (uint255(uint256(stor[_4965].field_0)) * 0.5) + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_4965] = 0
                    stor2[_4965] = t
                    stor3[_4965] = block.timestamp
                    stor4[_4965] = s
                    stor5[_4965] = t
                    uint256(stor6[_4965]) = 0
                    uint256(stor7[_4965].field_0) = 0
                    Mask(248, 0, stor7[_4965].field_8) = 5
                    mem[mem[64] + 4] = _4963
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _4963
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5540 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_5540] == mem[_5540 + 12 len 20]
                    if not mem[_5540 + 12 len 20]:
                        sub_ded2abc3[_4963] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4963
                        idx = 0
                        s = _3351
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _4963, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5986 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_4963] = mem[_5986]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_4965)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_4965] = 0
                    stor2[_4965] = t
                    stor3[_4965] = block.timestamp
                    stor4[_4965] = s
                    stor5[_4965] = t
                    uint256(stor6[_4965]) = 0
                    uint256(stor7[_4965].field_0) = 0
                    Mask(248, 0, stor7[_4965].field_8) = 5
                    mem[mem[64] + 4] = _4963
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _4963
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6039 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_6039] == mem[_6039 + 12 len 20]
                    if not mem[_6039 + 12 len 20]:
                        sub_ded2abc3[_4963] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4963
                        idx = 0
                        s = _3351
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _4963, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6753 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_4963] = mem[_6753]
                else:
                    uint256(stor[_4965].field_0) = 0
                    idx = 0
                    while stor[_4965].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_4965] = 0
                    stor2[_4965] = t
                    stor3[_4965] = block.timestamp
                    stor4[_4965] = s
                    stor5[_4965] = t
                    uint256(stor6[_4965]) = 0
                    uint256(stor7[_4965].field_0) = 0
                    Mask(248, 0, stor7[_4965].field_8) = 5
                    mem[mem[64] + 4] = _4963
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _4963
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5543 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_5543] == mem[_5543 + 12 len 20]
                    if not mem[_5543 + 12 len 20]:
                        sub_ded2abc3[_4963] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4963
                        idx = 0
                        s = _3351
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _4963, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5990 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_4963] = mem[_5990]
            return _4963
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = t
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = s
        mem[mem[64] + 228] = t
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4961 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _4964 = mem[_4961]
        mem[0] = mem[_4961]
        mem[32] = 13
        _4968 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_4968)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_4968] = 0
                stor2[_4968] = t
                stor3[_4968] = block.timestamp
                stor4[_4968] = s
                stor5[_4968] = t
                uint256(stor6[_4968]) = 0
                uint256(stor7[_4968].field_0) = 0
                Mask(248, 0, stor7[_4968].field_8) = 5
                mem[mem[64] + 4] = _4964
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _4964
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6043 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6043] == mem[_6043 + 12 len 20]
                if not mem[_6043 + 12 len 20]:
                    sub_ded2abc3[_4964] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4964
                    idx = 0
                    s = _3351
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _4964, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6754 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4964] = mem[_6754]
            else:
                uint256(stor[_4968].field_0) = 0
                idx = 0
                while (uint255(uint256(stor[_4968].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_4968] = 0
                stor2[_4968] = t
                stor3[_4968] = block.timestamp
                stor4[_4968] = s
                stor5[_4968] = t
                uint256(stor6[_4968]) = 0
                uint256(stor7[_4968].field_0) = 0
                Mask(248, 0, stor7[_4968].field_8) = 5
                mem[mem[64] + 4] = _4964
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _4964
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5546 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5546] == mem[_5546 + 12 len 20]
                if not mem[_5546 + 12 len 20]:
                    sub_ded2abc3[_4964] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4964
                    idx = 0
                    s = _3351
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _4964, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5994 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4964] = mem[_5994]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_4968)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_4968] = 0
                stor2[_4968] = t
                stor3[_4968] = block.timestamp
                stor4[_4968] = s
                stor5[_4968] = t
                uint256(stor6[_4968]) = 0
                uint256(stor7[_4968].field_0) = 0
                Mask(248, 0, stor7[_4968].field_8) = 5
                mem[mem[64] + 4] = _4964
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _4964
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6047 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6047] == mem[_6047 + 12 len 20]
                if not mem[_6047 + 12 len 20]:
                    sub_ded2abc3[_4964] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4964
                    idx = 0
                    s = _3351
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _4964, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6755 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4964] = mem[_6755]
            else:
                uint256(stor[_4968].field_0) = 0
                idx = 0
                while stor[_4968].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_4968] = 0
                stor2[_4968] = t
                stor3[_4968] = block.timestamp
                stor4[_4968] = s
                stor5[_4968] = t
                uint256(stor6[_4968]) = 0
                uint256(stor7[_4968].field_0) = 0
                Mask(248, 0, stor7[_4968].field_8) = 5
                mem[mem[64] + 4] = _4964
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _4964
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5549 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5549] == mem[_5549 + 12 len 20]
                if not mem[_5549 + 12 len 20]:
                    sub_ded2abc3[_4964] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4964
                    idx = 0
                    s = _3351
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _4964, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5998 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4964] = mem[_5998]
        return _4964
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1217
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 929] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 961] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 993] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1025] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1057] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1089] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1121] = 0
    mem[var59002] = 0
    mem[var59002 + 32] = 0
    mem[var61002] = var61001
    if var61003 - 1:
        mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1505
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1217] = 96
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1249] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1281] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1313] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1345] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1377] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1409] = 0
        mem[var67002] = 0
        mem[var67002 + 32] = 0
        mem[var69002] = var69001
        if var69003 - 1:
            # nil
        else:
            idx = 0
            while uint8(idx) < 4:
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _8639 = mem[(32 * uint8(idx)) + 128]
                _8681 = mem[64]
                mem[64] = mem[64] + 288
                mem[_8681] = 96
                mem[_8681 + 32] = 0
                mem[_8681 + 64] = 0
                mem[_8681 + 96] = 0
                mem[_8681 + 128] = 0
                mem[_8681 + 160] = 0
                mem[_8681 + 192] = 0
                mem[_8681 + 224] = 0
                mem[_8681 + 256] = 0
                mem[0] = _8639
                mem[32] = 13
                if uint256(stor13[_8639].field_512):
                    mem[0] = _8639
                    mem[32] = 13
                    _8727 = mem[64]
                    mem[64] = mem[64] + 288
                    if bool(stor13[_8639].field_0):
                        if bool(stor13[_8639].field_0) == uint255(uint256(stor13[_8639].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        _8781 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_8639].field_0)) * 0.5) + 32
                        mem[_8781] = uint255(uint256(stor13[_8639].field_0)) * 0.5
                        if bool(stor13[_8639].field_0):
                            if bool(stor13[_8639].field_0) == uint255(uint256(stor13[_8639].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, uint256(stor13[_8639].field_0)):
                                if 31 >= uint255(uint256(stor13[_8639].field_0)) * 0.5:
                                    mem[_8781 + 32] = 256 * Mask(248, 0, stor13[_8639].field_8)
                                else:
                                    mem[0] = sha3(_8639, 13)
                                    mem[_8781 + 32] = uint256(stor13[_8639].field_0)
                                    s = _8781 + 32
                                    t = sha3(sha3(_8639, 13))
                                    while _8781 + (uint255(uint256(stor13[_8639].field_0)) * 0.5) > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor13[_8639].field_0) == stor13[_8639].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[_8639].field_1 % 128:
                                if 31 >= stor13[_8639].field_1 % 128:
                                    mem[_8781 + 32] = 256 * Mask(248, 0, stor13[_8639].field_8)
                                else:
                                    mem[0] = sha3(_8639, 13)
                                    mem[_8781 + 32] = uint256(stor13[_8639].field_0)
                                    s = _8781 + 32
                                    t = sha3(sha3(_8639, 13))
                                    while _8781 + stor13[_8639].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        mem[_8727] = _8781
                    else:
                        if bool(stor13[_8639].field_0) == stor13[_8639].field_1 % 128 < 32:
                            revert with 0, 34
                        _8784 = mem[64]
                        mem[64] = mem[64] + ceil32(stor13[_8639].field_1 % 128) + 32
                        mem[_8784] = stor13[_8639].field_1 % 128
                        if bool(stor13[_8639].field_0):
                            if bool(stor13[_8639].field_0) == uint255(uint256(stor13[_8639].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, uint256(stor13[_8639].field_0)):
                                if 31 >= uint255(uint256(stor13[_8639].field_0)) * 0.5:
                                    mem[_8784 + 32] = 256 * Mask(248, 0, stor13[_8639].field_8)
                                else:
                                    mem[0] = sha3(_8639, 13)
                                    mem[_8784 + 32] = uint256(stor13[_8639].field_0)
                                    s = _8784 + 32
                                    t = sha3(sha3(_8639, 13))
                                    while _8784 + (uint255(uint256(stor13[_8639].field_0)) * 0.5) > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor13[_8639].field_0) == stor13[_8639].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[_8639].field_1 % 128:
                                if 31 >= stor13[_8639].field_1 % 128:
                                    mem[_8784 + 32] = 256 * Mask(248, 0, stor13[_8639].field_8)
                                else:
                                    mem[0] = sha3(_8639, 13)
                                    mem[_8784 + 32] = uint256(stor13[_8639].field_0)
                                    s = _8784 + 32
                                    t = sha3(sha3(_8639, 13))
                                    while _8784 + stor13[_8639].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        mem[_8727] = _8784
                    mem[_8727 + 32] = uint256(stor13[_8639].field_256)
                    mem[_8727 + 64] = uint256(stor13[_8639].field_512)
                    mem[_8727 + 96] = uint256(stor13[_8639].field_768)
                    mem[_8727 + 128] = uint256(stor13[_8639].field_1024)
                    mem[_8727 + 160] = uint256(stor13[_8639].field_1280)
                    mem[_8727 + 192] = uint256(stor13[_8639].field_1536)
                    if uint8(stor13[_8639].field_1792) > 5:
                        revert with 0, 33
                    mem[_8727 + 224] = uint8(stor13[_8639].field_1792)
                    if uint8(stor13[_8639].field_1800) > 5:
                        revert with 0, 33
                    mem[_8727 + 256] = uint8(stor13[_8639].field_1800)
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _8727
                    if uint256(stor13[_8639].field_1280) != stor1.length:
                        revert with 0, 'Invalid tier'
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    if uint8(stor13[_8639].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[_8639].field_1800) >= 4:
                        revert with 0, 50
                    if mem[(32 * uint8(stor13[_8639].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                        revert with 0, 17
                    mem[(32 * uint8(stor13[_8639].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_8639].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
                else:
                    mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _8639
                    require ext_code.size(stor8)
                    staticcall stor8.0x36dac2cc with:
                            gas gas_remaining wei
                           args _8639
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8751 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8782 = mem[_8751]
                    require mem[_8751] <= test266151307()
                    require return_data.size - mem[_8751] >= 288
                    if not bool(_8751 + ceil32(return_data.size) + 288 <= test266151307()):
                        revert with 0, 65
                    mem[64] = _8751 + ceil32(return_data.size) + 288
                    _8797 = mem[_8751 + _8782]
                    require mem[_8751 + _8782] <= test266151307()
                    require _8751 + _8782 + mem[_8751 + _8782] + 31 < _8751 + return_data.size
                    _8819 = mem[_8751 + _8782 + mem[_8751 + _8782]]
                    if mem[_8751 + _8782 + mem[_8751 + _8782]] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[_8751 + _8782 + mem[_8751 + _8782]])) + 289 < 288 or _8751 + ceil32(return_data.size) + ceil32(ceil32(mem[_8751 + _8782 + mem[_8751 + _8782]])) + 289 > test266151307():
                        revert with 0, 65
                    mem[64] = _8751 + ceil32(return_data.size) + ceil32(ceil32(mem[_8751 + _8782 + mem[_8751 + _8782]])) + 289
                    mem[_8751 + ceil32(return_data.size) + 288] = _8819
                    require _8782 + _8797 + _8819 + 32 <= return_data.size
                    s = 0
                    while s < _8819:
                        mem[s + _8751 + ceil32(return_data.size) + 320] = mem[s + _8751 + _8782 + _8797 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_8819) > _8819:
                        mem[_8819 + _8751 + ceil32(return_data.size) + 320] = 0
                    mem[_8751 + ceil32(return_data.size)] = _8751 + ceil32(return_data.size) + 288
                    mem[_8751 + ceil32(return_data.size) + 32] = mem[_8751 + _8782 + 32]
                    mem[_8751 + ceil32(return_data.size) + 64] = mem[_8751 + _8782 + 64]
                    mem[_8751 + ceil32(return_data.size) + 96] = mem[_8751 + _8782 + 96]
                    mem[_8751 + ceil32(return_data.size) + 128] = mem[_8751 + _8782 + 128]
                    mem[_8751 + ceil32(return_data.size) + 160] = mem[_8751 + _8782 + 160]
                    mem[_8751 + ceil32(return_data.size) + 192] = mem[_8751 + _8782 + 192]
                    require mem[_8751 + _8782 + 224] < 6
                    mem[_8751 + ceil32(return_data.size) + 224] = mem[_8751 + _8782 + 224]
                    require mem[_8751 + _8782 + 256] < 6
                    mem[_8751 + ceil32(return_data.size) + 256] = mem[_8751 + _8782 + 256]
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _8751 + ceil32(return_data.size)
                    if mem[_8751 + ceil32(return_data.size) + 160] != stor1.length:
                        revert with 0, 'Invalid tier'
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    if mem[_8751 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_8751 + ceil32(return_data.size) + 256] >= 4:
                        revert with 0, 50
                    if mem[(32 * mem[_8751 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                        revert with 0, 17
                    mem[(32 * mem[_8751 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_8751 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                continue 
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
                revert with 0, 'Invalid token type'
            _8749 = mem[64]
            mem[64] = mem[64] + 128
            mem[_8749 len 128] = call.data[calldata.size len 128]
            idx = 0
            s = 0
            t = 0
            while uint8(idx) < 4:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                    revert with 0, 33
                if 1 > -mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                    revert with 0, 17
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + _8749] = uint8(mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
                _9465 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                if t > !mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if uint8(idx) >= 4:
                    revert with 0, 50
                _9512 = mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _9528 = mem[(32 * uint8(idx)) + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        _9542 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                        _9554 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                        if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                            revert with 0, 17
                        _9677 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9916 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600) and mem[_9916] > -1 / _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _10113 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _10113
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _10113, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 13
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _9465
                                    continue 
                            else:
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _9465
                                    continue 
                        else:
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9940 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600) and mem[_9940] > -1 / _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10118 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10118
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10118, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9941 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600) and mem[_9941] > -1 / _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10129 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10129
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10129, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9677 + ((block.timestamp * _9542 * stor5.length) - (_9554 * _9542 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                    else:
                        _9543 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                        _9555 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                        if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                            revert with 0, 17
                        _9678 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9921 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600) and mem[_9921] > -1 / _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _10116 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _10116
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _10116, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 13
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _9465
                                    continue 
                            else:
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _9465
                                    continue 
                        else:
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9943 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600) and mem[_9943] > -1 / _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10122 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10122
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10122, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9944 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600) and mem[_9944] > -1 / _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10132 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10132
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10132, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9678 + ((block.timestamp * _9543 * stor5.length) - (_9555 * _9543 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                else:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            _9561 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                            _9574 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                            if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                                revert with 0, 17
                            _9721 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9950 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600) and mem[_9950] > -1 / _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10137 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10137
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10137, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                            else:
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9974 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600) and mem[_9974] > -1 / _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10152 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10152
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10152, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9975 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600) and mem[_9975] > -1 / _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10175 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10175
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10175, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9721 + ((block.timestamp * _9561 * stor4.length) - (_9574 * _9561 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                        else:
                            _9562 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                            _9575 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                            if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                                revert with 0, 17
                            _9722 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9955 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600) and mem[_9955] > -1 / _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _10140 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _10140
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _10140, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _9465
                                        continue 
                            else:
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9977 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600) and mem[_9977] > -1 / _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10156 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10156
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10156, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9978 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600) and mem[_9978] > -1 / _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10178 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10178
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10178, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9722 + ((block.timestamp * _9562 * stor4.length) - (_9575 * _9562 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                    else:
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 12
                        if sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 12
                            _9544 = sha3(mem[(32 * uint8(idx)) + 128], 12)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                _9572 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                                _9578 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                                    revert with 0, 17
                                _9773 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9962 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9962] > -1 / _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10147 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10147
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10147, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9986 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9986] > -1 / _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10166 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10166
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10166, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9987 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9987] > -1 / _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10187 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10187
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10187, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9773 + ((block.timestamp * _9572 * uint256(stor[_9544].field_0)) - (_9578 * _9572 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                            else:
                                _9573 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                                _9579 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                                    revert with 0, 17
                                _9774 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9967 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9967] > -1 / _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10150 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10150
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10150, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9989 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9989] > -1 / _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10170 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10170
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10170, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9990 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600) and mem[_9990] > -1 / _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10190 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10190
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10190, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9774 + ((block.timestamp * _9573 * uint256(stor[_9544].field_0)) - (_9579 * _9573 * uint256(stor[_9544].field_0)) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                        else:
                            mem[mem[64] + 4] = mem[(32 * uint8(idx)) + 128]
                            require ext_code.size(stor8)
                            staticcall stor8.0xded2abc3 with:
                                    gas gas_remaining wei
                                   args _9528
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9560 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9580 = mem[_9560]
                            if mem[_9512 + 256] > 5:
                                revert with 0, 33
                            if mem[_9512 + 256] == 5:
                                _9594 = mem[_9512 + 160]
                                _9597 = mem[_9512 + 96]
                                if block.timestamp < mem[_9512 + 96]:
                                    revert with 0, 17
                                if mem[_9512 + 160] and mem[_9560] > -1 / mem[_9512 + 160]:
                                    revert with 0, 17
                                if mem[_9512 + 160] * mem[_9560] and block.timestamp - mem[_9512 + 96] > -1 / mem[_9512 + 160] * mem[_9560]:
                                    revert with 0, 17
                                _9892 = mem[_9512 + 128]
                                if mem[_9512 + 128] > !((block.timestamp * mem[_9512 + 160] * mem[_9560]) - (mem[_9512 + 96] * mem[_9512 + 160] * mem[_9560]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_9512 + 256] > 5:
                                    revert with 0, 33
                                if mem[_9512 + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10052 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600) and mem[_10052] > -1 / _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10231 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10231
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10231, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    if mem[_9512 + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_9512 + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10090 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600) and mem[_10090] > -1 / _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10244 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10244
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10244, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10091 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600) and mem[_10091] > -1 / _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10255 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10255
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10255, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9892 + ((block.timestamp * _9594 * _9580) - (_9597 * _9594 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                            else:
                                _9595 = mem[_9512 + 64]
                                _9598 = mem[_9512 + 96]
                                if block.timestamp < mem[_9512 + 96]:
                                    revert with 0, 17
                                if mem[_9512 + 64] and mem[_9560] > -1 / mem[_9512 + 64]:
                                    revert with 0, 17
                                if mem[_9512 + 64] * mem[_9560] and block.timestamp - mem[_9512 + 96] > -1 / mem[_9512 + 64] * mem[_9560]:
                                    revert with 0, 17
                                _9893 = mem[_9512 + 128]
                                if mem[_9512 + 128] > !((block.timestamp * mem[_9512 + 64] * mem[_9560]) - (mem[_9512 + 96] * mem[_9512 + 64] * mem[_9560]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_9512 + 256] > 5:
                                    revert with 0, 33
                                if mem[_9512 + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10057 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600) and mem[_10057] > -1 / _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _10234 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _10234
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _10234, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                            t = t + _9465
                                            continue 
                                else:
                                    if mem[_9512 + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_9512 + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10093 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600) and mem[_10093] > -1 / _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10248 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10248
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10248, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10094 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600) and mem[_10094] > -1 / _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _10258 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _10258
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _10258, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _9893 + ((block.timestamp * _9595 * _9580) - (_9598 * _9595 * _9580) / 10000 / 24 * 3600)
                                                t = t + _9465
                                                continue 
            # nil
    else:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _5940 = mem[(32 * uint8(idx)) + 128]
            _5982 = mem[64]
            mem[64] = mem[64] + 288
            mem[_5982] = 96
            mem[_5982 + 32] = 0
            mem[_5982 + 64] = 0
            mem[_5982 + 96] = 0
            mem[_5982 + 128] = 0
            mem[_5982 + 160] = 0
            mem[_5982 + 192] = 0
            mem[_5982 + 224] = 0
            mem[_5982 + 256] = 0
            mem[0] = _5940
            mem[32] = 13
            if uint256(stor13[_5940].field_512):
                mem[0] = _5940
                mem[32] = 13
                _6028 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_5940].field_0):
                    if bool(stor13[_5940].field_0) == uint255(uint256(stor13[_5940].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _6082 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_5940].field_0)) * 0.5) + 32
                    mem[_6082] = uint255(uint256(stor13[_5940].field_0)) * 0.5
                    if bool(stor13[_5940].field_0):
                        if bool(stor13[_5940].field_0) == uint255(uint256(stor13[_5940].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_5940].field_0)):
                            if 31 >= uint255(uint256(stor13[_5940].field_0)) * 0.5:
                                mem[_6082 + 32] = 256 * Mask(248, 0, stor13[_5940].field_8)
                            else:
                                mem[0] = sha3(_5940, 13)
                                mem[_6082 + 32] = uint256(stor13[_5940].field_0)
                                s = _6082 + 32
                                t = sha3(sha3(_5940, 13))
                                while _6082 + (uint255(uint256(stor13[_5940].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_5940].field_0) == stor13[_5940].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_5940].field_1 % 128:
                            if 31 >= stor13[_5940].field_1 % 128:
                                mem[_6082 + 32] = 256 * Mask(248, 0, stor13[_5940].field_8)
                            else:
                                mem[0] = sha3(_5940, 13)
                                mem[_6082 + 32] = uint256(stor13[_5940].field_0)
                                s = _6082 + 32
                                t = sha3(sha3(_5940, 13))
                                while _6082 + stor13[_5940].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_6028] = _6082
                else:
                    if bool(stor13[_5940].field_0) == stor13[_5940].field_1 % 128 < 32:
                        revert with 0, 34
                    _6085 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_5940].field_1 % 128) + 32
                    mem[_6085] = stor13[_5940].field_1 % 128
                    if bool(stor13[_5940].field_0):
                        if bool(stor13[_5940].field_0) == uint255(uint256(stor13[_5940].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_5940].field_0)):
                            if 31 >= uint255(uint256(stor13[_5940].field_0)) * 0.5:
                                mem[_6085 + 32] = 256 * Mask(248, 0, stor13[_5940].field_8)
                            else:
                                mem[0] = sha3(_5940, 13)
                                mem[_6085 + 32] = uint256(stor13[_5940].field_0)
                                s = _6085 + 32
                                t = sha3(sha3(_5940, 13))
                                while _6085 + (uint255(uint256(stor13[_5940].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_5940].field_0) == stor13[_5940].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_5940].field_1 % 128:
                            if 31 >= stor13[_5940].field_1 % 128:
                                mem[_6085 + 32] = 256 * Mask(248, 0, stor13[_5940].field_8)
                            else:
                                mem[0] = sha3(_5940, 13)
                                mem[_6085 + 32] = uint256(stor13[_5940].field_0)
                                s = _6085 + 32
                                t = sha3(sha3(_5940, 13))
                                while _6085 + stor13[_5940].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_6028] = _6085
                mem[_6028 + 32] = uint256(stor13[_5940].field_256)
                mem[_6028 + 64] = uint256(stor13[_5940].field_512)
                mem[_6028 + 96] = uint256(stor13[_5940].field_768)
                mem[_6028 + 128] = uint256(stor13[_5940].field_1024)
                mem[_6028 + 160] = uint256(stor13[_5940].field_1280)
                mem[_6028 + 192] = uint256(stor13[_5940].field_1536)
                if uint8(stor13[_5940].field_1792) > 5:
                    revert with 0, 33
                mem[_6028 + 224] = uint8(stor13[_5940].field_1792)
                if uint8(stor13[_5940].field_1800) > 5:
                    revert with 0, 33
                mem[_6028 + 256] = uint8(stor13[_5940].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _6028
                if uint256(stor13[_5940].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_5940].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_5940].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_5940].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_5940].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_5940].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _5940
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _5940
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6052 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _6083 = mem[_6052]
                require mem[_6052] <= test266151307()
                require return_data.size - mem[_6052] >= 288
                if not bool(_6052 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _6052 + ceil32(return_data.size) + 288
                _6098 = mem[_6052 + _6083]
                require mem[_6052 + _6083] <= test266151307()
                require _6052 + _6083 + mem[_6052 + _6083] + 31 < _6052 + return_data.size
                _6120 = mem[_6052 + _6083 + mem[_6052 + _6083]]
                if mem[_6052 + _6083 + mem[_6052 + _6083]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_6052 + _6083 + mem[_6052 + _6083]])) + 289 < 288 or _6052 + ceil32(return_data.size) + ceil32(ceil32(mem[_6052 + _6083 + mem[_6052 + _6083]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _6052 + ceil32(return_data.size) + ceil32(ceil32(mem[_6052 + _6083 + mem[_6052 + _6083]])) + 289
                mem[_6052 + ceil32(return_data.size) + 288] = _6120
                require _6083 + _6098 + _6120 + 32 <= return_data.size
                s = 0
                while s < _6120:
                    mem[s + _6052 + ceil32(return_data.size) + 320] = mem[s + _6052 + _6083 + _6098 + 32]
                    s = s + 32
                    continue 
                if ceil32(_6120) > _6120:
                    mem[_6120 + _6052 + ceil32(return_data.size) + 320] = 0
                mem[_6052 + ceil32(return_data.size)] = _6052 + ceil32(return_data.size) + 288
                mem[_6052 + ceil32(return_data.size) + 32] = mem[_6052 + _6083 + 32]
                mem[_6052 + ceil32(return_data.size) + 64] = mem[_6052 + _6083 + 64]
                mem[_6052 + ceil32(return_data.size) + 96] = mem[_6052 + _6083 + 96]
                mem[_6052 + ceil32(return_data.size) + 128] = mem[_6052 + _6083 + 128]
                mem[_6052 + ceil32(return_data.size) + 160] = mem[_6052 + _6083 + 160]
                mem[_6052 + ceil32(return_data.size) + 192] = mem[_6052 + _6083 + 192]
                require mem[_6052 + _6083 + 224] < 6
                mem[_6052 + ceil32(return_data.size) + 224] = mem[_6052 + _6083 + 224]
                require mem[_6052 + _6083 + 256] < 6
                mem[_6052 + ceil32(return_data.size) + 256] = mem[_6052 + _6083 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _6052 + ceil32(return_data.size)
                if mem[_6052 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_6052 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_6052 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_6052 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_6052 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_6052 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _6050 = mem[64]
        mem[64] = mem[64] + 128
        mem[_6050 len 128] = call.data[calldata.size len 128]
        idx = 0
        s = 0
        t = 0
        while uint8(idx) < 4:
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            mem[(32 * uint8(idx)) + _6050] = uint8(mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _6766 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if t > !mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(idx) >= 4:
                revert with 0, 50
            _6813 = mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _6829 = mem[(32 * uint8(idx)) + 128]
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6843 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6855 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _6978 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7217 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600) and mem[_7217] > -1 / _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7414 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7414
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7414, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7241 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600) and mem[_7241] > -1 / _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7419 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7419
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7419, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7242 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600) and mem[_7242] > -1 / _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7430 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7430
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7430, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _6978 + ((block.timestamp * _6843 * stor5.length) - (_6855 * _6843 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                _6844 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6856 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _6979 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7222 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600) and mem[_7222] > -1 / _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7417 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7417
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7417, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7244 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600) and mem[_7244] > -1 / _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7423 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7423
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7423, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7245 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600) and mem[_7245] > -1 / _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _7433 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _7433
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _7433, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                    uint256(stor[u].field_0) = 0
                    u = u + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                s = s + _6979 + ((block.timestamp * _6844 * stor5.length) - (_6856 * _6844 * stor5.length) / 10000 / 24 * 3600)
                t = t + _6766
                continue 
            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6862 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6875 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _7022 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7251 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600) and mem[_7251] > -1 / _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7438 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7438
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7438, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7275 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600) and mem[_7275] > -1 / _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7453 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7453
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7453, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                                t = t + _6766
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7276 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600) and mem[_7276] > -1 / _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7476 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7476
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7476, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _7022 + ((block.timestamp * _6862 * stor4.length) - (_6875 * _6862 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                _6863 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6876 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _7023 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7256 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600) and mem[_7256] > -1 / _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7441 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7441
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7441, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                        if uint8(idx) == 255:
                            revert with 0, 17
                        idx = uint8(idx) + 1
                        s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + (stor13[mem[(32 * uint8(u)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7278 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600) and mem[_7278] > -1 / _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7457 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7457
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7457, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7279 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600) and mem[_7279] > -1 / _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7479 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7479
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7479, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _7023 + ((block.timestamp * _6863 * stor4.length) - (_6876 * _6863 * stor4.length) / 10000 / 24 * 3600)
                t = t + _6766
                continue 
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 12
                _6845 = sha3(mem[(32 * uint8(idx)) + 128], 12)
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6873 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6879 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                        revert with 0, 17
                    _7074 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7263 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7263] > -1 / _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7448 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7448
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7448, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                if uint8(idx) == 255:
                                    revert with 0, 17
                                idx = uint8(idx) + 1
                                s = s + _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                                t = t + _6766
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            s = s + _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7287 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7287] > -1 / _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _7467 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _7467
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _7467, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7288 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7288] > -1 / _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _7488 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _7488
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _7488, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                                u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                    uint256(stor[u].field_0) = 0
                                    u = u + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                    if uint8(idx) == 255:
                        revert with 0, 17
                    idx = uint8(idx) + 1
                    s = s + _7074 + ((block.timestamp * _6873 * uint256(stor[_6845].field_0)) - (_6879 * _6873 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                    t = t + _6766
                    continue 
                _6874 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6880 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                    revert with 0, 17
                _7075 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7268 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7268] > -1 / _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7451 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7451
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7451, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                            if uint8(idx) == 255:
                                revert with 0, 17
                            idx = uint8(idx) + 1
                            s = s + _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                            t = t + _6766
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(u)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(u)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(u)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        u = uint8(sha3(sha3(mem[(32 * uint8(u)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(u)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        s = s + _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                        t = t + _6766
                        continue 
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7290 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7290] > -1 / _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7471 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7471
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7471, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7291 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600) and mem[_7291] > -1 / _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7491 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7491
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7491, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(idx)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                            u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                                uint256(stor[u].field_0) = 0
                                u = u + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _7075 + ((block.timestamp * _6874 * uint256(stor[_6845].field_0)) - (_6880 * _6874 * uint256(stor[_6845].field_0)) / 10000 / 24 * 3600)
                t = t + _6766
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(idx)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _6829
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6861 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _6881 = mem[_6861]
            if mem[_6813 + 256] > 5:
                revert with 0, 33
            if mem[_6813 + 256] == 5:
                _6895 = mem[_6813 + 160]
                _6898 = mem[_6813 + 96]
                if block.timestamp < mem[_6813 + 96]:
                    revert with 0, 17
                if mem[_6813 + 160] and mem[_6861] > -1 / mem[_6813 + 160]:
                    revert with 0, 17
                if mem[_6813 + 160] * mem[_6861] and block.timestamp - mem[_6813 + 96] > -1 / mem[_6813 + 160] * mem[_6861]:
                    revert with 0, 17
                _7193 = mem[_6813 + 128]
                if mem[_6813 + 128] > !((block.timestamp * mem[_6813 + 160] * mem[_6861]) - (mem[_6813 + 96] * mem[_6813 + 160] * mem[_6861]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_6813 + 256] > 5:
                    revert with 0, 33
                if mem[_6813 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7353 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600) and mem[_7353] > -1 / _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7532 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7532
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7532, msg.sender
                else:
                    if mem[_6813 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_6813 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7391 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600) and mem[_7391] > -1 / _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7545 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7545
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7545, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7392 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600) and mem[_7392] > -1 / _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if s > !(_7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(idx) >= mem[96]:
                            revert with 0, 50
                        _7556 = mem[(32 * uint8(idx)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7556
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _7556, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(idx)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                        u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                            uint256(stor[u].field_0) = 0
                            u = u + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                s = s + _7193 + ((block.timestamp * _6895 * _6881) - (_6898 * _6895 * _6881) / 10000 / 24 * 3600)
                t = t + _6766
                continue 
            _6896 = mem[_6813 + 64]
            _6899 = mem[_6813 + 96]
            if block.timestamp < mem[_6813 + 96]:
                revert with 0, 17
            if mem[_6813 + 64] and mem[_6861] > -1 / mem[_6813 + 64]:
                revert with 0, 17
            if mem[_6813 + 64] * mem[_6861] and block.timestamp - mem[_6813 + 96] > -1 / mem[_6813 + 64] * mem[_6861]:
                revert with 0, 17
            _7194 = mem[_6813 + 128]
            if mem[_6813 + 128] > !((block.timestamp * mem[_6813 + 64] * mem[_6861]) - (mem[_6813 + 96] * mem[_6813 + 64] * mem[_6861]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_6813 + 256] > 5:
                revert with 0, 33
            if mem[_6813 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7358 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600) and mem[_7358] > -1 / _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600):
                    revert with 0, 17
                if s > !(_7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _7535 = mem[(32 * uint8(idx)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _7535
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _7535, msg.sender
            else:
                if mem[_6813 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_6813 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7394 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600) and mem[_7394] > -1 / _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7549 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7549
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7549, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7395 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600) and mem[_7395] > -1 / _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if s > !(_7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(idx) >= mem[96]:
                        revert with 0, 50
                    _7559 = mem[(32 * uint8(idx)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7559
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _7559, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(idx)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5) + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(idx)) + 128], 13)
                    u = sha3(sha3(mem[(32 * uint8(idx)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(idx)) + 128], 13)) + (stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 + 31 / 32) > u:
                        uint256(stor[u].field_0) = 0
                        u = u + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            s = s + _7194 + ((block.timestamp * _6896 * _6881) - (_6899 * _6896 * _6881) / 10000 / 24 * 3600)
            t = t + _6766
            continue 
        _6724 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_6724 + 288] = ('cd', 4).length
        mem[_6724 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_6724 + ('cd', 4).length + 320] = 0
        mem[_6724] = _6724 + 288
        mem[_6724 + 32] = 0
        mem[_6724 + 64] = t
        mem[_6724 + 96] = block.timestamp
        mem[_6724 + 128] = s
        mem[_6724 + 160] = t
        mem[_6724 + 192] = 0
        mem[_6724 + 224] = 0
        mem[_6724 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_6724 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var82001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = t
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = s
            mem[mem[64] + 228] = t
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7659 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7662 = mem[_7659]
            mem[0] = mem[_7659]
            mem[32] = 13
            _7664 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_7664)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_7664] = 0
                    stor2[_7664] = t
                    stor3[_7664] = block.timestamp
                    stor4[_7664] = s
                    stor5[_7664] = t
                    uint256(stor6[_7664]) = 0
                    uint256(stor7[_7664].field_0) = 0
                    Mask(248, 0, stor7[_7664].field_8) = 5
                    mem[mem[64] + 4] = _7662
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _7662
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8734 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_8734] == mem[_8734 + 12 len 20]
                    if not mem[_8734 + 12 len 20]:
                        sub_ded2abc3[_7662] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7662
                        idx = 0
                        s = _6050
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _7662, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9451 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_7662] = mem[_9451]
                else:
                    uint256(stor[_7664].field_0) = 0
                    idx = 0
                    while (uint255(uint256(stor[_7664].field_0)) * 0.5) + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_7664] = 0
                    stor2[_7664] = t
                    stor3[_7664] = block.timestamp
                    stor4[_7664] = s
                    stor5[_7664] = t
                    uint256(stor6[_7664]) = 0
                    uint256(stor7[_7664].field_0) = 0
                    Mask(248, 0, stor7[_7664].field_8) = 5
                    mem[mem[64] + 4] = _7662
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _7662
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_8239] == mem[_8239 + 12 len 20]
                    if not mem[_8239 + 12 len 20]:
                        sub_ded2abc3[_7662] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7662
                        idx = 0
                        s = _6050
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _7662, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8685 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_7662] = mem[_8685]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_7664)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_7664] = 0
                    stor2[_7664] = t
                    stor3[_7664] = block.timestamp
                    stor4[_7664] = s
                    stor5[_7664] = t
                    uint256(stor6[_7664]) = 0
                    uint256(stor7[_7664].field_0) = 0
                    Mask(248, 0, stor7[_7664].field_8) = 5
                    mem[mem[64] + 4] = _7662
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _7662
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8738 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_8738] == mem[_8738 + 12 len 20]
                    if not mem[_8738 + 12 len 20]:
                        sub_ded2abc3[_7662] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7662
                        idx = 0
                        s = _6050
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _7662, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9452 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_7662] = mem[_9452]
                else:
                    uint256(stor[_7664].field_0) = 0
                    idx = 0
                    while stor[_7664].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_7664] = 0
                    stor2[_7664] = t
                    stor3[_7664] = block.timestamp
                    stor4[_7664] = s
                    stor5[_7664] = t
                    uint256(stor6[_7664]) = 0
                    uint256(stor7[_7664].field_0) = 0
                    Mask(248, 0, stor7[_7664].field_8) = 5
                    mem[mem[64] + 4] = _7662
                    require ext_code.size(stor8)
                    staticcall stor8.ownerOf(uint256 arg1) with:
                            gas gas_remaining wei
                           args _7662
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8242 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_8242] == mem[_8242 + 12 len 20]
                    if not mem[_8242 + 12 len 20]:
                        sub_ded2abc3[_7662] = 0
                    else:
                        mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _7662
                        idx = 0
                        s = _6050
                        t = mem[64] + 36
                        while idx < 4:
                            mem[t] = mem[s + 31 len 1]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(stor10)
                        staticcall stor10.0x90b82ddb with:
                                gas gas_remaining wei
                               args _7662, mem[mem[64] + 36 len 128]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8689 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        sub_ded2abc3[_7662] = mem[_8689]
            return _7662
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = t
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = s
        mem[mem[64] + 228] = t
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, t, block.timestamp, s, t, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _7660 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _7663 = mem[_7660]
        mem[0] = mem[_7660]
        mem[32] = 13
        _7667 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_7667)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_7667] = 0
                stor2[_7667] = t
                stor3[_7667] = block.timestamp
                stor4[_7667] = s
                stor5[_7667] = t
                uint256(stor6[_7667]) = 0
                uint256(stor7[_7667].field_0) = 0
                Mask(248, 0, stor7[_7667].field_8) = 5
                mem[mem[64] + 4] = _7663
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _7663
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8742 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_8742] == mem[_8742 + 12 len 20]
                if not mem[_8742 + 12 len 20]:
                    sub_ded2abc3[_7663] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7663
                    idx = 0
                    s = _6050
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _7663, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9453 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_7663] = mem[_9453]
            else:
                uint256(stor[_7667].field_0) = 0
                idx = 0
                while (uint255(uint256(stor[_7667].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_7667] = 0
                stor2[_7667] = t
                stor3[_7667] = block.timestamp
                stor4[_7667] = s
                stor5[_7667] = t
                uint256(stor6[_7667]) = 0
                uint256(stor7[_7667].field_0) = 0
                Mask(248, 0, stor7[_7667].field_8) = 5
                mem[mem[64] + 4] = _7663
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _7663
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8245 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_8245] == mem[_8245 + 12 len 20]
                if not mem[_8245 + 12 len 20]:
                    sub_ded2abc3[_7663] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7663
                    idx = 0
                    s = _6050
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _7663, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8693 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_7663] = mem[_8693]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_7667)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_7667] = 0
                stor2[_7667] = t
                stor3[_7667] = block.timestamp
                stor4[_7667] = s
                stor5[_7667] = t
                uint256(stor6[_7667]) = 0
                uint256(stor7[_7667].field_0) = 0
                Mask(248, 0, stor7[_7667].field_8) = 5
                mem[mem[64] + 4] = _7663
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _7663
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8746 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_8746] == mem[_8746 + 12 len 20]
                if not mem[_8746 + 12 len 20]:
                    sub_ded2abc3[_7663] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7663
                    idx = 0
                    s = _6050
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _7663, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9454 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_7663] = mem[_9454]
            else:
                uint256(stor[_7667].field_0) = 0
                idx = 0
                while stor[_7667].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_7667] = 0
                stor2[_7667] = t
                stor3[_7667] = block.timestamp
                stor4[_7667] = s
                stor5[_7667] = t
                uint256(stor6[_7667]) = 0
                uint256(stor7[_7667].field_0) = 0
                Mask(248, 0, stor7[_7667].field_8) = 5
                mem[mem[64] + 4] = _7663
                require ext_code.size(stor8)
                staticcall stor8.ownerOf(uint256 arg1) with:
                        gas gas_remaining wei
                       args _7663
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8248 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_8248] == mem[_8248 + 12 len 20]
                if not mem[_8248 + 12 len 20]:
                    sub_ded2abc3[_7663] = 0
                else:
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7663
                    idx = 0
                    s = _6050
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor10)
                    staticcall stor10.0x90b82ddb with:
                            gas gas_remaining wei
                           args _7663, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8697 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_7663] = mem[_8697]
        return _7663
}

function sub_5cb677ee(?) payable {
    require calldata.size - 4 >= 64
    mem[100] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    mem[ceil32(return_data.size) + 100] = arg1
    require ext_code.size(stor8)
    staticcall stor8.ownerOf(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'Not owner'
    mem[(2 * ceil32(return_data.size)) + 96] = 96
    mem[(2 * ceil32(return_data.size)) + 128] = 0
    mem[(2 * ceil32(return_data.size)) + 160] = 0
    mem[(2 * ceil32(return_data.size)) + 192] = 0
    mem[(2 * ceil32(return_data.size)) + 224] = 0
    mem[(2 * ceil32(return_data.size)) + 256] = 0
    mem[(2 * ceil32(return_data.size)) + 288] = 0
    mem[(2 * ceil32(return_data.size)) + 320] = 0
    mem[(2 * ceil32(return_data.size)) + 352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if not bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if bool(stor13[arg1].field_0):
                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, uint256(stor13[arg1].field_0)):
                    if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                        mem[(2 * ceil32(return_data.size)) + 704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[(2 * ceil32(return_data.size)) + 704] = uint256(stor13[arg1].field_0)
                        idx = (2 * ceil32(return_data.size)) + 704
                        s = 0
                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            else:
                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                if stor13[arg1].field_1 % 128:
                    if 31 >= stor13[arg1].field_1 % 128:
                        mem[(2 * ceil32(return_data.size)) + 704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[(2 * ceil32(return_data.size)) + 704] = uint256(stor13[arg1].field_0)
                        idx = (2 * ceil32(return_data.size)) + 704
                        s = 0
                        while (2 * ceil32(return_data.size)) + stor13[arg1].field_1 % 128 + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            if uint8(stor13[arg1].field_1792) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) != 4:
                revert with 0, 'Invalid token'
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 4:
                if block.timestamp < uint256(stor13[arg1].field_768):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) == 5:
                    if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                        revert with 0, 17
                    if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                        revert with 0, 17
                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                    else:
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if uint8(stor13[arg1].field_1800) != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if uint256(stor13[arg1].field_512) > !arg2:
                        revert with 0, 17
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if stor13[arg1].field_1 % 128:
                            uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[arg1].field_1 % 128:
                            uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_512) += arg2
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                else:
                    if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                        revert with 0, 17
                    if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                        revert with 0, 17
                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                    else:
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if uint8(stor13[arg1].field_1800) != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if uint256(stor13[arg1].field_512) > !arg2:
                        revert with 0, 17
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if stor13[arg1].field_1 % 128:
                            uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[arg1].field_1 % 128:
                            uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_512) += arg2
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
            else:
                if uint8(stor13[arg1].field_1800) != 5:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if block.timestamp < uint256(stor13[arg1].field_768):
                        revert with 0, 17
                    if uint8(stor13[arg1].field_1800) == 5:
                        if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                            revert with 0, 17
                        if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                            revert with 0, 17
                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                        else:
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if uint8(stor13[arg1].field_1800) != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if uint256(stor13[arg1].field_512) > !arg2:
                            revert with 0, 17
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if stor13[arg1].field_1 % 128:
                                uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[arg1].field_1 % 128:
                                uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_512) += arg2
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                    else:
                        if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                            revert with 0, 17
                        if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                            revert with 0, 17
                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                        else:
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if uint8(stor13[arg1].field_1800) != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if uint256(stor13[arg1].field_512) > !arg2:
                            revert with 0, 17
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if stor13[arg1].field_1 % 128:
                                uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[arg1].field_1 % 128:
                                uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_512) += arg2
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                else:
                    if sub_ded2abc3[arg1]:
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if block.timestamp < uint256(stor13[arg1].field_768):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) == 5:
                            if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                        else:
                            if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                    else:
                        require ext_code.size(stor8)
                        staticcall stor8.0xded2abc3 with:
                                gas gas_remaining wei
                               args arg1
                        mem[(2 * ceil32(return_data.size)) + ceil32(stor13[arg1].field_1 % 128) + 704] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if block.timestamp < uint256(stor13[arg1].field_768):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) == 5:
                            if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(4 * ceil32(return_data.size)) + ceil32(stor13[arg1].field_1 % 128) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                        else:
                            if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(4 * ceil32(return_data.size)) + ceil32(stor13[arg1].field_1 % 128) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor13[arg1].field_1 % 128:
                                    uint256(stor13[arg1][].field_0) = Array(len=stor13[arg1].field_1 % 128, data=mem[(2 * ceil32(return_data.size)) + 704 len stor13[arg1].field_1 % 128])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
        else:
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if bool(stor13[arg1].field_0):
                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                    if uint8(stor13[arg1].field_1792) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) != 4:
                        revert with 0, 'Invalid token'
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) == 4:
                        if block.timestamp < uint256(stor13[arg1].field_768):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) == 5:
                            if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                    else:
                        if uint8(stor13[arg1].field_1800) != 5:
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                        else:
                            if sub_ded2abc3[arg1]:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                            else:
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
                else:
                    if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                        mem[(2 * ceil32(return_data.size)) + 704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                        if uint8(stor13[arg1].field_1792) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) != 4:
                            revert with 0, 'Invalid token'
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 4:
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint8(stor13[arg1].field_1800) != 5:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if sub_ded2abc3[arg1]:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xded2abc3 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
                    else:
                        mem[(2 * ceil32(return_data.size)) + 704] = uint256(stor13[arg1].field_0)
                        idx = (2 * ceil32(return_data.size)) + 704
                        s = 0
                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint8(stor13[arg1].field_1792) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) != 4:
                            revert with 0, 'Invalid token'
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 4:
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint8(stor13[arg1].field_1800) != 5:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if sub_ded2abc3[arg1]:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xded2abc3 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
            else:
                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor13[arg1].field_1 % 128:
                    if uint8(stor13[arg1].field_1792) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) != 4:
                        revert with 0, 'Invalid token'
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[arg1].field_1800) == 4:
                        if block.timestamp < uint256(stor13[arg1].field_768):
                            revert with 0, 17
                        if uint8(stor13[arg1].field_1800) == 5:
                            if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                revert with 0, 17
                            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[arg1].field_1800) == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                            else:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if uint8(stor13[arg1].field_1800) != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if uint256(stor13[arg1].field_512) > !arg2:
                                revert with 0, 17
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                        if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            s = 0
                                            idx = (2 * ceil32(return_data.size)) + 704
                                            while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                uint256(stor13[arg1][s].field_0) = mem[idx]
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                    else:
                                        bool(stor13[arg1].field_0) = 0
                                        uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                        Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                            uint256(stor13[arg1].field_512) += arg2
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                    else:
                        if uint8(stor13[arg1].field_1800) != 5:
                            if uint8(stor13[arg1].field_1800) > 5:
                                revert with 0, 33
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                        else:
                            if sub_ded2abc3[arg1]:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                            else:
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
                else:
                    if 31 >= stor13[arg1].field_1 % 128:
                        mem[(2 * ceil32(return_data.size)) + 704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                        if uint8(stor13[arg1].field_1792) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) != 4:
                            revert with 0, 'Invalid token'
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 4:
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint8(stor13[arg1].field_1800) != 5:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if sub_ded2abc3[arg1]:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xded2abc3 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = Mask(248, 0, stor13[arg1].field_8)
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
                    else:
                        mem[(2 * ceil32(return_data.size)) + 704] = uint256(stor13[arg1].field_0)
                        idx = (2 * ceil32(return_data.size)) + 704
                        s = 0
                        while (2 * ceil32(return_data.size)) + stor13[arg1].field_1 % 128 + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint8(stor13[arg1].field_1792) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) != 4:
                            revert with 0, 'Invalid token'
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) > 5:
                            revert with 0, 33
                        if uint8(stor13[arg1].field_1800) == 4:
                            if block.timestamp < uint256(stor13[arg1].field_768):
                                revert with 0, 17
                            if uint8(stor13[arg1].field_1800) == 5:
                                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600
                            else:
                                if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[arg1].field_1800) == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                else:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if uint8(stor13[arg1].field_1800) != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if uint256(stor13[arg1].field_512) > !arg2:
                                    revert with 0, 17
                                if bool(stor13[arg1].field_0):
                                    if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                else:
                                    if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                        uint256(stor13[arg1].field_0) = 0
                                        idx = 0
                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                            uint256(stor13[arg1][idx].field_0) = 0
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                            if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                s = 0
                                                idx = (2 * ceil32(return_data.size)) + 704
                                                while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                    uint256(stor13[arg1][s].field_0) = mem[idx]
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            bool(stor13[arg1].field_0) = 0
                                            uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                            Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                uint256(stor13[arg1].field_512) += arg2
                                uint256(stor13[arg1].field_768) = block.timestamp
                                uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600
                        else:
                            if uint8(stor13[arg1].field_1800) != 5:
                                if uint8(stor13[arg1].field_1800) > 5:
                                    revert with 0, 33
                                if block.timestamp < uint256(stor13[arg1].field_768):
                                    revert with 0, 17
                                if uint8(stor13[arg1].field_1800) == 5:
                                    if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600
                                else:
                                    if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                    else:
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[arg1].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint256(stor13[arg1].field_512) > !arg2:
                                        revert with 0, 17
                                    if bool(stor13[arg1].field_0):
                                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    else:
                                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                            revert with 0, 34
                                        if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                            uint256(stor13[arg1].field_0) = 0
                                            idx = 0
                                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                uint256(stor13[arg1][idx].field_0) = 0
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    s = 0
                                                    idx = (2 * ceil32(return_data.size)) + 704
                                                    while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                        uint256(stor13[arg1][s].field_0) = mem[idx]
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                bool(stor13[arg1].field_0) = 0
                                                uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                    uint256(stor13[arg1].field_512) += arg2
                                    uint256(stor13[arg1].field_768) = block.timestamp
                                    uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600
                            else:
                                if sub_ded2abc3[arg1]:
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600
                                else:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xded2abc3 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[(2 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if uint8(stor13[arg1].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[arg1].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[arg1].field_1800) == 5:
                                        if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600
                                    else:
                                        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[arg1].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[arg1].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                        else:
                                            if uint8(stor13[arg1].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[arg1].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                        mem[(4 * ceil32(return_data.size)) + ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[arg1].field_512) > !arg2:
                                            revert with 0, 17
                                        if bool(stor13[arg1].field_0):
                                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        else:
                                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                                revert with 0, 34
                                            if not uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                uint256(stor13[arg1].field_0) = 0
                                                idx = 0
                                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                    uint256(stor13[arg1][idx].field_0) = 0
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                                                    uint256(stor13[arg1].field_0) = Mask(254, 1, uint256(stor13[arg1].field_0)) + 1
                                                    if not Mask(256, -1, uint256(stor13[arg1].field_0)):
                                                        idx = 0
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                    else:
                                                        s = 0
                                                        idx = (2 * ceil32(return_data.size)) + 704
                                                        while (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 704 > idx:
                                                            uint256(stor13[arg1][s].field_0) = mem[idx]
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = Mask(251, 0, (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31) >> 5
                                                        while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                            uint256(stor13[arg1][idx].field_0) = 0
                                                            idx = idx + 1
                                                            continue 
                                                else:
                                                    bool(stor13[arg1].field_0) = 0
                                                    uint255(stor13[arg1].field_1) = Mask(254, 0, stor13[arg1].field_1)
                                                    Mask(248, 0, stor13[arg1].field_8) = mem[(2 * ceil32(return_data.size)) + 704 len 31]
                                                    idx = 0
                                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                                        uint256(stor13[arg1][idx].field_0) = 0
                                                        idx = idx + 1
                                                        continue 
                                        uint256(stor13[arg1].field_512) += arg2
                                        uint256(stor13[arg1].field_768) = block.timestamp
                                        uint256(stor13[arg1].field_1024) += (block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        uint8(stor13[arg1].field_1792) = uint8(stor13[arg1].field_1792)
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = uint8(stor13[arg1].field_1800)
    else:
        mem[(2 * ceil32(return_data.size)) + 384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 388] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0x36dac2cc with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _21 = mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32
        require mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require return_data.size - mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 >= 288
        if not bool((4 * ceil32(return_data.size)) + 672 <= test266151307()):
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + 672
        _24 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384]
        require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
        _29 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
        if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
        mem[(4 * ceil32(return_data.size)) + 672] = _29
        require mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + _24 + _29 + 32 <= return_data.size
        mem[(4 * ceil32(return_data.size)) + 704 len ceil32(_29)] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384 len 4], Mask(224, 32, arg1) >> 32 + _24 + 416 len ceil32(_29)]
        if ceil32(_29) <= _29:
            mem[(4 * ceil32(return_data.size)) + 384] = (4 * ceil32(return_data.size)) + 672
            mem[(4 * ceil32(return_data.size)) + 416] = mem[(2 * ceil32(return_data.size)) + _21 + 416]
            mem[(4 * ceil32(return_data.size)) + 448] = mem[(2 * ceil32(return_data.size)) + _21 + 448]
            mem[(4 * ceil32(return_data.size)) + 480] = mem[(2 * ceil32(return_data.size)) + _21 + 480]
            mem[(4 * ceil32(return_data.size)) + 512] = mem[(2 * ceil32(return_data.size)) + _21 + 512]
            mem[(4 * ceil32(return_data.size)) + 544] = mem[(2 * ceil32(return_data.size)) + _21 + 544]
            mem[(4 * ceil32(return_data.size)) + 576] = mem[(2 * ceil32(return_data.size)) + _21 + 576]
            require mem[(2 * ceil32(return_data.size)) + _21 + 608] < 6
            mem[(4 * ceil32(return_data.size)) + 608] = mem[(2 * ceil32(return_data.size)) + _21 + 608]
            require mem[(2 * ceil32(return_data.size)) + _21 + 640] < 6
            mem[(4 * ceil32(return_data.size)) + 640] = mem[(2 * ceil32(return_data.size)) + _21 + 640]
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                revert with 0, 'Invalid token'
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] == 4:
                if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                    _39741 = mem[(4 * ceil32(return_data.size)) + 544]
                    _39753 = mem[(4 * ceil32(return_data.size)) + 480]
                    if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * stor5.length:
                        revert with 0, 17
                    _39861 = mem[(4 * ceil32(return_data.size)) + 512]
                    if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _40237 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600) and mem[_40237] > -1 / _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40297 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600) and mem[_40297] > -1 / _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40298 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600) and mem[_40298] > -1 / _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                    uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) = _39861 + ((block.timestamp * _39741 * stor5.length) - (_39753 * _39741 * stor5.length) / 10000 / 24 * 3600)
                else:
                    _39742 = mem[(4 * ceil32(return_data.size)) + 448]
                    _39754 = mem[(4 * ceil32(return_data.size)) + 480]
                    if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * stor5.length:
                        revert with 0, 17
                    _39862 = mem[(4 * ceil32(return_data.size)) + 512]
                    if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _40242 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600) and mem[_40242] > -1 / _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40300 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600) and mem[_40300] > -1 / _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40301 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600) and mem[_40301] > -1 / _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                    uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) = _39862 + ((block.timestamp * _39742 * stor5.length) - (_39754 * _39742 * stor5.length) / 10000 / 24 * 3600)
            else:
                if mem[(4 * ceil32(return_data.size)) + 640] != 5:
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        _39760 = mem[(4 * ceil32(return_data.size)) + 544]
                        _39767 = mem[(4 * ceil32(return_data.size)) + 480]
                        if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * stor4.length:
                            revert with 0, 17
                        _39945 = mem[(4 * ceil32(return_data.size)) + 512]
                        if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40307 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600) and mem[_40307] > -1 / _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40377 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600) and mem[_40377] > -1 / _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40378 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600) and mem[_40378] > -1 / _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                        uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) = _39945 + ((block.timestamp * _39760 * stor4.length) - (_39767 * _39760 * stor4.length) / 10000 / 24 * 3600)
                    else:
                        _39761 = mem[(4 * ceil32(return_data.size)) + 448]
                        _39768 = mem[(4 * ceil32(return_data.size)) + 480]
                        if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * stor4.length:
                            revert with 0, 17
                        _39946 = mem[(4 * ceil32(return_data.size)) + 512]
                        if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40312 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600) and mem[_40312] > -1 / _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40380 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600) and mem[_40380] > -1 / _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40381 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600) and mem[_40381] > -1 / _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                        uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) = _39946 + ((block.timestamp * _39761 * stor4.length) - (_39768 * _39761 * stor4.length) / 10000 / 24 * 3600)
                else:
                    mem[0] = arg1
                    mem[32] = 12
                    if sub_ded2abc3[arg1]:
                        mem[0] = arg1
                        mem[32] = 12
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            _39765 = mem[(4 * ceil32(return_data.size)) + 544]
                            _39773 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            _40015 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40349 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40349] > -1 / _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40401 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40401] > -1 / _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40402 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40402] > -1 / _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40015 + ((block.timestamp * _39765 * sub_ded2abc3[arg1]) - (_39773 * _39765 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600)
                        else:
                            _39766 = mem[(4 * ceil32(return_data.size)) + 448]
                            _39774 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            _40016 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40354 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40354] > -1 / _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40404 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40404] > -1 / _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40405 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40405] > -1 / _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40016 + ((block.timestamp * _39766 * sub_ded2abc3[arg1]) - (_39774 * _39766 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600)
                    else:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(stor8)
                        staticcall stor8.0xded2abc3 with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _39759 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _39775 = mem[_39759]
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            _39789 = mem[(4 * ceil32(return_data.size)) + 544]
                            _39801 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] and mem[_39759] > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] * mem[_39759] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * mem[_39759]:
                                revert with 0, 17
                            _40185 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * mem[_39759]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * mem[_39759]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40537 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600) and mem[_40537] > -1 / _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40657 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600) and mem[_40657] > -1 / _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40658 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600) and mem[_40658] > -1 / _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40185 + ((block.timestamp * _39789 * _39775) - (_39801 * _39789 * _39775) / 10000 / 24 * 3600)
                        else:
                            _39790 = mem[(4 * ceil32(return_data.size)) + 448]
                            _39802 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] and mem[_39759] > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] * mem[_39759] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * mem[_39759]:
                                revert with 0, 17
                            _40186 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * mem[_39759]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * mem[_39759]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40542 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600) and mem[_40542] > -1 / _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40660 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600) and mem[_40660] > -1 / _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40661 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600) and mem[_40661] > -1 / _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40186 + ((block.timestamp * _39790 * _39775) - (_39802 * _39790 * _39775) / 10000 / 24 * 3600)
        else:
            mem[_29 + (4 * ceil32(return_data.size)) + 704] = 0
            mem[(4 * ceil32(return_data.size)) + 384] = (4 * ceil32(return_data.size)) + 672
            mem[(4 * ceil32(return_data.size)) + 416] = mem[(2 * ceil32(return_data.size)) + _21 + 416]
            mem[(4 * ceil32(return_data.size)) + 448] = mem[(2 * ceil32(return_data.size)) + _21 + 448]
            mem[(4 * ceil32(return_data.size)) + 480] = mem[(2 * ceil32(return_data.size)) + _21 + 480]
            mem[(4 * ceil32(return_data.size)) + 512] = mem[(2 * ceil32(return_data.size)) + _21 + 512]
            mem[(4 * ceil32(return_data.size)) + 544] = mem[(2 * ceil32(return_data.size)) + _21 + 544]
            mem[(4 * ceil32(return_data.size)) + 576] = mem[(2 * ceil32(return_data.size)) + _21 + 576]
            require mem[(2 * ceil32(return_data.size)) + _21 + 608] < 6
            mem[(4 * ceil32(return_data.size)) + 608] = mem[(2 * ceil32(return_data.size)) + _21 + 608]
            require mem[(2 * ceil32(return_data.size)) + _21 + 640] < 6
            mem[(4 * ceil32(return_data.size)) + 640] = mem[(2 * ceil32(return_data.size)) + _21 + 640]
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                revert with 0, 'Invalid token'
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(4 * ceil32(return_data.size)) + 640] == 4:
                if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                    _39747 = mem[(4 * ceil32(return_data.size)) + 544]
                    _39756 = mem[(4 * ceil32(return_data.size)) + 480]
                    if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * stor5.length:
                        revert with 0, 17
                    _39863 = mem[(4 * ceil32(return_data.size)) + 512]
                    if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _40251 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600) and mem[_40251] > -1 / _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40313 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600) and mem[_40313] > -1 / _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40314 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600) and mem[_40314] > -1 / _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                    uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) = _39863 + ((block.timestamp * _39747 * stor5.length) - (_39756 * _39747 * stor5.length) / 10000 / 24 * 3600)
                else:
                    _39748 = mem[(4 * ceil32(return_data.size)) + 448]
                    _39757 = mem[(4 * ceil32(return_data.size)) + 480]
                    if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * stor5.length:
                        revert with 0, 17
                    _39864 = mem[(4 * ceil32(return_data.size)) + 512]
                    if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _40256 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600) and mem[_40256] > -1 / _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40316 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600) and mem[_40316] > -1 / _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40317 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600) and mem[_40317] > -1 / _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                    if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                    if bool(stor13[arg1].field_0):
                        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    else:
                        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                            revert with 0, 34
                        if _29:
                            uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                        else:
                            uint256(stor13[arg1].field_0) = 0
                            idx = 0
                            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                uint256(stor13[arg1][idx].field_0) = 0
                                idx = idx + 1
                                continue 
                    uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                    uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                    uint256(stor13[arg1].field_768) = block.timestamp
                    uint256(stor13[arg1].field_1024) = _39864 + ((block.timestamp * _39748 * stor5.length) - (_39757 * _39748 * stor5.length) / 10000 / 24 * 3600)
            else:
                if mem[(4 * ceil32(return_data.size)) + 640] != 5:
                    if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                        _39763 = mem[(4 * ceil32(return_data.size)) + 544]
                        _39771 = mem[(4 * ceil32(return_data.size)) + 480]
                        if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * stor4.length:
                            revert with 0, 17
                        _39947 = mem[(4 * ceil32(return_data.size)) + 512]
                        if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40323 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600) and mem[_40323] > -1 / _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40387 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600) and mem[_40387] > -1 / _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40388 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600) and mem[_40388] > -1 / _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                        uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) = _39947 + ((block.timestamp * _39763 * stor4.length) - (_39771 * _39763 * stor4.length) / 10000 / 24 * 3600)
                    else:
                        _39764 = mem[(4 * ceil32(return_data.size)) + 448]
                        _39772 = mem[(4 * ceil32(return_data.size)) + 480]
                        if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * stor4.length:
                            revert with 0, 17
                        _39948 = mem[(4 * ceil32(return_data.size)) + 512]
                        if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _40328 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600) and mem[_40328] > -1 / _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                        else:
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40390 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600) and mem[_40390] > -1 / _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40391 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600) and mem[_40391] > -1 / _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                        if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                        if bool(stor13[arg1].field_0):
                            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        else:
                            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                revert with 0, 34
                            if _29:
                                uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                            else:
                                uint256(stor13[arg1].field_0) = 0
                                idx = 0
                                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                    uint256(stor13[arg1][idx].field_0) = 0
                                    idx = idx + 1
                                    continue 
                        uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                        uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                        uint256(stor13[arg1].field_768) = block.timestamp
                        uint256(stor13[arg1].field_1024) = _39948 + ((block.timestamp * _39764 * stor4.length) - (_39772 * _39764 * stor4.length) / 10000 / 24 * 3600)
                else:
                    mem[0] = arg1
                    mem[32] = 12
                    if sub_ded2abc3[arg1]:
                        mem[0] = arg1
                        mem[32] = 12
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            _39769 = mem[(4 * ceil32(return_data.size)) + 544]
                            _39776 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            _40019 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40359 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40359] > -1 / _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40407 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40407] > -1 / _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40408 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40408] > -1 / _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40019 + ((block.timestamp * _39769 * sub_ded2abc3[arg1]) - (_39776 * _39769 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600)
                        else:
                            _39770 = mem[(4 * ceil32(return_data.size)) + 448]
                            _39777 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
                                revert with 0, 17
                            _40020 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40364 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40364] > -1 / _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40410 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40410] > -1 / _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40411 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_40411] > -1 / _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40020 + ((block.timestamp * _39770 * sub_ded2abc3[arg1]) - (_39777 * _39770 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600)
                    else:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(stor8)
                        staticcall stor8.0xded2abc3 with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _39762 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _39778 = mem[_39762]
                        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                            revert with 0, 33
                        if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                            _39791 = mem[(4 * ceil32(return_data.size)) + 544]
                            _39803 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] and mem[_39762] > -1 / mem[(4 * ceil32(return_data.size)) + 544]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 544] * mem[_39762] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 544] * mem[_39762]:
                                revert with 0, 17
                            _40191 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 544] * mem[_39762]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 544] * mem[_39762]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40547 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600) and mem[_40547] > -1 / _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40663 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600) and mem[_40663] > -1 / _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40664 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600) and mem[_40664] > -1 / _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40191 + ((block.timestamp * _39791 * _39778) - (_39803 * _39791 * _39778) / 10000 / 24 * 3600)
                        else:
                            _39792 = mem[(4 * ceil32(return_data.size)) + 448]
                            _39804 = mem[(4 * ceil32(return_data.size)) + 480]
                            if block.timestamp < mem[(4 * ceil32(return_data.size)) + 480]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] and mem[_39762] > -1 / mem[(4 * ceil32(return_data.size)) + 448]:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] * mem[_39762] and block.timestamp - mem[(4 * ceil32(return_data.size)) + 480] > -1 / mem[(4 * ceil32(return_data.size)) + 448] * mem[_39762]:
                                revert with 0, 17
                            _40192 = mem[(4 * ceil32(return_data.size)) + 512]
                            if mem[(4 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(4 * ceil32(return_data.size)) + 448] * mem[_39762]) - (mem[(4 * ceil32(return_data.size)) + 480] * mem[(4 * ceil32(return_data.size)) + 448] * mem[_39762]) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                revert with 0, 33
                            if mem[(4 * ceil32(return_data.size)) + 640] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _40552 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600) and mem[_40552] > -1 / _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600):
                                    revert with 0, 17
                            else:
                                if mem[(4 * ceil32(return_data.size)) + 640] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[(4 * ceil32(return_data.size)) + 640] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40666 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600) and mem[_40666] > -1 / _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _40667 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600) and mem[_40667] > -1 / _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600):
                                        revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 448] > !arg2:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 448] = mem[(4 * ceil32(return_data.size)) + 448] + arg2
                            if bool(stor13[arg1].field_0):
                                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            else:
                                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                                    revert with 0, 34
                                if _29:
                                    uint256(stor13[arg1][].field_0) = Array(len=_29, data=mem[(4 * ceil32(return_data.size)) + 704 len _29])
                                else:
                                    uint256(stor13[arg1].field_0) = 0
                                    idx = 0
                                    while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                                        uint256(stor13[arg1][idx].field_0) = 0
                                        idx = idx + 1
                                        continue 
                            uint256(stor13[arg1].field_256) = mem[(4 * ceil32(return_data.size)) + 416]
                            uint256(stor13[arg1].field_512) = mem[(4 * ceil32(return_data.size)) + 448]
                            uint256(stor13[arg1].field_768) = block.timestamp
                            uint256(stor13[arg1].field_1024) = _40192 + ((block.timestamp * _39792 * _39778) - (_39804 * _39792 * _39778) / 10000 / 24 * 3600)
        uint256(stor13[arg1].field_1280) = mem[(4 * ceil32(return_data.size)) + 544]
        uint256(stor13[arg1].field_1536) = mem[(4 * ceil32(return_data.size)) + 576]
        if mem[(4 * ceil32(return_data.size)) + 608] > 5:
            revert with 0, 33
        uint256(stor13[arg1].field_1792) = mem[(4 * ceil32(return_data.size)) + 608]
        if mem[(4 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = mem[(4 * ceil32(return_data.size)) + 641 len 31]
}

function sub_335ce7a9(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    mem[ceil32(32 * ('cd', 4).length) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(32 * ('cd', 4).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        if mem[(32 * idx) + 128] != 0:
            if idx >= mem[96]:
                revert with 0, 50
            _4696 = mem[(32 * idx) + 128]
            _4697 = mem[64]
            mem[64] = mem[64] + 288
            mem[_4697] = 96
            mem[_4697 + 32] = 0
            mem[_4697 + 64] = 0
            mem[_4697 + 96] = 0
            mem[_4697 + 128] = 0
            mem[_4697 + 160] = 0
            mem[_4697 + 192] = 0
            mem[_4697 + 224] = 0
            mem[_4697 + 256] = 0
            mem[0] = _4696
            mem[32] = 13
            if uint256(stor13[_4696].field_512):
                mem[0] = _4696
                mem[32] = 13
                _4700 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_4696].field_0):
                    if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _4704 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_4696].field_0)) * 0.5) + 32
                    mem[_4704] = uint255(uint256(stor13[_4696].field_0)) * 0.5
                    if bool(stor13[_4696].field_0):
                        if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor13[_4696].field_0)):
                            mem[_4700] = _4704
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5250 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5250] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5250]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5250]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5346 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5346] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5346]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5346]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5347 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5347] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5347]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5347]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5255 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5255] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5255]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5255]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5349 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5349] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5349]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5349]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5350 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5350] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5350]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5350]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5356 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5356] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5356]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5356]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5516 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5516] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5516]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5516]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5517 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5517] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5517]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5517]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5361 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5361] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5361]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5361]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5519 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5519] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5519]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5519]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5520 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5520] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5520]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5520]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5420 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5420] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5420]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5420]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5620 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5620] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5620]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5620]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5621 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5621] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5621]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5621]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5425 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5425] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5425]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5425]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5623 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5623] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5623]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5623]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5624 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5624] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5624]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5624]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4769 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4832 = mem[_4769]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4769] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4769] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4769]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4769]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4769]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5978 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600) and mem[_5978] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5978]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600 * mem[_5978]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6162 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600) and mem[_6162] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6162]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600 * mem[_6162]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6163 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600) and mem[_6163] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6163]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4832) / 10000 / 24 * 3600 * mem[_6163]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4769] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4769] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4769]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4769]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4769]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5983 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600) and mem[_5983] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5983]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600 * mem[_5983]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6165 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600) and mem[_6165] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6165]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600 * mem[_6165]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6166 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600) and mem[_6166] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6166]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4832) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4832) / 10000 / 24 * 3600 * mem[_6166]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= uint255(uint256(stor13[_4696].field_0)) * 0.5:
                                mem[_4704 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5372 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5372] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5372]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5372]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5536 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5536] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5536]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5536]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5537 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5537] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5537]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5537]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5377 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5377] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5377]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5377]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5539 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5539] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5539]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5539]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5540 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5540] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5540]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5540]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5546 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5546] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5546]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5546]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5770 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5770] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5770]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5770]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5771 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5771] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5771]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5771]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5551 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5551] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5551]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5551]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5773 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5773] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5773]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5773]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5774 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5774] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5774]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5774]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5636 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5636] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5636]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5636]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5878 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5878] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5878]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5878]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5879 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5879] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5879]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5879]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5641 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5641] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5641]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5641]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5881 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5881] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5881]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5881]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5882 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5882] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5882]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5882]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4839 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4925 = mem[_4839]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4839] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4839] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4839]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4839]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4839]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6180 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600) and mem[_6180] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6180]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600 * mem[_6180]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6312 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600) and mem[_6312] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6312]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600 * mem[_6312]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6313 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600) and mem[_6313] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6313]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4925) / 10000 / 24 * 3600 * mem[_6313]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4839] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4839] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4839]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4839]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4839]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6185 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600) and mem[_6185] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6185]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600 * mem[_6185]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6315 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600) and mem[_6315] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6315]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600 * mem[_6315]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6316 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600) and mem[_6316] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6316]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4925) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4925) / 10000 / 24 * 3600 * mem[_6316]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4704 + 32] = uint256(stor13[_4696].field_0)
                                s = _4704 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4704 + (uint255(uint256(stor13[_4696].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7293 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7293] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7293]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7293]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7373 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7373] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7373]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7373]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7374 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7374] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7374]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7374]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7298 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7298] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7298]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7298]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7376 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7376] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7376]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7376]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7377 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7377] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7377]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7377]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7383 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7383] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7383]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7383]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7489 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7489] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7489]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7489]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7490 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7490] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7490]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7490]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7388 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7388] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7388]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7388]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7492 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7492] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7492]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7492]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7493 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7493] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7493]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7493]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7449 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7449] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7449]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7449]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7529 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7529] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7529]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7529]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7530 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7530] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7530]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7530]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7454 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7454] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7454]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7454]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7532 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7532] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7532]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7532]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7533 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7533] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7533]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7533]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7097 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7127 = mem[_7097]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7097] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7097] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7097]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7097]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7097]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7621 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7621] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7621]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7621]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7685 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7685] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7685]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7685]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7686 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7686] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7686]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7686]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7097] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7097] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7097]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7097]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7097]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7626 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7626] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7626]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7626]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7688 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7688] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7688]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7688]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7689 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7689] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7689]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7689]) / 10000):
                                                                revert with 0, 17
                    else:
                        if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor13[_4696].field_1 % 128:
                            mem[_4700] = _4704
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5298 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5298] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5298]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5298]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5432 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5432] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5432]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5432]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5433 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5433] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5433]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5433]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5303 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5303] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5303]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5303]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5435 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5435] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5435]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5435]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5436 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5436] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5436]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5436]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5442 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5442] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5442]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5442]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5646 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5646] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5646]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5646]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5647 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5647] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5647]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5647]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5447 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5447] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5447]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5447]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5649 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5649] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5649]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5649]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5650 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5650] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5650]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5650]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5556 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5556] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5556]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5556]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5776 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5776] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5776]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5776]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5777 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5777] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5777]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5777]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5561 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5561] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5561]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5561]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5779 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5779] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5779]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5779]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5780 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5780] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5780]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5780]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4805 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4877 = mem[_4805]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4805] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4805] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4805]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4805]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4805]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6090 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600) and mem[_6090] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6090]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600 * mem[_6090]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6238 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600) and mem[_6238] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6238]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600 * mem[_6238]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6239 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600) and mem[_6239] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6239]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4877) / 10000 / 24 * 3600 * mem[_6239]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4805] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4805] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4805]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4805]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4805]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6095 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600) and mem[_6095] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6095]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600 * mem[_6095]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6241 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600) and mem[_6241] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6241]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600 * mem[_6241]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6242 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600) and mem[_6242] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6242]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4877) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4877) / 10000 / 24 * 3600 * mem[_6242]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= stor13[_4696].field_1 % 128:
                                mem[_4704 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5458 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5458] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5458]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5458]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5666 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5666] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5666]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5666]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5667 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5667] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5667]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5667]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5463 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5463] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5463]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5463]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5669 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5669] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5669]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5669]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5670 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5670] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5670]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5670]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5676 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5676] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5676]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5676]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5912 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5912] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5912]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5912]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5913 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5913] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5913]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5913]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5681 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5681] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5681]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5681]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5915 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5915] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5915]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5915]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5916 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5916] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5916]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5916]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5792 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5792] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5792]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5792]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6016 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6016] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6016]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6016]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6017 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6017] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6017]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6017]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5797 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5797] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5797]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5797]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6019 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6019] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6019]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6019]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6020 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6020] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6020]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6020]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4884 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4964 = mem[_4884]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4884] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4884] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4884]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4884]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4884]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6256 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600) and mem[_6256] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6256]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600 * mem[_6256]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6368 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600) and mem[_6368] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6368]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600 * mem[_6368]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6369 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600) and mem[_6369] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6369]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4964) / 10000 / 24 * 3600 * mem[_6369]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4884] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4884] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4884]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4884]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4884]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6261 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600) and mem[_6261] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6261]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600 * mem[_6261]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6371 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600) and mem[_6371] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6371]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600 * mem[_6371]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6372 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600) and mem[_6372] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6372]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4964) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4964) / 10000 / 24 * 3600 * mem[_6372]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4704 + 32] = uint256(stor13[_4696].field_0)
                                s = _4704 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4704 + stor13[_4696].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7307 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7307] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7307]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7307]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7389 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7389] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7389]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7389]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7390 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7390] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7390]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7390]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7312 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7312] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7312]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7312]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7392 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7392] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7392]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7392]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7393 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7393] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7393]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7393]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7399 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7399] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7399]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7399]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7499 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7499] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7499]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7499]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7500 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7500] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7500]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7500]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7404 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7404] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7404]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7404]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7502 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7502] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7502]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7502]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7503 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7503] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7503]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7503]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7459 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7459] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7459]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7459]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7535 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7535] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7535]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7535]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7536 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7536] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7536]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7536]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7464 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7464] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7464]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7464]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7538 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7538] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7538]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7538]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7539 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7539] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7539]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7539]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7100 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7130 = mem[_7100]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7100] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7100] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7100]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7100]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7100]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7631 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7631] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7631]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7631]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7691 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7691] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7691]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7691]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7692 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7692] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7692]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7692]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7100] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7100] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7100]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7100]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7100]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7636 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7636] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7636]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7636]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7694 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7694] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7694]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7694]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7695 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7695] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7695]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7695]) / 10000):
                                                                revert with 0, 17
                else:
                    if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                        revert with 0, 34
                    _4706 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_4696].field_1 % 128) + 32
                    mem[_4706] = stor13[_4696].field_1 % 128
                    if bool(stor13[_4696].field_0):
                        if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor13[_4696].field_0)):
                            mem[_4700] = _4706
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5320 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5320] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5320]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5320]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5468 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5468] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5468]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5468]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5469 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5469] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5469]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5469]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5325 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5325] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5325]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5325]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5471 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5471] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5471]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5471]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5472 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5472] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5472]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5472]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5478 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5478] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5478]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5478]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5686 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5686] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5686]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5686]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5687 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5687] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5687]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5687]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5483 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5483] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5483]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5483]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5689 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5689] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5689]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5689]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5690 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5690] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5690]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5690]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5572 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5572] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5572]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5572]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5798 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5798] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5798]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5798]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5799 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5799] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5799]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5799]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5577 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5577] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5577]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5577]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5801 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5801] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5801]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5801]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5802 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5802] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5802]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5802]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4815 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4889 = mem[_4815]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4815] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4815] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4815]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4815]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4815]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6118 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600) and mem[_6118] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6118]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600 * mem[_6118]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6262 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600) and mem[_6262] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6262]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600 * mem[_6262]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6263 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600) and mem[_6263] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6263]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4889) / 10000 / 24 * 3600 * mem[_6263]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4815] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4815] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4815]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4815]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4815]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6123 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600) and mem[_6123] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6123]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600 * mem[_6123]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6265 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600) and mem[_6265] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6265]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600 * mem[_6265]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6266 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600) and mem[_6266] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6266]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4889) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4889) / 10000 / 24 * 3600 * mem[_6266]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= uint255(uint256(stor13[_4696].field_0)) * 0.5:
                                mem[_4706 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5494 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5494] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5494]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5494]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5706 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5706] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5706]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5706]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5707 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5707] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5707]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5707]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5499 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5499] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5499]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5499]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5709 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5709] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5709]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5709]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5710 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5710] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5710]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5710]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5716 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5716] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5716]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5716]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5946 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5946] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5946]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5946]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5947 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5947] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5947]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5947]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5721 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5721] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5721]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5721]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5949 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5949] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5949]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5949]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5950 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5950] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5950]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5950]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5814 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5814] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5814]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5814]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6036 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6036] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6036]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6036]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6037 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6037] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6037]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6037]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5819 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5819] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5819]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5819]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6039 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6039] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6039]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6039]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6040 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6040] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6040]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6040]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4896 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4971 = mem[_4896]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4896] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4896] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4896]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4896]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4896]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6280 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600) and mem[_6280] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6280]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600 * mem[_6280]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6390 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600) and mem[_6390] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6390]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600 * mem[_6390]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6391 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600) and mem[_6391] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6391]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4971) / 10000 / 24 * 3600 * mem[_6391]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4896] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4896] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4896]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4896]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4896]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6285 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600) and mem[_6285] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6285]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600 * mem[_6285]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6393 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600) and mem[_6393] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6393]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600 * mem[_6393]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6394 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600) and mem[_6394] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6394]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4971) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4971) / 10000 / 24 * 3600 * mem[_6394]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4706 + 32] = uint256(stor13[_4696].field_0)
                                s = _4706 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4706 + (uint255(uint256(stor13[_4696].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7321 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7321] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7321]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7321]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7405 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7405] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7405]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7405]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7406 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7406] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7406]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7406]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7326 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7326] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7326]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7326]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7408 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7408] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7408]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7408]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7409 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7409] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7409]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7409]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7415 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7415] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7415]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7415]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7509 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7509] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7509]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7509]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7510 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7510] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7510]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7510]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7420 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7420] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7420]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7420]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7512 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7512] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7512]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7512]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7513 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7513] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7513]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7513]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7469 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7469] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7469]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7469]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7541 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7541] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7541]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7541]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7542 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7542] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7542]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7542]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7474 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7474] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7474]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7474]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7544 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7544] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7544]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7544]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7545 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7545] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7545]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7545]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7103 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7133 = mem[_7103]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7103] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7103] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7103]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7103]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7103]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7641 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600) and mem[_7641] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7641]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600 * mem[_7641]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7697 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600) and mem[_7697] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7697]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600 * mem[_7697]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7698 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600) and mem[_7698] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7698]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7133) / 10000 / 24 * 3600 * mem[_7698]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7103] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7103] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7103]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7103]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7103]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7646 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600) and mem[_7646] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7646]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600 * mem[_7646]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7700 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600) and mem[_7700] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7700]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600 * mem[_7700]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7701 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600) and mem[_7701] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7701]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7133) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7133) / 10000 / 24 * 3600 * mem[_7701]) / 10000):
                                                                revert with 0, 17
                    else:
                        if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor13[_4696].field_1 % 128:
                            mem[_4700] = _4706
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5398 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5398] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5398]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5398]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5584 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5584] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5584]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5584]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5585 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5585] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5585]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5585]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5403 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5403] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5403]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5403]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5587 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5587] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5587]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5587]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5588 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5588] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5588]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5588]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5594 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5594] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5594]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5594]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5824 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5824] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5824]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5824]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5825 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5825] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5825]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5825]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5599 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5599] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5599]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5599]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5827 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5827] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5827]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5827]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5828 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5828] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5828]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5828]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5726 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5726] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5726]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5726]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5952 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5952] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5952]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5952]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5953 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5953] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5953]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5953]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5731 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5731] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5731]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5731]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5955 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5955] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5955]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5955]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5956 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5956] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5956]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5956]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4858 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4942 = mem[_4858]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4858] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4858] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4858]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4858]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4858]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6210 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600) and mem[_6210] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6210]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600 * mem[_6210]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6326 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600) and mem[_6326] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6326]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600 * mem[_6326]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6327 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600) and mem[_6327] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6327]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4942) / 10000 / 24 * 3600 * mem[_6327]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4858] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4858] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4858]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4858]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4858]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6215 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600) and mem[_6215] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6215]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600 * mem[_6215]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6329 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600) and mem[_6329] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6329]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600 * mem[_6329]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6330 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600) and mem[_6330] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6330]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4942) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4942) / 10000 / 24 * 3600 * mem[_6330]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= stor13[_4696].field_1 % 128:
                                mem[_4706 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5610 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5610] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5610]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5610]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5844 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5844] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5844]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5844]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5845 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5845] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5845]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5845]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5615 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5615] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5615]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5615]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5847 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5847] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5847]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5847]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5848 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5848] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5848]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5848]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5854 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5854] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5854]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5854]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6070 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_6070] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6070]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_6070]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6071 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_6071] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6071]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_6071]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5859 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5859] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5859]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5859]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6073 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_6073] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6073]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_6073]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6074 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_6074] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6074]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_6074]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5968 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5968] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5968]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5968]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6156 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6156] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6156]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6156]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6157 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6157] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6157]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6157]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5973 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5973] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5973]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5973]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6159 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6159] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6159]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6159]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6160 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6160] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6160]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6160]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4949 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4999 = mem[_4949]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4949] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4949] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4949]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4949]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4949]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6344 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600) and mem[_6344] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6344]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600 * mem[_6344]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6440 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600) and mem[_6440] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6440]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600 * mem[_6440]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6441 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600) and mem[_6441] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6441]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4999) / 10000 / 24 * 3600 * mem[_6441]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4949] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4949] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4949]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4949]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4949]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6349 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600) and mem[_6349] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6349]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600 * mem[_6349]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6443 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600) and mem[_6443] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6443]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600 * mem[_6443]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6444 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600) and mem[_6444] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6444]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4999) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4999) / 10000 / 24 * 3600 * mem[_6444]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4706 + 32] = uint256(stor13[_4696].field_0)
                                s = _4706 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4706 + stor13[_4696].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7335 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7335] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7335]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7335]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7421 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7421] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7421]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7421]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7422 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7422] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7422]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7422]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7340 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7340] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7340]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7340]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7424 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7424] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7424]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7424]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7425 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7425] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7425]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7425]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7431 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7431] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7431]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7431]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7519 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7519] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7519]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7519]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7520 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7520] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7520]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7520]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7436 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7436] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7436]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7436]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7522 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7522] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7522]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7522]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7523 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7523] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7523]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7523]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7479 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7479] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7479]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7479]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7547 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7547] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7547]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7547]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7548 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7548] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7548]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7548]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7484 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7484] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7484]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7484]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7550 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7550] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7550]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7550]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7551 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7551] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7551]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7551]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7106 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7136 = mem[_7106]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7106] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7106] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7106]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7106]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7106]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7651 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600) and mem[_7651] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7651]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600 * mem[_7651]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7703 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600) and mem[_7703] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7703]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600 * mem[_7703]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7704 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600) and mem[_7704] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7704]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7136) / 10000 / 24 * 3600 * mem[_7704]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7106] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7106] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7106]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7106]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7106]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7656 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600) and mem[_7656] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7656]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600 * mem[_7656]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7706 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600) and mem[_7706] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7706]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600 * mem[_7706]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7707 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600) and mem[_7707] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length >= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7707]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7136) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7136) / 10000 / 24 * 3600 * mem[_7707]) / 10000):
                                                                revert with 0, 17
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4696
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _4696
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4703 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4705 = mem[_4703]
                require mem[_4703] <= test266151307()
                require return_data.size - mem[_4703] >= 288
                if not bool(_4703 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _4703 + ceil32(return_data.size) + 288
                _4708 = mem[_4703 + _4705]
                require mem[_4703 + _4705] <= test266151307()
                require _4703 + _4705 + mem[_4703 + _4705] + 31 < _4703 + return_data.size
                _4713 = mem[_4703 + _4705 + mem[_4703 + _4705]]
                if mem[_4703 + _4705 + mem[_4703 + _4705]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289 < 288 or _4703 + ceil32(return_data.size) + ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _4703 + ceil32(return_data.size) + ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289
                mem[_4703 + ceil32(return_data.size) + 288] = _4713
                require _4705 + _4708 + _4713 + 32 <= return_data.size
                s = 0
                while s < _4713:
                    mem[s + _4703 + ceil32(return_data.size) + 320] = mem[s + _4703 + _4705 + _4708 + 32]
                    s = s + 32
                    continue 
                if ceil32(_4713) <= _4713:
                    mem[_4703 + ceil32(return_data.size)] = _4703 + ceil32(return_data.size) + 288
                    mem[_4703 + ceil32(return_data.size) + 32] = mem[_4703 + _4705 + 32]
                    mem[_4703 + ceil32(return_data.size) + 64] = mem[_4703 + _4705 + 64]
                    mem[_4703 + ceil32(return_data.size) + 96] = mem[_4703 + _4705 + 96]
                    mem[_4703 + ceil32(return_data.size) + 128] = mem[_4703 + _4705 + 128]
                    mem[_4703 + ceil32(return_data.size) + 160] = mem[_4703 + _4705 + 160]
                    mem[_4703 + ceil32(return_data.size) + 192] = mem[_4703 + _4705 + 192]
                    require mem[_4703 + _4705 + 224] < 6
                    mem[_4703 + ceil32(return_data.size) + 224] = mem[_4703 + _4705 + 224]
                    require mem[_4703 + _4705 + 256] < 6
                    mem[_4703 + ceil32(return_data.size) + 256] = mem[_4703 + _4705 + 256]
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] == 4:
                        if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                            _7165 = mem[_4703 + ceil32(return_data.size) + 160]
                            _7177 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor5.length:
                                revert with 0, 17
                            _7285 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7661 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600) and mem[_7661] > -1 / _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                    if 0 > !(_7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7285 * mem[_7661]) + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600 * mem[_7661]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7721 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600) and mem[_7721] > -1 / _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7285 * mem[_7721]) + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600 * mem[_7721]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7722 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600) and mem[_7722] > -1 / _7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7285 + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7285 * mem[_7722]) + ((block.timestamp * _7165 * stor5.length) - (_7177 * _7165 * stor5.length) / 10000 / 24 * 3600 * mem[_7722]) / 10000):
                                            revert with 0, 17
                        else:
                            _7166 = mem[_4703 + ceil32(return_data.size) + 64]
                            _7178 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor5.length:
                                revert with 0, 17
                            _7286 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7666 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600) and mem[_7666] > -1 / _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                    if 0 > !(_7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7286 * mem[_7666]) + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600 * mem[_7666]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7724 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600) and mem[_7724] > -1 / _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7286 * mem[_7724]) + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600 * mem[_7724]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7725 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600) and mem[_7725] > -1 / _7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7286 + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7286 * mem[_7725]) + ((block.timestamp * _7166 * stor5.length) - (_7178 * _7166 * stor5.length) / 10000 / 24 * 3600 * mem[_7725]) / 10000):
                                            revert with 0, 17
                    else:
                        if mem[_4703 + ceil32(return_data.size) + 256] != 5:
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                _7184 = mem[_4703 + ceil32(return_data.size) + 160]
                                _7191 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor4.length:
                                    revert with 0, 17
                                _7369 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7731 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600) and mem[_7731] > -1 / _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7369 * mem[_7731]) + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600 * mem[_7731]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7809 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600) and mem[_7809] > -1 / _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7369 * mem[_7809]) + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600 * mem[_7809]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7810 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600) and mem[_7810] > -1 / _7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7369 + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7369 * mem[_7810]) + ((block.timestamp * _7184 * stor4.length) - (_7191 * _7184 * stor4.length) / 10000 / 24 * 3600 * mem[_7810]) / 10000):
                                                revert with 0, 17
                            else:
                                _7185 = mem[_4703 + ceil32(return_data.size) + 64]
                                _7192 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor4.length:
                                    revert with 0, 17
                                _7370 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7736 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600) and mem[_7736] > -1 / _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7370 * mem[_7736]) + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600 * mem[_7736]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7812 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600) and mem[_7812] > -1 / _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7370 * mem[_7812]) + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600 * mem[_7812]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7813 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600) and mem[_7813] > -1 / _7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7370 + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7370 * mem[_7813]) + ((block.timestamp * _7185 * stor4.length) - (_7192 * _7185 * stor4.length) / 10000 / 24 * 3600 * mem[_7813]) / 10000):
                                                revert with 0, 17
                        else:
                            mem[0] = _4696
                            mem[32] = 12
                            if sub_ded2abc3[_4696]:
                                mem[0] = _4696
                                mem[32] = 12
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7189 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7197 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7439 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7781 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7781] > -1 / _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7439 * mem[_7781]) + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7781]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7841 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7841] > -1 / _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7439 * mem[_7841]) + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7841]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7842 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7842] > -1 / _7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7439 + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7439 * mem[_7842]) + ((block.timestamp * _7189 * sub_ded2abc3[_4696]) - (_7197 * _7189 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7842]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7190 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7198 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7440 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7786 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7786] > -1 / _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7440 * mem[_7786]) + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7786]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7844 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7844] > -1 / _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7440 * mem[_7844]) + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7844]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7845 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7845] > -1 / _7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7440 + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7440 * mem[_7845]) + ((block.timestamp * _7190 * sub_ded2abc3[_4696]) - (_7198 * _7190 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7845]) / 10000):
                                                    revert with 0, 17
                            else:
                                mem[mem[64] + 4] = _4696
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args _4696
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7183 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _7199 = mem[_7183]
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7213 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7225 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and mem[_7183] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * mem[_7183] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * mem[_7183]:
                                        revert with 0, 17
                                    _7609 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7183]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7183]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7921 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600) and mem[_7921] > -1 / _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7609 * mem[_7921]) + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600 * mem[_7921]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7937 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600) and mem[_7937] > -1 / _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7609 * mem[_7937]) + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600 * mem[_7937]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7938 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600) and mem[_7938] > -1 / _7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7609 + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7609 * mem[_7938]) + ((block.timestamp * _7213 * _7199) - (_7225 * _7213 * _7199) / 10000 / 24 * 3600 * mem[_7938]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7214 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7226 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and mem[_7183] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * mem[_7183] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * mem[_7183]:
                                        revert with 0, 17
                                    _7610 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7183]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7183]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7926 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600) and mem[_7926] > -1 / _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7610 * mem[_7926]) + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600 * mem[_7926]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7940 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600) and mem[_7940] > -1 / _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7610 * mem[_7940]) + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600 * mem[_7940]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7941 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600) and mem[_7941] > -1 / _7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7610 + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7610 * mem[_7941]) + ((block.timestamp * _7214 * _7199) - (_7226 * _7214 * _7199) / 10000 / 24 * 3600 * mem[_7941]) / 10000):
                                                    revert with 0, 17
                else:
                    mem[_4713 + _4703 + ceil32(return_data.size) + 320] = 0
                    mem[_4703 + ceil32(return_data.size)] = _4703 + ceil32(return_data.size) + 288
                    mem[_4703 + ceil32(return_data.size) + 32] = mem[_4703 + _4705 + 32]
                    mem[_4703 + ceil32(return_data.size) + 64] = mem[_4703 + _4705 + 64]
                    mem[_4703 + ceil32(return_data.size) + 96] = mem[_4703 + _4705 + 96]
                    mem[_4703 + ceil32(return_data.size) + 128] = mem[_4703 + _4705 + 128]
                    mem[_4703 + ceil32(return_data.size) + 160] = mem[_4703 + _4705 + 160]
                    mem[_4703 + ceil32(return_data.size) + 192] = mem[_4703 + _4705 + 192]
                    require mem[_4703 + _4705 + 224] < 6
                    mem[_4703 + ceil32(return_data.size) + 224] = mem[_4703 + _4705 + 224]
                    require mem[_4703 + _4705 + 256] < 6
                    mem[_4703 + ceil32(return_data.size) + 256] = mem[_4703 + _4705 + 256]
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] == 4:
                        if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                            _7171 = mem[_4703 + ceil32(return_data.size) + 160]
                            _7180 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor5.length:
                                revert with 0, 17
                            _7287 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7675 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600) and mem[_7675] > -1 / _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                    if 0 > !(_7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7287 * mem[_7675]) + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600 * mem[_7675]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7737 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600) and mem[_7737] > -1 / _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7287 * mem[_7737]) + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600 * mem[_7737]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7738 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600) and mem[_7738] > -1 / _7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7287 + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7287 * mem[_7738]) + ((block.timestamp * _7171 * stor5.length) - (_7180 * _7171 * stor5.length) / 10000 / 24 * 3600 * mem[_7738]) / 10000):
                                            revert with 0, 17
                        else:
                            _7172 = mem[_4703 + ceil32(return_data.size) + 64]
                            _7181 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor5.length:
                                revert with 0, 17
                            _7288 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7680 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600) and mem[_7680] > -1 / _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                    if 0 > !(_7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7288 * mem[_7680]) + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600 * mem[_7680]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7740 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600) and mem[_7740] > -1 / _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7288 * mem[_7740]) + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600 * mem[_7740]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7741 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600) and mem[_7741] > -1 / _7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7288 + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7288 * mem[_7741]) + ((block.timestamp * _7172 * stor5.length) - (_7181 * _7172 * stor5.length) / 10000 / 24 * 3600 * mem[_7741]) / 10000):
                                            revert with 0, 17
                    else:
                        if mem[_4703 + ceil32(return_data.size) + 256] != 5:
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                _7187 = mem[_4703 + ceil32(return_data.size) + 160]
                                _7195 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor4.length:
                                    revert with 0, 17
                                _7371 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7747 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600) and mem[_7747] > -1 / _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7371 * mem[_7747]) + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600 * mem[_7747]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7819 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600) and mem[_7819] > -1 / _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7371 * mem[_7819]) + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600 * mem[_7819]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7820 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600) and mem[_7820] > -1 / _7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7371 + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7371 * mem[_7820]) + ((block.timestamp * _7187 * stor4.length) - (_7195 * _7187 * stor4.length) / 10000 / 24 * 3600 * mem[_7820]) / 10000):
                                                revert with 0, 17
                            else:
                                _7188 = mem[_4703 + ceil32(return_data.size) + 64]
                                _7196 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor4.length:
                                    revert with 0, 17
                                _7372 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7752 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600) and mem[_7752] > -1 / _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                        if 0 > !(_7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7372 * mem[_7752]) + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600 * mem[_7752]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7822 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600) and mem[_7822] > -1 / _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7372 * mem[_7822]) + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600 * mem[_7822]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7823 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600) and mem[_7823] > -1 / _7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7372 + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7372 * mem[_7823]) + ((block.timestamp * _7188 * stor4.length) - (_7196 * _7188 * stor4.length) / 10000 / 24 * 3600 * mem[_7823]) / 10000):
                                                revert with 0, 17
                        else:
                            mem[0] = _4696
                            mem[32] = 12
                            if sub_ded2abc3[_4696]:
                                mem[0] = _4696
                                mem[32] = 12
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7193 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7200 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7443 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7791 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7791] > -1 / _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7443 * mem[_7791]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7791]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7847 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7847] > -1 / _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7443 * mem[_7847]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7847]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7848 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7848] > -1 / _7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7443 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7443 * mem[_7848]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7200 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7848]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7194 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7201 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7444 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7796 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7796] > -1 / _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7444 * mem[_7796]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7796]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7850 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7850] > -1 / _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7444 * mem[_7850]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7850]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7851 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7851] > -1 / _7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7444 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7444 * mem[_7851]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7201 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7851]) / 10000):
                                                    revert with 0, 17
                            else:
                                mem[mem[64] + 4] = _4696
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args _4696
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7186 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _7202 = mem[_7186]
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7215 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7227 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and mem[_7186] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]:
                                        revert with 0, 17
                                    _7615 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600) and mem[_7931] > -1 / _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7615 * mem[_7931]) + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600 * mem[_7931]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7943 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600) and mem[_7943] > -1 / _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7615 * mem[_7943]) + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600 * mem[_7943]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7944 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600) and mem[_7944] > -1 / _7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7615 + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7615 * mem[_7944]) + ((block.timestamp * _7215 * _7202) - (_7227 * _7215 * _7202) / 10000 / 24 * 3600 * mem[_7944]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7216 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7228 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and mem[_7186] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]:
                                        revert with 0, 17
                                    _7616 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7936 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600) and mem[_7936] > -1 / _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                            if 0 > !(_7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7616 * mem[_7936]) + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600 * mem[_7936]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7946 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600) and mem[_7946] > -1 / _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7616 * mem[_7946]) + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600 * mem[_7946]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600) and mem[_7947] > -1 / _7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length >= block.timestamp:
                                                if 0 > !(_7616 + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7616 * mem[_7947]) + ((block.timestamp * _7216 * _7202) - (_7228 * _7216 * _7202) / 10000 / 24 * 3600 * mem[_7947]) / 10000):
                                                    revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    revert with 0, 'Nothing to compound'
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4)
#
const name = 'Test', 0

const symbol = 'Test', 0


address owner;
address sub_a5dc9e1bAddress;
address sub_6251be71Address;
address managerAddress;
mapping of uint256 balanceOf;
mapping of address ownerOf;
mapping of struct sub_594d129f;
array of struct stor7;
mapping of address approved;
mapping of uint8 stor9;
mapping of uint8 stor10;
address deadAddress;
address upgradeManagerAddress;
address helperAddress;
address sub_c84b39e2Address;
array of struct stor15;
uint256 sub_bd1be4e6;
uint256 sub_727a2335;
uint64 stor18;
uint256 stor18;
uint256 maxWallet;
uint8 transferIsEnabled;

function getApproved(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    return approved[arg1 << 192]
}

function transferIsEnabled() payable {
    return bool(transferIsEnabled)
}

function deadAddress() payable {
    return deadAddress
}

function manager() payable {
    return managerAddress
}

function sub_594d129f(?) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    return uint64(sub_594d129f[arg1].field_768)
}

function sub_6251be71(?) payable {
    return sub_6251be71Address
}

function ownerOf(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    return ownerOf[arg1 << 192]
}

function helper() payable {
    return helperAddress
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function sub_727a2335(?) payable {
    return sub_727a2335
}

function owner() payable {
    return owner
}

function sub_a5dc9e1b(?) payable {
    return sub_a5dc9e1bAddress
}

function sub_bd1be4e6(?) payable {
    return sub_bd1be4e6
}

function sub_c84b39e2(?) payable {
    return sub_c84b39e2Address
}

function upgradeManager() payable {
    return upgradeManagerAddress
}

function isApprovedForAll(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor9[address(arg1)][address(arg2)])
}

function maxWallet() payable {
    return maxWallet
}

function isBlacklisted(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor10[address(arg1)])
}

function _fallback() payable {
    revert
}

function totalNodesCreated() payable {
    if uint256(stor18) < 1:
        revert with 0, 17
    return (uint256(stor18) - 1)
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_e33417df(?) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_bd1be4e6 = arg1
}

function setManager(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    managerAddress = arg1
}

function enableTransfer(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    transferIsEnabled = uint8(arg1)
}

function sub_5ba4aa78(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_6251be71Address = address(arg1)
}

function sub_c69533eb(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    upgradeManagerAddress = address(arg1)
}

function _setBlacklist(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor10[address(arg1)] = uint8(arg2)
}

function setApprovalForAll(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor9[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function supportsInterface(bytes4 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1))
}

function sub_d915898b(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if deadAddress != address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Helper: Can only be set to Dead Address'
    sub_c84b39e2Address = address(arg1)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function transferContractOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit ContractOwnershipTransferred(sub_a5dc9e1bAddress, arg1);
    sub_a5dc9e1bAddress = arg1
}

function sub_d9f12a02(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor7[address(arg1)].field_0:
        mem[128] = stor7[address(arg1)].field_0
        idx = 128
        s = 0
        while (32 * stor7[address(arg1)].field_0) + 96 > idx:
            mem[idx + 32] = stor7[address(arg1)][s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        return Array(len=stor7[address(arg1)].field_0, data=mem[128 len 32 * stor7[address(arg1)].field_0])
    mem[(32 * stor7[address(arg1)].field_0) + 128] = 32
    mem[(32 * stor7[address(arg1)].field_0) + 160] = stor7[address(arg1)].field_0
    mem[(32 * stor7[address(arg1)].field_0) + 192 len 32 * stor7[address(arg1)].field_0] = mem[128 len 32 * stor7[address(arg1)].field_0]
    return memory
      from (32 * stor7[address(arg1)].field_0) + 128
       len (96 * stor7[address(arg1)].field_0) + 64
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if arg1 == ownerOf[arg2 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2 << 192] != msg.sender:
        if not stor9[stor5[arg2 << 192]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2 << 192] = arg1
    if not ownerOf[arg2 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    emit Approval(ownerOf[arg2 << 192], arg1, arg2);
}

function sub_371ffa64(?) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(stor15.length):
        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
            revert with 0, 34
        if arg1.length:
            stor15[].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor15.length = 0
            idx = 0
            while (uint255(stor15.length) * 0.5) + 31 / 32 > idx:
                stor15[idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
            revert with 0, 34
        if arg1.length:
            stor15[].field_0 = Array(len=arg1.length, data=arg1[all])
        else:
            stor15.length = 0
            idx = 0
            while stor15.length.field_1 % 128 + 31 / 32 > idx:
                stor15[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_37aad4ba(?) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_594d129f[arg1].field_256):
        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1][1][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1].field_256 = 0
            idx = 0
            while (uint255(sub_594d129f[arg1].field_256) * 0.5) + 31 / 32 > idx:
                sub_594d129f[arg1][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1][1][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1].field_256 = 0
            idx = 0
            while sub_594d129f[arg1].field_257 % 128 + 31 / 32 > idx:
                sub_594d129f[arg1][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_ab8b9f7c(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == uint64(arg1)
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if 0x726ca9a11821b08e8b39a0c12fff38e2a582b4c38cfe7da1888136bad2ac4c42 == sha3(arg2[all]):
        revert with 0, 'MANAGER: V1 NODE is reserved name'
    if not ownerOf[arg1 << 192]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if ownerOf[arg1 << 192] != msg.sender:
        revert with 0, 'MANAGER: You are not the owner'
    if bool(sub_594d129f[arg1 << 192].field_0):
        if bool(sub_594d129f[arg1 << 192].field_0) == uint255(sub_594d129f[arg1 << 192].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1 << 192][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1 << 192].field_0 = 0
            idx = 0
            while (uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 31 / 32 > idx:
                sub_594d129f[arg1 << 192][idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[arg1 << 192].field_0) == sub_594d129f[arg1 << 192].field_1 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1 << 192][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1 << 192].field_0 = 0
            idx = 0
            while sub_594d129f[arg1 << 192].field_1 % 128 + 31 / 32 > idx:
                sub_594d129f[arg1 << 192][idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_d6a00469(?) payable {
    require calldata.size - 4 >= 64
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + ('cd', 36).length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_594d129f[cd[4]].field_256):
        if bool(sub_594d129f[cd[4]].field_256) == uint255(sub_594d129f[cd[4]].field_256) * 0.5 < 32:
            revert with 0, 34
        if not ('cd', 36).length:
            sub_594d129f[cd[4]].field_256 = 0
            idx = 0
            while (uint255(sub_594d129f[cd[4]].field_256) * 0.5) + 31 / 32 > idx:
                sub_594d129f[cd[4]][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
        else:
            sub_594d129f[cd[4]].field_256 = (2 * ('cd', 36).length) + 1
            s = 0
            idx = cd[36] + 36
            while cd[36] + ('cd', 36).length + 36 > idx:
                sub_594d129f[cd[4]][s + 1].field_0 = cd[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, ('cd', 36).length + 31) >> 5
            while (uint255(sub_594d129f[cd[4]].field_256) * 0.5) + 31 / 32 > idx:
                sub_594d129f[cd[4]][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[cd[4]].field_256) == sub_594d129f[cd[4]].field_257 % 128 < 32:
            revert with 0, 34
        if not ('cd', 36).length:
            sub_594d129f[cd[4]].field_256 = 0
            idx = 0
            while sub_594d129f[cd[4]].field_257 % 128 + 31 / 32 > idx:
                sub_594d129f[cd[4]][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
        else:
            sub_594d129f[cd[4]].field_256 = (2 * ('cd', 36).length) + 1
            s = 0
            idx = cd[36] + 36
            while cd[36] + ('cd', 36).length + 36 > idx:
                sub_594d129f[cd[4]][s + 1].field_0 = cd[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, ('cd', 36).length + 31) >> 5
            while sub_594d129f[cd[4]].field_257 % 128 + 31 / 32 > idx:
                sub_594d129f[cd[4]][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if ownerOf[arg3 << 192] != msg.sender:
        if not ownerOf[arg3 << 192]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
        if approved[arg3 << 192] != msg.sender:
            if not stor9[stor5[arg3 << 192]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if bool(transferIsEnabled) != 1:
        if deadAddress != arg2:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'District Transfers are not allowed'
    if not ownerOf[arg3 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if ownerOf[arg3 << 192] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
    if stor10[address(arg2)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MANAGER: You can't transfer to blacklisted user'
    if stor10[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MANAGER: You can't transfer as blacklisted user'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if balanceOf[address(arg2)] > maxWallet:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MANAGER: You can't exceed max wallet'
    approved[arg3 << 192] = 0
    if not ownerOf[arg3 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    emit Approval(ownerOf[arg3 << 192], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3 << 192] = arg2
    stor7[address(arg2)].field_0++
    uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
    Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
    mem[0] = arg1
    idx = 0
    s = stor7[mem[0]].field_0
    while idx < stor7[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 7)
        if idx == -1:
            revert with 0, 17
        if stor7[address(arg1)][idx].field_0 != uint64(arg3):
            idx = idx + 1
            s = s
            continue 
        idx = idx + 1
        s = idx
        continue 
    if s < stor7[address(arg1)].field_0:
        if stor7[address(arg1)].field_0 < 1:
            revert with 0, 17
        if stor7[address(arg1)].field_0 - 1 >= stor7[address(arg1)].field_0:
            revert with 0, 50
        if s >= stor7[address(arg1)].field_0:
            revert with 0, 50
        stor7[address(arg1)][s].field_0 = stor7[address(arg1)][stor7[address(arg1)].field_0].field_0
        if not stor7[address(arg1)].field_0:
            revert with 0, 49
        stor7[address(arg1)][stor7[address(arg1)].field_0].field_0 = 0
        stor7[address(arg1)].field_0--
    emit Transfer(arg1, arg2, arg3);
}

function sub_893b0eec(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size > cd[4] + 35
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    s = 128
    idx = cd[4] + 36
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        s = s + 32
        idx = idx + 32
        continue 
    if sub_c84b39e2Address != msg.sender:
        revert with 0, 'Helper: Only airdrop handler can call this.'
    idx = 0
    while idx < ('cd', 4).length:
        if 1 > !idx:
            revert with 0, 17
        if idx >= ('cd', 4).length:
            revert with 0, 50
        if not ownerOf[idx + 1 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if ownerOf[idx + 1 << 192] != msg.sender:
            revert with 0, 'ERC721: transfer from incorrect owner'
        if stor10[address(mem[(32 * idx) + 128])]:
            revert with 0, 'MANAGER: You can't transfer to blacklisted user'
        if stor10[address(msg.sender)]:
            revert with 0, 'MANAGER: You can't transfer as blacklisted user'
        if not mem[(32 * idx) + 140 len 20]:
            revert with 0, 'ERC721: balance query for the zero address'
        if balanceOf[address(mem[(32 * idx) + 128])] > maxWallet:
            revert with 0, 'MANAGER: You can't exceed max wallet'
        approved[idx + 1 << 192] = 0
        if not ownerOf[idx + 1 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        emit Approval(ownerOf[idx + 1 << 192], 0, idx + 1);
        if balanceOf[address(msg.sender)] < 1:
            revert with 0, 17
        balanceOf[address(msg.sender)]--
        if balanceOf[address(mem[(32 * idx) + 128])] > -2:
            revert with 0, 17
        balanceOf[address(mem[(32 * idx) + 128])]++
        ownerOf[idx + 1 << 192] = mem[(32 * idx) + 140 len 20]
        stor7[address(mem[(32 * idx) + 128])].field_0++
        uint64(stor7[address(mem[(32 * idx) + 128])][stor7[address(mem[(32 * idx) + 128])].field_0].field_0) = uint64(idx + 1)
        Mask(192, 0, stor7[address(mem[(32 * idx) + 128])][stor7[address(mem[(32 * idx) + 128])].field_0].field_64) = 0
        mem[0] = msg.sender
        mem[32] = 7
        s = 0
        t = stor7[mem[0]].field_0
        while s < stor7[address(msg.sender)].field_0:
            mem[0] = sha3(address(msg.sender), 7)
            if s == -1:
                revert with 0, 17
            if stor7[address(msg.sender)][s].field_0 != uint64(idx + 1):
                s = s + 1
                t = t
                continue 
            s = s + 1
            t = s
            continue 
        if t < stor7[address(msg.sender)].field_0:
            if stor7[address(msg.sender)].field_0 < 1:
                revert with 0, 17
            if stor7[address(msg.sender)].field_0 - 1 >= stor7[address(msg.sender)].field_0:
                revert with 0, 50
            if t >= stor7[address(msg.sender)].field_0:
                revert with 0, 50
            stor7[address(msg.sender)][t].field_0 = stor7[address(msg.sender)][stor7[address(msg.sender)].field_0].field_0
            if not stor7[address(msg.sender)].field_0:
                revert with 0, 49
            mem[0] = sha3(address(msg.sender), 7)
            stor7[address(msg.sender)][stor7[address(msg.sender)].field_0].field_0 = 0
            stor7[address(msg.sender)].field_0--
        emit Transfer(msg.sender, mem[(32 * idx) + 140 len 20], idx + 1);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_d2d99fec(?) payable {
    if bool(stor15.length):
        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor15.length):
            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor15.length):
                if 31 < uint255(stor15.length) * 0.5:
                    mem[128] = uint256(stor15.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor15.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor15[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[128 len ceil32(uint255(stor15.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor15.length.field_8)
        else:
            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor15.length.field_1 % 128:
                if 31 < stor15.length.field_1 % 128:
                    mem[128] = uint256(stor15.field_0)
                    idx = 128
                    s = 0
                    while stor15.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor15[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[128 len ceil32(uint255(stor15.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor15.length.field_8)
        mem[ceil32(uint255(stor15.length) * 0.5) + 192 len ceil32(uint255(stor15.length) * 0.5)] = mem[128 len ceil32(uint255(stor15.length) * 0.5)]
        if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
            mem[ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[128 len ceil32(uint255(stor15.length) * 0.5)], mem[(2 * ceil32(uint255(stor15.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor15.length):
        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor15.length):
            if 31 < uint255(stor15.length) * 0.5:
                mem[128] = uint256(stor15.field_0)
                idx = 128
                s = 0
                while (uint255(stor15.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor15[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor15.length % 128, data=mem[128 len ceil32(stor15.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor15.length.field_8)
    else:
        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor15.length.field_1 % 128:
            if 31 < stor15.length.field_1 % 128:
                mem[128] = uint256(stor15.field_0)
                idx = 128
                s = 0
                while stor15.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor15[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor15.length % 128, data=mem[128 len ceil32(stor15.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor15.length.field_8)
    mem[ceil32(stor15.length.field_1 % 128) + 192 len ceil32(stor15.length.field_1 % 128)] = mem[128 len ceil32(stor15.length.field_1 % 128)]
    if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
        mem[ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 192] = 0
    return Array(len=stor15.length % 128, data=mem[128 len ceil32(stor15.length.field_1 % 128)], mem[(2 * ceil32(stor15.length.field_1 % 128)) + 192 len 2 * ceil32(stor15.length.field_1 % 128)]), 
}

function sub_d003adca(?) payable {
    require calldata.size - 4 >= 192
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require arg2 + arg2.length + 36 <= calldata.size
    require arg3 == uint64(arg3)
    require arg4 == uint64(arg4)
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    require arg5.length <= test266151307()
    require arg5 + arg5.length + 36 <= calldata.size
    require arg6 == address(arg6)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(arg2.length) + 128] = arg5.length
    mem[ceil32(arg2.length) + 160 len arg5.length] = arg5[all]
    mem[ceil32(arg2.length) + arg5.length + 160] = 0
    if ownerOf[arg1 << 192]:
        revert with 0, 'MANAGER: District already exist'
    mem[ceil32(arg2.length) + ceil32(arg5.length) + 160] = 96
    mem[ceil32(arg2.length) + ceil32(arg5.length) + 192] = ceil32(arg2.length) + 128
    mem[ceil32(arg2.length) + ceil32(arg5.length) + 224] = arg1
    mem[ceil32(arg2.length) + ceil32(arg5.length) + 256] = uint64(arg3)
    mem[ceil32(arg2.length) + ceil32(arg5.length) + 288] = uint64(arg4)
    if bool(sub_594d129f[arg1].field_0):
        if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1].field_0 = 0
            idx = 0
            while (uint255(sub_594d129f[arg1].field_0) * 0.5) + 31 / 32 > idx:
                sub_594d129f[arg1][idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            sub_594d129f[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_594d129f[arg1].field_0 = 0
            idx = 0
            while sub_594d129f[arg1].field_1 % 128 + 31 / 32 > idx:
                sub_594d129f[arg1][idx].field_0 = 0
                idx = idx + 1
                continue 
    if bool(sub_594d129f[arg1].field_256):
        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
            revert with 0, 34
        if Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]:
            sub_594d129f[arg1][1][].field_0 = Array(len=Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)], data=mem[ceil32(arg2.length) + 160 len Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]])
        else:
            sub_594d129f[arg1].field_256 = 0
            idx = 0
            while (uint255(sub_594d129f[arg1].field_256) * 0.5) + 31 / 32 > idx:
                sub_594d129f[arg1][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
            revert with 0, 34
        if Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]:
            sub_594d129f[arg1][1][].field_0 = Array(len=Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)], data=mem[ceil32(arg2.length) + 160 len Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]])
        else:
            sub_594d129f[arg1].field_256 = 0
            idx = 0
            while sub_594d129f[arg1].field_257 % 128 + 31 / 32 > idx:
                sub_594d129f[arg1][idx + 1].field_0 = 0
                idx = idx + 1
                continue 
    sub_594d129f[arg1].field_512 = arg1
    uint64(sub_594d129f[arg1].field_768) = uint64(arg3)
    uint64(sub_594d129f[arg1].field_832) = uint64(arg4)
    ownerOf[arg1] = address(arg6)
    if balanceOf[address(arg6)] > -2:
        revert with 0, 17
    balanceOf[address(arg6)]++
    stor7[address(arg6)].field_0++
    stor7[address(arg6)][stor7[address(arg6)].field_0].field_0 = arg1
    emit Transfer(0, address(arg6), arg1);
}

function getNameOf(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1 << 192]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if bool(sub_594d129f[arg1].field_0):
        if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1].field_0):
            if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, sub_594d129f[arg1].field_0):
                if 31 < uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[128] = sub_594d129f[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_594d129f[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1].field_0), data=mem[128 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
        else:
            if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if sub_594d129f[arg1].field_1 % 128:
                if 31 < sub_594d129f[arg1].field_1 % 128:
                    mem[128] = sub_594d129f[arg1].field_0
                    idx = 128
                    s = 0
                    while sub_594d129f[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1].field_0), data=mem[128 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)] = mem[128 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)]
        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1].field_0), data=mem[128 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)], mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)]), 
    if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(sub_594d129f[arg1].field_0):
        if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, sub_594d129f[arg1].field_0):
            if 31 < uint255(sub_594d129f[arg1].field_0) * 0.5:
                mem[128] = sub_594d129f[arg1].field_0
                idx = 128
                s = 0
                while (uint255(sub_594d129f[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=sub_594d129f[arg1].field_0 % 128, data=mem[128 len ceil32(sub_594d129f[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
    else:
        if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if sub_594d129f[arg1].field_1 % 128:
            if 31 < sub_594d129f[arg1].field_1 % 128:
                mem[128] = sub_594d129f[arg1].field_0
                idx = 128
                s = 0
                while sub_594d129f[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=sub_594d129f[arg1].field_0 % 128, data=mem[128 len ceil32(sub_594d129f[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 192 len ceil32(sub_594d129f[arg1].field_1 % 128)] = mem[128 len ceil32(sub_594d129f[arg1].field_1 % 128)]
    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_1 % 128 + 192] = 0
    return Array(len=sub_594d129f[arg1].field_0 % 128, data=mem[128 len ceil32(sub_594d129f[arg1].field_1 % 128)], mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + 192 len 2 * ceil32(sub_594d129f[arg1].field_1 % 128)]), 
}

function sub_f2d805c1(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] <= test266151307()
        require cd[4] + cd[idx] + 67 < calldata.size
        if cd[(cd[4] + cd[idx] + 36)] > test266151307():
            revert with 0, 65
        _613 = mem[64]
        if mem[64] + ceil32(ceil32(cd[(cd[4] + cd[idx] + 36)])) + 1 < mem[64] or mem[64] + ceil32(ceil32(cd[(cd[4] + cd[idx] + 36)])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(ceil32(cd[(cd[4] + cd[idx] + 36)])) + 1
        mem[_613] = cd[(cd[4] + cd[idx] + 36)]
        require cd[4] + cd[idx] + cd[(cd[4] + cd[idx] + 36)] + 68 <= calldata.size
        mem[_613 + 32 len cd[(cd[4] + cd[idx] + 36)]] = call.data[cd[4] + cd[idx] + 68 len cd[(cd[4] + cd[idx] + 36)]]
        mem[_613 + cd[(cd[4] + cd[idx] + 36)] + 32] = 0
        mem[s] = _613
        idx = idx + 32
        s = s + 32
        continue 
    if sub_c84b39e2Address != msg.sender:
        revert with 0, 'Helper: Only airdrop handler can call this.'
    idx = 0
    while idx < cd[36]:
        if idx >= mem[96]:
            revert with 0, 50
        _1215 = mem[(32 * idx) + 128]
        if mem[mem[(32 * idx) + 128]] <= 0:
            revert with 0, 'HELPER: name size is invalid'
        if mem[mem[(32 * idx) + 128]] >= 33:
            revert with 0, 'HELPER: name size is invalid'
        _1221 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1221] = 7
        mem[_1221 + 32] = 'V1 NODE'
        if 0x726ca9a11821b08e8b39a0c12fff38e2a582b4c38cfe7da1888136bad2ac4c42 == sha3(mem[_1215 + 32 len mem[_1215]]):
            revert with 0, 'MANAGER: V1 NODE is reserved name'
        _1225 = mem[64]
        mem[64] = mem[64] + 32
        mem[_1225] = 0
        mem[0] = uint64(stor18)
        mem[32] = 5
        if ownerOf[uint64(stor18)]:
            revert with 0, 'MANAGER: District already exist'
        _1229 = mem[64]
        mem[64] = mem[64] + 160
        mem[_1229] = _1215
        mem[_1229 + 32] = _1225
        mem[_1229 + 64] = uint256(stor18)
        mem[_1229 + 96] = uint64(block.timestamp)
        mem[_1229 + 128] = uint64(block.timestamp)
        mem[0] = uint256(stor18)
        mem[32] = 6
        _1232 = mem[_1215]
        if bool(sub_594d129f[uint256(stor18)].field_0):
            if bool(sub_594d129f[uint256(stor18)].field_0) == uint255(sub_594d129f[uint256(stor18)].field_0) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(uint256(stor18), 6)
            if not _1232:
                sub_594d129f[uint256(stor18)].field_0 = 0
                s = sha3(sha3(uint256(stor18), 6))
                while sha3(sha3(uint256(stor18), 6)) + ((uint255(sub_594d129f[uint256(stor18)].field_0) * 0.5) + 31 / 32) > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
            else:
                sub_594d129f[uint256(stor18)].field_0 = (2 * _1232) + 1
                t = sha3(sha3(uint256(stor18), 6))
                s = _1215 + 32
                while _1215 + _1232 + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(uint256(stor18), 6)) + (Mask(251, 0, _1232 + 31) >> 5)
                while sha3(sha3(uint256(stor18), 6)) + ((uint255(sub_594d129f[uint256(stor18)].field_0) * 0.5) + 31 / 32) > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
        else:
            if bool(sub_594d129f[uint256(stor18)].field_0) == sub_594d129f[uint256(stor18)].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(uint256(stor18), 6)
            if not _1232:
                sub_594d129f[uint256(stor18)].field_0 = 0
                s = sha3(sha3(uint256(stor18), 6))
                while sha3(sha3(uint256(stor18), 6)) + (sub_594d129f[uint256(stor18)].field_1 % 128 + 31 / 32) > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
            else:
                sub_594d129f[uint256(stor18)].field_0 = (2 * _1232) + 1
                t = sha3(sha3(uint256(stor18), 6))
                s = _1215 + 32
                while _1215 + _1232 + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(uint256(stor18), 6)) + (Mask(251, 0, _1232 + 31) >> 5)
                while sha3(sha3(uint256(stor18), 6)) + (sub_594d129f[uint256(stor18)].field_1 % 128 + 31 / 32) > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
        if bool(sub_594d129f[uint256(stor18)].field_256):
            if bool(sub_594d129f[uint256(stor18)].field_256) == uint255(sub_594d129f[uint256(stor18)].field_256) * 0.5 < 32:
                revert with 0, 34
            sub_594d129f[uint256(stor18)].field_256 = 0
            s = sha3(sha3(uint256(stor18), 6) + 1)
            while sha3(sha3(uint256(stor18), 6) + 1) + ((uint255(sub_594d129f[uint256(stor18)].field_256) * 0.5) + 31 / 32) > s:
                stor[s] = 0
                s = s + 1
                continue 
        else:
            if bool(sub_594d129f[uint256(stor18)].field_256) == sub_594d129f[uint256(stor18)].field_257 % 128 < 32:
                revert with 0, 34
            sub_594d129f[uint256(stor18)].field_256 = 0
            s = sha3(sha3(uint256(stor18), 6) + 1)
            while sha3(sha3(uint256(stor18), 6) + 1) + (sub_594d129f[uint256(stor18)].field_257 % 128 + 31 / 32) > s:
                stor[s] = 0
                s = s + 1
                continue 
        sub_594d129f[uint256(stor18)].field_512 = uint256(stor18)
        uint64(sub_594d129f[uint256(stor18)].field_768) = uint64(block.timestamp)
        uint64(sub_594d129f[uint256(stor18)].field_832) = uint64(block.timestamp)
        ownerOf[uint256(stor18)] = msg.sender
        if balanceOf[address(msg.sender)] > -2:
            revert with 0, 17
        balanceOf[address(msg.sender)]++
        mem[32] = 7
        stor7[address(msg.sender)].field_0++
        mem[0] = sha3(address(msg.sender), 7)
        stor7[address(msg.sender)][stor7[address(msg.sender)].field_0].field_0 = uint256(stor18)
        emit Transfer(0, msg.sender, uint256(stor18));
        if uint256(stor18) > -2:
            revert with 0, 17
        uint256(stor18)++
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_5b827055(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(('cd', 4).length)) + 97 < 96 or ceil32(ceil32(('cd', 4).length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + ('cd', 4).length + 36 <= calldata.size
    mem[128 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
    mem[('cd', 4).length + 128] = 0
    require cd[36] <= test266151307()
    require calldata.size > cd[36] + 35
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(('cd', 4).length)) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    s = ceil32(ceil32(('cd', 4).length)) + 129
    idx = cd[36] + 36
    while idx < cd[36] + (32 * ('cd', 36).length) + 36:
        require cd[idx] == uint64(cd[idx])
        mem[s] = cd[idx]
        s = s + 32
        idx = idx + 32
        continue 
    if ('cd', 4).length <= 0:
        revert with 0, 'HELPER: name size is invalid'
    if ('cd', 4).length >= 33:
        revert with 0, 'HELPER: name size is invalid'
    if not msg.sender:
        revert with 0, 'HELPER:  Creation from the zero address'
    if sub_bd1be4e6 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
        revert with 0, 17
    if 10^18 * sub_bd1be4e6 <= 0:
        revert with 0, 'error'
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + 102] = msg.sender
    staticcall sub_6251be71Address.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + 98] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < 10^18 * sub_bd1be4e6:
        revert with 0, 'HELPER: Playmate balance too low for creation.'
    if not msg.sender:
        revert with 0, 'ERC721: balance query for the zero address'
    if 1 > !balanceOf[address(msg.sender)]:
        revert with 0, 17
    if balanceOf[address(msg.sender)] + 1 >= maxWallet:
        revert with 0, 'HELPER: Exceeds max wallet amount'
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 102] = msg.sender
    staticcall managerAddress.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < sub_727a2335:
        revert with 0, 'HELPER: Mansion balance too low for creation.'
    idx = 0
    while idx < sub_727a2335:
        if idx >= mem[ceil32(ceil32(('cd', 4).length)) + 97]:
            revert with 0, 50
        _1267 = mem[(32 * idx) + ceil32(ceil32(('cd', 4).length)) + 129]
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 98] = 0xb88d4fde00000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 102] = msg.sender
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 134] = 0
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 166] = uint64(_1267)
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 198] = 128
        mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 230] = 0
        require ext_code.size(managerAddress)
        call managerAddress.0xb88d4fde with:
             gas gas_remaining wei
            args msg.sender, 0, _1267 << 192, 128, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 102] = msg.sender
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 134] = helperAddress
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 166] = 10^18 * sub_bd1be4e6
    call sub_6251be71Address.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, helperAddress, 10^18 * sub_bd1be4e6
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 98] = 7
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 130] = 'V1 NODE'
    if 0x726ca9a11821b08e8b39a0c12fff38e2a582b4c38cfe7da1888136bad2ac4c42 == sha3(mem[128 len mem[96]]):
        revert with 0, 'MANAGER: V1 NODE is reserved name'
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 162] = 0
    if ownerOf[uint64(stor18)]:
        revert with 0, 'MANAGER: District already exist'
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 194] = 96
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 226] = ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 162
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 258] = uint256(stor18)
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 290] = uint64(block.timestamp)
    mem[ceil32(ceil32(('cd', 4).length)) + ceil32(32 * ('cd', 36).length) + (4 * ceil32(return_data.size)) + 322] = uint64(block.timestamp)
    if bool(sub_594d129f[uint256(stor18)].field_0):
        if bool(sub_594d129f[uint256(stor18)].field_0) == uint255(sub_594d129f[uint256(stor18)].field_0) * 0.5 < 32:
            revert with 0, 34
        if mem[96]:
            sub_594d129f[uint256(stor18)][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])
        else:
            sub_594d129f[uint256(stor18)].field_0 = 0
            idx = 0
            while (uint255(sub_594d129f[uint256(stor18)].field_0) * 0.5) + 31 / 32 > idx:
                sub_594d129f[uint256(stor18)][idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_594d129f[uint256(stor18)].field_0) == sub_594d129f[uint256(stor18)].field_1 % 128 < 32:
            revert with 0, 34
        if mem[96]:
            sub_594d129f[uint256(stor18)][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])
        else:
            sub_594d129f[uint256(stor18)].field_0 = 0
            idx = 0
            while sub_594d129f[uint256(stor18)].field_1 % 128 + 31 / 32 > idx:
                sub_594d129f[uint256(stor18)][idx].field_0 = 0
                idx = idx + 1
                continue 
    if bool(sub_594d129f[uint256(stor18)].field_256):
        if bool(sub_594d129f[uint256(stor18)].field_256) == uint255(sub_594d129f[uint256(stor18)].field_256) * 0.5 < 32:
            revert with 0, 34
        sub_594d129f[uint256(stor18)].field_256 = 0
        idx = 0
        while (uint255(sub_594d129f[uint256(stor18)].field_256) * 0.5) + 31 / 32 > idx:
            sub_594d129f[uint256(stor18)][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    else:
        if bool(sub_594d129f[uint256(stor18)].field_256) == sub_594d129f[uint256(stor18)].field_257 % 128 < 32:
            revert with 0, 34
        sub_594d129f[uint256(stor18)].field_256 = 0
        idx = 0
        while sub_594d129f[uint256(stor18)].field_257 % 128 + 31 / 32 > idx:
            sub_594d129f[uint256(stor18)][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    sub_594d129f[uint256(stor18)].field_512 = uint256(stor18)
    uint64(sub_594d129f[uint256(stor18)].field_768) = uint64(block.timestamp)
    uint64(sub_594d129f[uint256(stor18)].field_832) = uint64(block.timestamp)
    ownerOf[uint256(stor18)] = msg.sender
    if balanceOf[address(msg.sender)] > -2:
        revert with 0, 17
    balanceOf[address(msg.sender)]++
    stor7[address(msg.sender)].field_0++
    stor7[address(msg.sender)][stor7[address(msg.sender)].field_0].field_0 = uint256(stor18)
    emit Transfer(0, msg.sender, uint256(stor18));
    if uint256(stor18) > -2:
        revert with 0, 17
    uint256(stor18)++
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if bool(transferIsEnabled) != 1:
        if deadAddress != arg2:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'District Transfers are not allowed'
    if not ownerOf[arg3 << 192]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3 << 192]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if ownerOf[arg3 << 192] != msg.sender:
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if approved[arg3 << 192] != msg.sender:
            if not stor9[stor5[arg3 << 192]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if 1 == bool(transferIsEnabled):
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if ownerOf[arg3 << 192] != arg1:
            revert with 0, 'ERC721: transfer from incorrect owner'
        if stor10[address(arg2)]:
            revert with 0, 'MANAGER: You can't transfer to blacklisted user'
        if stor10[address(arg1)]:
            revert with 0, 'MANAGER: You can't transfer as blacklisted user'
        if not arg2:
            revert with 0, 'ERC721: balance query for the zero address'
        if balanceOf[address(arg2)] > maxWallet:
            revert with 0, 'MANAGER: You can't exceed max wallet'
        approved[arg3 << 192] = 0
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        emit Approval(ownerOf[arg3 << 192], 0, arg3);
        if balanceOf[address(arg1)] < 1:
            revert with 0, 17
        balanceOf[address(arg1)]--
        if balanceOf[address(arg2)] > -2:
            revert with 0, 17
        balanceOf[address(arg2)]++
        ownerOf[arg3 << 192] = arg2
        stor7[address(arg2)].field_0++
        uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
        Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
        mem[0] = arg1
        idx = 0
        s = stor7[mem[0]].field_0
        while idx < stor7[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 7)
            if idx == -1:
                revert with 0, 17
            if stor7[address(arg1)][idx].field_0 != uint64(arg3):
                idx = idx + 1
                s = s
                continue 
            idx = idx + 1
            s = idx
            continue 
        if s < stor7[address(arg1)].field_0:
            if stor7[address(arg1)].field_0 < 1:
                revert with 0, 17
            if stor7[address(arg1)].field_0 - 1 >= stor7[address(arg1)].field_0:
                revert with 0, 50
            if s >= stor7[address(arg1)].field_0:
                revert with 0, 50
            stor7[address(arg1)][s].field_0 = stor7[address(arg1)][stor7[address(arg1)].field_0].field_0
            if not stor7[address(arg1)].field_0:
                revert with 0, 49
            stor7[address(arg1)][stor7[address(arg1)].field_0].field_0 = 0
            stor7[address(arg1)].field_0--
        emit Transfer(arg1, arg2, arg3);
        if ext_code.size(arg2):
            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
            if not ext_call.success:
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if ownerOf[arg3 << 192] != arg1:
            revert with 0, 'ERC721: transfer from incorrect owner'
        if stor10[address(arg2)]:
            revert with 0, 'MANAGER: You can't transfer to blacklisted user'
        if stor10[address(arg1)]:
            revert with 0, 'MANAGER: You can't transfer as blacklisted user'
        if not arg2:
            revert with 0, 'ERC721: balance query for the zero address'
        if balanceOf[address(arg2)] > maxWallet:
            revert with 0, 'MANAGER: You can't exceed max wallet'
        approved[arg3 << 192] = 0
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        emit Approval(ownerOf[arg3 << 192], 0, arg3);
        if balanceOf[address(arg1)] < 1:
            revert with 0, 17
        balanceOf[address(arg1)]--
        if balanceOf[address(arg2)] > -2:
            revert with 0, 17
        balanceOf[address(arg2)]++
        ownerOf[arg3 << 192] = arg2
        stor7[address(arg2)].field_0++
        uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
        Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
        mem[0] = arg1
        idx = 0
        s = stor7[mem[0]].field_0
        while idx < stor7[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 7)
            if idx == -1:
                revert with 0, 17
            if stor7[address(arg1)][idx].field_0 != uint64(arg3):
                idx = idx + 1
                s = s
                continue 
            idx = idx + 1
            s = idx
            continue 
    else:
        if upgradeManagerAddress != msg.sender:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        if 1 == bool(transferIsEnabled):
            if not ownerOf[arg3 << 192]:
                revert with 0, 'ERC721: operator query for nonexistent token'
            if ownerOf[arg3 << 192] != arg1:
                revert with 0, 'ERC721: transfer from incorrect owner'
            if stor10[address(arg2)]:
                revert with 0, 'MANAGER: You can't transfer to blacklisted user'
            if stor10[address(arg1)]:
                revert with 0, 'MANAGER: You can't transfer as blacklisted user'
            if not arg2:
                revert with 0, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg2)] > maxWallet:
                revert with 0, 'MANAGER: You can't exceed max wallet'
            approved[arg3 << 192] = 0
            if not ownerOf[arg3 << 192]:
                revert with 0, 'ERC721: operator query for nonexistent token'
            emit Approval(ownerOf[arg3 << 192], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3 << 192] = arg2
            stor7[address(arg2)].field_0++
            uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
            Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
            mem[0] = arg1
            idx = 0
            s = stor7[mem[0]].field_0
            while idx < stor7[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 7)
                if idx == -1:
                    revert with 0, 17
                if stor7[address(arg1)][idx].field_0 != uint64(arg3):
                    idx = idx + 1
                    s = s
                    continue 
                idx = idx + 1
                s = idx
                continue 
        else:
            if upgradeManagerAddress != msg.sender:
                revert with 0, 'District Transfers are not allowed'
            if not ownerOf[arg3 << 192]:
                revert with 0, 'ERC721: operator query for nonexistent token'
            if ownerOf[arg3 << 192] != arg1:
                revert with 0, 'ERC721: transfer from incorrect owner'
            if stor10[address(arg2)]:
                revert with 0, 'MANAGER: You can't transfer to blacklisted user'
            if stor10[address(arg1)]:
                revert with 0, 'MANAGER: You can't transfer as blacklisted user'
            if not arg2:
                revert with 0, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg2)] > maxWallet:
                revert with 0, 'MANAGER: You can't exceed max wallet'
            approved[arg3 << 192] = 0
            if not ownerOf[arg3 << 192]:
                revert with 0, 'ERC721: operator query for nonexistent token'
            emit Approval(ownerOf[arg3 << 192], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3 << 192] = arg2
            stor7[address(arg2)].field_0++
            uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
            Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
            mem[0] = arg1
            idx = 0
            s = stor7[mem[0]].field_0
            while idx < stor7[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 7)
                if idx == -1:
                    revert with 0, 17
                if stor7[address(arg1)][idx].field_0 != uint64(arg3):
                    idx = idx + 1
                    s = s
                    continue 
                idx = idx + 1
                s = idx
                continue 
        if s < stor7[address(arg1)].field_0:
            if stor7[address(arg1)].field_0 < 1:
                revert with 0, 17
            if stor7[address(arg1)].field_0 - 1 >= stor7[address(arg1)].field_0:
                revert with 0, 50
            if s >= stor7[address(arg1)].field_0:
                revert with 0, 50
            stor7[address(arg1)][s].field_0 = stor7[address(arg1)][stor7[address(arg1)].field_0].field_0
            if not stor7[address(arg1)].field_0:
                revert with 0, 49
            stor7[address(arg1)][stor7[address(arg1)].field_0].field_0 = 0
            stor7[address(arg1)].field_0--
        emit Transfer(arg1, arg2, arg3);
        if ext_code.size(arg2):
            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
            if not ext_call.success:
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                if not return_data.size:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        if ownerOf[arg3 << 192] != arg1:
            revert with 0, 'ERC721: transfer from incorrect owner'
        if stor10[address(arg2)]:
            revert with 0, 'MANAGER: You can't transfer to blacklisted user'
        if stor10[address(arg1)]:
            revert with 0, 'MANAGER: You can't transfer as blacklisted user'
        if not arg2:
            revert with 0, 'ERC721: balance query for the zero address'
        if balanceOf[address(arg2)] > maxWallet:
            revert with 0, 'MANAGER: You can't exceed max wallet'
        approved[arg3 << 192] = 0
        if not ownerOf[arg3 << 192]:
            revert with 0, 'ERC721: operator query for nonexistent token'
        emit Approval(ownerOf[arg3 << 192], 0, arg3);
        if balanceOf[address(arg1)] < 1:
            revert with 0, 17
        balanceOf[address(arg1)]--
        if balanceOf[address(arg2)] > -2:
            revert with 0, 17
        balanceOf[address(arg2)]++
        ownerOf[arg3 << 192] = arg2
        stor7[address(arg2)].field_0++
        uint64(stor7[address(arg2)][stor7[address(arg2)].field_0].field_0) = uint64(arg3)
        Mask(192, 0, stor7[address(arg2)][stor7[address(arg2)].field_0].field_64) = 0
        mem[0] = arg1
        idx = 0
        s = stor7[mem[0]].field_0
        while idx < stor7[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 7)
            if idx == -1:
                revert with 0, 17
            if stor7[address(arg1)][idx].field_0 != uint64(arg3):
                idx = idx + 1
                s = s
                continue 
            idx = idx + 1
            s = idx
            continue 
    if s < stor7[address(arg1)].field_0:
        if stor7[address(arg1)].field_0 < 1:
            revert with 0, 17
        if stor7[address(arg1)].field_0 - 1 >= stor7[address(arg1)].field_0:
            revert with 0, 50
        if s >= stor7[address(arg1)].field_0:
            revert with 0, 50
        stor7[address(arg1)][s].field_0 = stor7[address(arg1)][stor7[address(arg1)].field_0].field_0
        if not stor7[address(arg1)].field_0:
            revert with 0, 49
        stor7[address(arg1)][stor7[address(arg1)].field_0].field_0 = 0
        stor7[address(arg1)].field_0--
    emit Transfer(arg1, arg2, arg3);
}

function sub_d42819a0(?) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1 << 192]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if bool(sub_594d129f[arg1].field_0):
        if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1].field_0):
            if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1].field_0):
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1].field_256):
                        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_594d129f[arg1].field_256):
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                            revert with 0, 34
                        if not sub_594d129f[arg1].field_257 % 128:
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= sub_594d129f[arg1].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if 31 >= uint255(sub_594d129f[arg1].field_0) * 0.5:
                mem[448] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1].field_256):
                        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_594d129f[arg1].field_256):
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                            revert with 0, 34
                        if not sub_594d129f[arg1].field_257 % 128:
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= sub_594d129f[arg1].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            mem[448] = sub_594d129f[arg1].field_0
            idx = 448
            s = 0
            while (uint255(sub_594d129f[arg1].field_0) * 0.5) + 416 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1].field_1 % 128:
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1].field_256):
                        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_594d129f[arg1].field_256):
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                            revert with 0, 34
                        if not sub_594d129f[arg1].field_257 % 128:
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= sub_594d129f[arg1].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if 31 >= sub_594d129f[arg1].field_1 % 128:
                mem[448] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1].field_256):
                        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_594d129f[arg1].field_256):
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                            revert with 0, 34
                        if not sub_594d129f[arg1].field_257 % 128:
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if 31 >= sub_594d129f[arg1].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                            return 32, 160, 
                                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                                   sub_594d129f[arg1].field_512,
                                   uint64(sub_594d129f[arg1].field_768),
                                   uint64(sub_594d129f[arg1].field_768),
                                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                                   uint255(sub_594d129f[arg1].field_256) * 0.5,
                                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                        return 32, 160, 
                               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                               mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                               sub_594d129f[arg1].field_257 % 128,
                               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            mem[448] = sub_594d129f[arg1].field_0
            idx = 448
            s = 0
            while sub_594d129f[arg1].field_1 % 128 + 416 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if bool(sub_594d129f[arg1].field_256):
            if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1].field_256):
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                s = 0
                while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1].field_257 % 128:
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if 31 >= sub_594d129f[arg1].field_257 % 128:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                    return 32, 160, 
                           ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                           mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                           2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                           mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
                s = 0
                while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) <= uint255(sub_594d129f[arg1].field_0) * 0.5:
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
            return 32, 160, 
                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                   mem[448 len uint255(sub_594d129f[arg1].field_0) * 0.5],
                   0,
                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) - (uint255(sub_594d129f[arg1].field_0) * 0.5)]
        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1].field_256):
            if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1].field_256):
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
            idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
            s = 0
            while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1].field_257 % 128:
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if 31 >= sub_594d129f[arg1].field_257 % 128:
                mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) > uint255(sub_594d129f[arg1].field_0) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                    mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                return 32, 160, 
                       ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                       mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                       sub_594d129f[arg1].field_256 % 128,
                       mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480] = sub_594d129f[arg1][1].field_0
            idx = ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480
            s = 0
            while ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) <= uint255(sub_594d129f[arg1].field_0) * 0.5:
            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   2 * Mask(256, -1, sub_594d129f[arg1].field_0),
                   mem[448 len ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 704] = 0
        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
        mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
            mem[(2 * ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
        return 32, 160, 
               ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + 192,
               sub_594d129f[arg1].field_512,
               uint64(sub_594d129f[arg1].field_768),
               uint64(sub_594d129f[arg1].field_768),
               2 * Mask(256, -1, sub_594d129f[arg1].field_0),
               mem[448 len uint255(sub_594d129f[arg1].field_0) * 0.5],
               0,
               mem[ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) + ceil32(sub_594d129f[arg1].field_257 % 128) + (uint255(sub_594d129f[arg1].field_0) * 0.5) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128) + ceil32(uint255(sub_594d129f[arg1].field_0) * 0.5) - (uint255(sub_594d129f[arg1].field_0) * 0.5)]
    if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(sub_594d129f[arg1].field_0):
        if bool(sub_594d129f[arg1].field_0) == uint255(sub_594d129f[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_594d129f[arg1].field_0):
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1].field_256):
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1].field_257 % 128:
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= sub_594d129f[arg1].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if 31 >= uint255(sub_594d129f[arg1].field_0) * 0.5:
            mem[448] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1].field_256):
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1].field_257 % 128:
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= sub_594d129f[arg1].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        mem[448] = sub_594d129f[arg1].field_0
        idx = 448
        s = 0
        while (uint255(sub_594d129f[arg1].field_0) * 0.5) + 416 > idx:
            mem[idx + 32] = sub_594d129f[arg1][s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    else:
        if bool(sub_594d129f[arg1].field_0) == sub_594d129f[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if not sub_594d129f[arg1].field_1 % 128:
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1].field_256):
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1].field_257 % 128:
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= sub_594d129f[arg1].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if 31 >= sub_594d129f[arg1].field_1 % 128:
            mem[448] = 256 * Mask(248, 0, sub_594d129f[arg1].field_8)
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1].field_256):
                    if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1].field_256):
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1].field_257 % 128:
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    if 31 >= sub_594d129f[arg1].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                        if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                        return 32, 160, 
                               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                               sub_594d129f[arg1].field_512,
                               uint64(sub_594d129f[arg1].field_768),
                               uint64(sub_594d129f[arg1].field_768),
                               sub_594d129f[arg1].field_0 % 128,
                               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                               uint255(sub_594d129f[arg1].field_256) * 0.5,
                               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                    idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                    s = 0
                    while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                        mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1].field_256):
                if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1].field_256):
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1].field_257 % 128:
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                if 31 >= sub_594d129f[arg1].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                    if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
                    return 32, 160, 
                           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                           sub_594d129f[arg1].field_512,
                           uint64(sub_594d129f[arg1].field_768),
                           uint64(sub_594d129f[arg1].field_768),
                           sub_594d129f[arg1].field_0 % 128,
                           mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                           sub_594d129f[arg1].field_257 % 128,
                           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
                idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
                s = 0
                while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                    mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        mem[448] = sub_594d129f[arg1].field_0
        idx = 448
        s = 0
        while sub_594d129f[arg1].field_1 % 128 + 416 > idx:
            mem[idx + 32] = sub_594d129f[arg1][s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if bool(sub_594d129f[arg1].field_256):
        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1].field_256):
            if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1].field_256):
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
            idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
            s = 0
            while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1].field_257 % 128:
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if 31 >= sub_594d129f[arg1].field_257 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
                if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
                if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
                return 32, 160, 
                       ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                       sub_594d129f[arg1].field_512,
                       uint64(sub_594d129f[arg1].field_768),
                       uint64(sub_594d129f[arg1].field_768),
                       sub_594d129f[arg1].field_0 % 128,
                       mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                       2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                       mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
            idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
            s = 0
            while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
                mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if ceil32(sub_594d129f[arg1].field_1 % 128) <= sub_594d129f[arg1].field_1 % 128:
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
            if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   2 * Mask(256, -1, sub_594d129f[arg1].field_256),
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 704] = uint255(sub_594d129f[arg1].field_256) * 0.5
        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5)]
        if ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) > uint255(sub_594d129f[arg1].field_256) * 0.5:
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 736] = 0
        return 32, 160, 
               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
               sub_594d129f[arg1].field_512,
               uint64(sub_594d129f[arg1].field_768),
               uint64(sub_594d129f[arg1].field_768),
               sub_594d129f[arg1].field_0 % 128,
               mem[448 len sub_594d129f[arg1].field_1 % 128],
               0,
               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + sub_594d129f[arg1].field_1 % 128 + 736 len ceil32(uint255(sub_594d129f[arg1].field_256) * 0.5) + ceil32(sub_594d129f[arg1].field_1 % 128) - sub_594d129f[arg1].field_1 % 128]
    if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
        revert with 0, 34
    if bool(sub_594d129f[arg1].field_256):
        if bool(sub_594d129f[arg1].field_256) == uint255(sub_594d129f[arg1].field_256) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_594d129f[arg1].field_256):
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if 31 >= uint255(sub_594d129f[arg1].field_256) * 0.5:
            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
        idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
        s = 0
        while ceil32(sub_594d129f[arg1].field_1 % 128) + (uint255(sub_594d129f[arg1].field_256) * 0.5) + 448 > idx:
            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
    else:
        if bool(sub_594d129f[arg1].field_256) == sub_594d129f[arg1].field_257 % 128 < 32:
            revert with 0, 34
        if not sub_594d129f[arg1].field_257 % 128:
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if 31 >= sub_594d129f[arg1].field_257 % 128:
            mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = 256 * Mask(248, 0, sub_594d129f[arg1].field_264)
            if ceil32(sub_594d129f[arg1].field_1 % 128) > sub_594d129f[arg1].field_1 % 128:
                mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
            if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
                mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
            return 32, 160, 
                   ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
                   sub_594d129f[arg1].field_512,
                   uint64(sub_594d129f[arg1].field_768),
                   uint64(sub_594d129f[arg1].field_768),
                   sub_594d129f[arg1].field_0 % 128,
                   mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
                   sub_594d129f[arg1].field_256 % 128,
                   mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480] = sub_594d129f[arg1][1].field_0
        idx = ceil32(sub_594d129f[arg1].field_1 % 128) + 480
        s = 0
        while ceil32(sub_594d129f[arg1].field_1 % 128) + sub_594d129f[arg1].field_257 % 128 + 448 > idx:
            mem[idx + 32] = sub_594d129f[arg1][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if ceil32(sub_594d129f[arg1].field_1 % 128) <= sub_594d129f[arg1].field_1 % 128:
        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
        if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
            mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
        return 32, 160, 
               ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
               sub_594d129f[arg1].field_512,
               uint64(sub_594d129f[arg1].field_768),
               uint64(sub_594d129f[arg1].field_768),
               sub_594d129f[arg1].field_0 % 128,
               mem[448 len ceil32(sub_594d129f[arg1].field_1 % 128)],
               sub_594d129f[arg1].field_256 % 128,
               mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
    mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 704] = 0
    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 704] = sub_594d129f[arg1].field_257 % 128
    mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + 736 len ceil32(sub_594d129f[arg1].field_257 % 128)] = mem[ceil32(sub_594d129f[arg1].field_1 % 128) + 480 len ceil32(sub_594d129f[arg1].field_257 % 128)]
    if ceil32(sub_594d129f[arg1].field_257 % 128) > sub_594d129f[arg1].field_257 % 128:
        mem[(2 * ceil32(sub_594d129f[arg1].field_1 % 128)) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_257 % 128 + 736] = 0
    return 32, 160, 
           ceil32(sub_594d129f[arg1].field_1 % 128) + 192,
           sub_594d129f[arg1].field_512,
           uint64(sub_594d129f[arg1].field_768),
           uint64(sub_594d129f[arg1].field_768),
           sub_594d129f[arg1].field_0 % 128,
           mem[448 len sub_594d129f[arg1].field_1 % 128],
           0,
           mem[ceil32(sub_594d129f[arg1].field_1 % 128) + ceil32(sub_594d129f[arg1].field_257 % 128) + sub_594d129f[arg1].field_1 % 128 + 736 len ceil32(sub_594d129f[arg1].field_257 % 128) + ceil32(sub_594d129f[arg1].field_1 % 128) - sub_594d129f[arg1].field_1 % 128]
}

function tokenURI(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if bool(sub_594d129f[arg1 << 192].field_0):
        if bool(sub_594d129f[arg1 << 192].field_0) == uint255(sub_594d129f[arg1 << 192].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1 << 192].field_0):
            if bool(sub_594d129f[arg1 << 192].field_0) == uint255(sub_594d129f[arg1 << 192].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1 << 192].field_0):
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1 << 192].field_256):
                        if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                            if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    else:
                        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                            revert with 0, 34
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                        if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                    if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                    return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if 31 >= uint255(sub_594d129f[arg1 << 192].field_0) * 0.5:
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1 << 192].field_256):
                        if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                            if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    else:
                        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                            revert with 0, 34
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                        if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                    if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                    return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            idx = 288
            s = 0
            while (uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 256 > idx:
                mem[idx + 32] = sub_594d129f[arg1 << 192][s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var44001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var46001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var45001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var46001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var45001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var47001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor15.length):
                                        var46001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 < uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not stor15.length.field_1 % 128:
                                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 < stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var47001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor15.length):
                                        var49001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not stor15.length.field_1 % 128:
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1 << 192].field_257 % 128:
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var46001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var47001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var49001 = ceil32(stor15.length.field_1 % 128)
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var46001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var45001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var47001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var47001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            var41001 = ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var46001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var47001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(stor15.length.field_1 % 128)
                        return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var46001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var45001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        var41001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1 << 192].field_257 % 128:
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var46001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var47001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var50001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            var42001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        else:
            if bool(sub_594d129f[arg1 << 192].field_0) == sub_594d129f[arg1 << 192].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1 << 192].field_1 % 128:
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1 << 192].field_256):
                        if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                            if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    else:
                        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                            revert with 0, 34
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                        if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                    if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                    return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if 31 >= sub_594d129f[arg1 << 192].field_1 % 128:
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_594d129f[arg1 << 192].field_256):
                        if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                            if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    else:
                        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                            revert with 0, 34
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if bool(stor15.length):
                                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                            revert with 0, 34
                                        if Mask(256, -1, stor15.length):
                                            if 31 >= uint255(stor15.length) * 0.5:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    else:
                                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                            revert with 0, 34
                                        if stor15.length.field_1 % 128:
                                            if 31 >= stor15.length.field_1 % 128:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            else:
                                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                                s = 0
                                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                    mem[idx + 32] = stor15[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                        if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                    if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                    return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if sub_594d129f[arg1 << 192].field_257 % 128:
                                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            idx = 288
            s = 0
            while sub_594d129f[arg1 << 192].field_1 % 128 + 256 > idx:
                mem[idx + 32] = sub_594d129f[arg1 << 192][s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var45001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var46001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var48001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        var51001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var47001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var46001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor15.length):
                                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 < uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not stor15.length.field_1 % 128:
                                        var48001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 < stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                            var50001 = ceil32(uint255(stor15.length) * 0.5)
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var49001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                            s = 0
                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor15.length):
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if not stor15.length.field_1 % 128:
                                        var51001 = ceil32(uint255(stor15.length) * 0.5)
                                    else:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if not sub_594d129f[arg1 << 192].field_257 % 128:
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var47001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var48001 = ceil32(stor15.length.field_1 % 128)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(stor15.length.field_1 % 128)
                            return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor15.length):
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var46001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var51001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var50001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            var42001 = ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var47001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                        return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var47001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var46001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                    s = 0
                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        var42001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1 << 192].field_257 % 128:
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var51001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var50001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var51001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                    else:
                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320
                        s = 0
                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            var43001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
        return Array(len=stor15.length % 128, data=mem[ceil32(uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
    if bool(sub_594d129f[arg1 << 192].field_0) == sub_594d129f[arg1 << 192].field_1 % 128 < 32:
        revert with 0, 34
    if bool(sub_594d129f[arg1 << 192].field_0):
        if bool(sub_594d129f[arg1 << 192].field_0) == uint255(sub_594d129f[arg1 << 192].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_594d129f[arg1 << 192].field_0):
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            if sub_594d129f[arg1 << 192].field_257 % 128:
                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                revert with 0, 34
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor15.length):
                    if 31 < uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            else:
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if stor15.length.field_1 % 128:
                    if 31 < stor15.length.field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
            if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
        if 31 >= uint255(sub_594d129f[arg1 << 192].field_0) * 0.5:
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            if sub_594d129f[arg1 << 192].field_257 % 128:
                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                revert with 0, 34
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor15.length):
                    if 31 < uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            else:
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if stor15.length.field_1 % 128:
                    if 31 < stor15.length.field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
            if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
        idx = 288
        s = 0
        while (uint255(sub_594d129f[arg1 << 192].field_0) * 0.5) + 256 > idx:
            mem[idx + 32] = sub_594d129f[arg1 << 192][s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if bool(sub_594d129f[arg1 << 192].field_256):
            if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var45001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var47001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var46001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var47001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var46001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var51001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var47001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var51001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1 << 192].field_257 % 128:
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var47001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var47001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var46001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var48001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                    s = 0
                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        var42001 = ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1 << 192].field_256):
            if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if not bool(stor15.length):
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var47001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                    return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if not bool(stor15.length):
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                else:
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var46001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if 31 >= uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            var51001 = ceil32(uint255(stor15.length) * 0.5)
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
            if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var51001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 >= stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
            else:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                s = 0
                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    var42001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var51001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 >= uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 >= stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
        else:
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1 << 192].field_257 % 128:
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var47001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var48001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var50001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var51001 = ceil32(stor15.length.field_1 % 128)
            else:
                if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                    s = 0
                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        var43001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
    else:
        if bool(sub_594d129f[arg1 << 192].field_0) == sub_594d129f[arg1 << 192].field_1 % 128 < 32:
            revert with 0, 34
        if not sub_594d129f[arg1 << 192].field_1 % 128:
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            if sub_594d129f[arg1 << 192].field_257 % 128:
                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                revert with 0, 34
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor15.length):
                    if 31 < uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            else:
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if stor15.length.field_1 % 128:
                    if 31 < stor15.length.field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
            if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
        if 31 >= sub_594d129f[arg1 << 192].field_1 % 128:
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_594d129f[arg1 << 192].field_256):
                    if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                        if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                else:
                    if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                        revert with 0, 34
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                                mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                                return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if bool(stor15.length):
                                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor15.length):
                                        if 31 >= uint255(stor15.length) * 0.5:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                else:
                                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                        revert with 0, 34
                                    if stor15.length.field_1 % 128:
                                        if 31 >= stor15.length.field_1 % 128:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        else:
                                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                            s = 0
                                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                                mem[idx + 32] = stor15[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                    return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                    if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]
                if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
                return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if 31 < uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    if 31 < sub_594d129f[arg1 << 192].field_257 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if sub_594d129f[arg1 << 192].field_257 % 128:
                            return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor15.length):
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if stor15.length.field_1 % 128:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
            if sub_594d129f[arg1 << 192].field_257 % 128:
                return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + 416 len ceil32(uint255(stor15.length) * 0.5)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]
                if ceil32(uint255(stor15.length) * 0.5) > uint255(stor15.length) * 0.5:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(uint255(stor15.length) * 0.5) + (uint255(stor15.length) * 0.5) + 416] = 0
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(uint255(stor15.length) * 0.5)) + 416 len 2 * ceil32(uint255(stor15.length) * 0.5)]), 
            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                revert with 0, 34
            if bool(stor15.length):
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor15.length):
                    if 31 < uint255(stor15.length) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            else:
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if stor15.length.field_1 % 128:
                    if 31 < stor15.length.field_1 % 128:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                            mem[idx + 32] = stor15[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + 416 len ceil32(stor15.length.field_1 % 128)] = mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]
            if ceil32(stor15.length.field_1 % 128) > stor15.length.field_1 % 128:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + ceil32(stor15.length.field_1 % 128) + stor15.length.field_1 % 128 + 416] = 0
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)], mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (2 * ceil32(stor15.length.field_1 % 128)) + 416 len 2 * ceil32(stor15.length.field_1 % 128)]), 
        idx = 288
        s = 0
        while sub_594d129f[arg1 << 192].field_1 % 128 + 256 > idx:
            mem[idx + 32] = sub_594d129f[arg1 << 192][s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if bool(sub_594d129f[arg1 << 192].field_256):
            if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                revert with 0, 34
            if bool(sub_594d129f[arg1 << 192].field_256):
                if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var46001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var47001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    var52001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var47001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var52001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var48001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var49001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 < stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                        var51001 = ceil32(uint255(stor15.length) * 0.5)
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var50001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var52001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                        s = 0
                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                            mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                            return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor15.length):
                                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                    revert with 0, 34
                                if not Mask(256, -1, stor15.length):
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= uint255(stor15.length) * 0.5:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            else:
                                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                    revert with 0, 34
                                if not stor15.length.field_1 % 128:
                                    var52001 = ceil32(uint255(stor15.length) * 0.5)
                                else:
                                    if 31 >= stor15.length.field_1 % 128:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    else:
                                        mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                        idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                        s = 0
                                        while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                            mem[idx + 32] = stor15[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                            return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var52001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
            else:
                if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                    revert with 0, 34
                if not sub_594d129f[arg1 << 192].field_257 % 128:
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var48001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var49001 = ceil32(stor15.length.field_1 % 128)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(stor15.length.field_1 % 128)
                        return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not bool(stor15.length):
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var47001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                var52001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var49001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var51001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var52001 = ceil32(uint255(stor15.length) * 0.5)
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var50001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var52001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                    s = 0
                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                        var43001 = ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)
                        return Array(len=2 * Mask(256, -1, sub_594d129f[arg1 << 192].field_256), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var52001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
            return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 352 len ceil32(stor15.length.field_1 % 128)]), 
        if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
            revert with 0, 34
        if bool(sub_594d129f[arg1 << 192].field_256):
            if bool(sub_594d129f[arg1 << 192].field_256) == uint255(sub_594d129f[arg1 << 192].field_256) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_594d129f[arg1 << 192].field_256):
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if not bool(stor15.length):
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var48001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var49001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(stor15.length.field_1 % 128)
                    return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
                if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                    revert with 0, 34
                if not bool(stor15.length):
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var48001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var50001 = ceil32(uint255(stor15.length) * 0.5)
                else:
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var47001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if 31 >= uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            var52001 = ceil32(uint255(stor15.length) * 0.5)
                return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
            if 31 >= uint255(sub_594d129f[arg1 << 192].field_256) * 0.5:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var50001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var52001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var52001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var51001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 >= stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
            else:
                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                s = 0
                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + (uint255(sub_594d129f[arg1 << 192].field_256) * 0.5) + 288 > idx:
                    mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    var43001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var52001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor15.length):
                        if 31 >= uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if stor15.length.field_1 % 128:
                        if 31 >= stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
        else:
            if bool(sub_594d129f[arg1 << 192].field_256) == sub_594d129f[arg1 << 192].field_257 % 128 < 32:
                revert with 0, 34
            if not sub_594d129f[arg1 << 192].field_257 % 128:
                if sub_594d129f[arg1 << 192].field_257 % 128:
                    return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var48001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var49001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if 31 < stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                    return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                    revert with 0, 34
                if bool(stor15.length):
                    if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor15.length):
                        var49001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < uint255(stor15.length) * 0.5:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var51001 = ceil32(stor15.length.field_1 % 128)
                else:
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor15.length.field_1 % 128:
                        var50001 = ceil32(stor15.length.field_1 % 128)
                    else:
                        if 31 < stor15.length.field_1 % 128:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                            idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                            s = 0
                            while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                mem[idx + 32] = stor15[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        else:
                            mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            var52001 = ceil32(stor15.length.field_1 % 128)
            else:
                if 31 >= sub_594d129f[arg1 << 192].field_257 % 128:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = 256 * Mask(248, 0, sub_594d129f[arg1 << 192].field_264)
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor15.length):
                                var50001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 < uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                    var52001 = ceil32(uint255(stor15.length) * 0.5)
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if not stor15.length.field_1 % 128:
                                var51001 = ceil32(uint255(stor15.length) * 0.5)
                            else:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor15.length):
                            var51001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor15.length.field_1 % 128:
                            var52001 = ceil32(stor15.length.field_1 % 128)
                        else:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                else:
                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320] = sub_594d129f[arg1 << 192][1].field_0
                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320
                    s = 0
                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + sub_594d129f[arg1 << 192].field_257 % 128 + 288 > idx:
                        mem[idx + 32] = sub_594d129f[arg1 << 192][s + 1].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_594d129f[arg1 << 192].field_257 % 128:
                        var44001 = ceil32(sub_594d129f[arg1 << 192].field_257 % 128)
                        return Array(len=sub_594d129f[arg1 << 192].field_256 % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + 320 len ceil32(sub_594d129f[arg1 << 192].field_257 % 128)]), 
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor15.length):
                            if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor15.length):
                                if 31 >= uint255(stor15.length) * 0.5:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        else:
                            if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                                revert with 0, 34
                            if stor15.length.field_1 % 128:
                                if 31 >= stor15.length.field_1 % 128:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                                else:
                                    mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                    idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                    s = 0
                                    while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                        mem[idx + 32] = stor15[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                        return Array(len=2 * Mask(256, -1, stor15.length), data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(uint255(stor15.length) * 0.5)]), 
                    if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                        revert with 0, 34
                    if bool(stor15.length):
                        if bool(stor15.length) == uint255(stor15.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor15.length):
                            if 31 >= uint255(stor15.length) * 0.5:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + (uint255(stor15.length) * 0.5) + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor15.length) == stor15.length.field_1 % 128 < 32:
                            revert with 0, 34
                        if stor15.length.field_1 % 128:
                            if 31 >= stor15.length.field_1 % 128:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = 256 * Mask(248, 0, stor15.length.field_8)
                            else:
                                mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352] = uint256(stor15.field_0)
                                idx = ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352
                                s = 0
                                while ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + stor15.length.field_1 % 128 + 320 > idx:
                                    mem[idx + 32] = stor15[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
    return Array(len=stor15.length % 128, data=mem[ceil32(sub_594d129f[arg1 << 192].field_1 % 128) + ceil32(sub_594d129f[arg1 << 192].field_257 % 128) + 352 len ceil32(stor15.length.field_1 % 128)]), 
}



}

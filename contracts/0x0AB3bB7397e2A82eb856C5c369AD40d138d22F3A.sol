contract main {




// =====================  Runtime code  =====================


address stor0;

function _fallback() payable {
    revert
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require arg4.length >= 160
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 100)] == cd[(arg4 + 100)]
    require cd[(arg4 + 132)] == cd[(arg4 + 132)]
    require cd[(arg4 + 164)] == cd[(arg4 + 164)]
    require ext_code.size(address(cd[(arg4 + 68)]))
    call address(cd[(arg4 + 68)]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args cd[(arg4 + 132)], cd[(arg4 + 164)], address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if cd[(arg4 + 132)] > -cd[(arg4 + 164)] - 1:
        revert with 'NH{q', 17
    if cd[(arg4 + 132)] + cd[(arg4 + 164)] < cd[(arg4 + 100)]:
        revert with 'NH{q', 17
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg1), cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args 0x85a92368ab710a85f57b9872c0fe4361a405e5d, cd[(arg4 + 132)] + cd[(arg4 + 164)] - cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function baguetteCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require arg4.length >= 160
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 100)] == cd[(arg4 + 100)]
    require cd[(arg4 + 132)] == cd[(arg4 + 132)]
    require cd[(arg4 + 164)] == cd[(arg4 + 164)]
    require ext_code.size(address(cd[(arg4 + 68)]))
    call address(cd[(arg4 + 68)]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args cd[(arg4 + 132)], cd[(arg4 + 164)], address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if cd[(arg4 + 132)] > -cd[(arg4 + 164)] - 1:
        revert with 'NH{q', 17
    if cd[(arg4 + 132)] + cd[(arg4 + 164)] < cd[(arg4 + 100)]:
        revert with 'NH{q', 17
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg1), cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args 0x85a92368ab710a85f57b9872c0fe4361a405e5d, cd[(arg4 + 132)] + cd[(arg4 + 164)] - cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require arg4.length >= 160
    require cd[(arg4 + 36)] == address(cd[(arg4 + 36)])
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 100)] == cd[(arg4 + 100)]
    require cd[(arg4 + 132)] == cd[(arg4 + 132)]
    require cd[(arg4 + 164)] == cd[(arg4 + 164)]
    require ext_code.size(address(cd[(arg4 + 68)]))
    call address(cd[(arg4 + 68)]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args cd[(arg4 + 132)], cd[(arg4 + 164)], address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if cd[(arg4 + 132)] > -cd[(arg4 + 164)] - 1:
        revert with 'NH{q', 17
    if cd[(arg4 + 132)] + cd[(arg4 + 164)] < cd[(arg4 + 100)]:
        revert with 'NH{q', 17
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg1), cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(cd[(arg4 + 36)]))
    call address(cd[(arg4 + 36)]).0xa9059cbb with:
         gas gas_remaining wei
        args 0x85a92368ab710a85f57b9872c0fe4361a405e5d, cd[(arg4 + 132)] + cd[(arg4 + 164)] - cd[(arg4 + 100)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_c2f019f8(?) payable {
    require calldata.size - 4 >= 448
    require calldata.size - 4 >= 224
    require arg1 == address(arg1)
    mem[96] = arg1
    require arg2 == address(arg2)
    mem[128] = arg2
    require arg3 == address(arg3)
    mem[160] = arg3
    require arg4 == arg4
    mem[192] = arg4
    require arg5 == arg5
    mem[224] = arg5
    require arg6 == arg6
    mem[256] = arg6
    require arg7 == arg7
    mem[288] = arg7
    require calldata.size - 228 >= 224
    require arg8 == address(arg8)
    mem[320] = arg8
    require arg9 == address(arg9)
    mem[352] = arg9
    require arg10 == address(arg10)
    mem[384] = arg10
    require arg11 == arg11
    mem[416] = arg11
    require arg12 == arg12
    mem[448] = arg12
    require arg13 == arg13
    mem[480] = arg13
    require arg14 == arg14
    mem[512] = arg14
    mem[544] = 0xddb2763300000000000000000000000000000000000000000000000000000000
    mem[548] = 0
    mem[580] = address(arg1)
    mem[612] = address(arg2)
    mem[644] = address(arg3)
    mem[676] = arg4
    mem[708] = arg5
    mem[740] = arg6
    mem[772] = arg7
    mem[804] = address(arg8)
    mem[836] = address(arg9)
    mem[868] = address(arg10)
    mem[900] = arg11
    mem[932] = arg12
    mem[964] = arg13
    mem[996] = arg14
    require ext_code.size(stor0)
    staticcall stor0.0xddb27633 with:
            gas gas_remaining wei
           args 0, address(arg1), address(arg2), address(arg3), arg4, arg5, arg6, arg7, address(arg8), address(arg9), address(arg10), arg11, arg12, arg13, arg14
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[544 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _20 = mem[544 len 4], 0
    require mem[544 len 4], 0 <= test266151307()
    require return_data.size - mem[544 len 4], 0 >= 96
    if not bool(ceil32(return_data.size) + 640 <= test266151307()):
        revert with 'NH{q', 65
    mem[64] = ceil32(return_data.size) + 640
    require mem[mem[544 len 4], 0 + 544] == mem[mem[544 len 4], 0 + 544]
    mem[ceil32(return_data.size) + 544] = mem[mem[544 len 4], 0 + 544]
    require mem[_20 + 576] == bool(mem[_20 + 576])
    mem[ceil32(return_data.size) + 576] = mem[_20 + 576]
    _24 = mem[_20 + 608]
    require mem[_20 + 608] <= test266151307()
    require _20 + mem[_20 + 608] + 575 < return_data.size + 544
    _25 = mem[_20 + mem[_20 + 608] + 544]
    if mem[_20 + mem[_20 + 608] + 544] > test266151307():
        revert with 'NH{q', 65
    if ceil32(return_data.size) + floor32(mem[_20 + mem[_20 + 608] + 544]) + 641 > test266151307() or floor32(mem[_20 + mem[_20 + 608] + 544]) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = ceil32(return_data.size) + floor32(mem[_20 + mem[_20 + 608] + 544]) + 641
    mem[ceil32(return_data.size) + 640] = _25
    require _20 + _24 + (32 * _25) + 32 <= return_data.size
    idx = 0
    s = _20 + _24 + 576
    t = ceil32(return_data.size) + 672
    while idx < _25:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[ceil32(return_data.size) + 608] = ceil32(return_data.size) + 640
    if not mem[ceil32(return_data.size) + 576]:
        revert with 0, 'S3'
    if not arg7:
        _106 = mem[ceil32(return_data.size) + 544]
        if 3 >= _25:
            revert with 'NH{q', 50
        _112 = mem[ceil32(return_data.size) + 768]
        if 2 >= _25:
            revert with 'NH{q', 50
        _118 = mem[ceil32(return_data.size) + 736]
        if mem[ceil32(return_data.size) + 736] > -mem[ceil32(return_data.size) + 768] - 1:
            revert with 'NH{q', 17
        if 2 >= _25:
            revert with 'NH{q', 50
        _129 = mem[ceil32(return_data.size) + 736]
        if 3 >= _25:
            revert with 'NH{q', 50
        _135 = mem[ceil32(return_data.size) + 768]
        _136 = mem[64]
        mem[mem[64] + 32] = address(arg2)
        mem[mem[64] + 64] = address(arg8)
        mem[mem[64] + 96] = _106
        mem[mem[64] + 128] = _129
        mem[mem[64] + 160] = _135
        _139 = mem[64]
        mem[mem[64]] = 160
        mem[64] = mem[64] + 192
        if 0 >= _25:
            revert with 'NH{q', 50
        _145 = mem[ceil32(return_data.size) + 672]
        if 1 >= _25:
            revert with 'NH{q', 50
        _151 = mem[ceil32(return_data.size) + 704]
        mem[_136 + 192] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_136 + 196] = _145
        mem[_136 + 228] = _151
        mem[_136 + 260] = address(arg8)
        mem[_136 + 292] = 128
        _157 = mem[_139]
        mem[_136 + 324] = mem[_139]
        mem[_136 + 356 len ceil32(_157)] = mem[_139 + 32 len ceil32(_157)]
        if ceil32(_157) > _157:
            mem[_136 + _157 + 356] = 0
        require ext_code.size(address(arg1))
        call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
             gas gas_remaining wei
            args _145, _151, address(arg8), 128, mem[_136 + 324 len ceil32(_157) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if _118 + _112 < _106:
            revert with 'NH{q', 17
        return _106, _118 + _112, _118 + _112 - _106
    _109 = mem[ceil32(return_data.size) + 544]
    if 3 >= _25:
        revert with 'NH{q', 50
    _115 = mem[ceil32(return_data.size) + 768]
    if 2 >= _25:
        revert with 'NH{q', 50
    _119 = mem[ceil32(return_data.size) + 736]
    if mem[ceil32(return_data.size) + 736] > -mem[ceil32(return_data.size) + 768] - 1:
        revert with 'NH{q', 17
    if 2 >= _25:
        revert with 'NH{q', 50
    _132 = mem[ceil32(return_data.size) + 736]
    if 3 >= _25:
        revert with 'NH{q', 50
    _137 = mem[ceil32(return_data.size) + 768]
    _138 = mem[64]
    mem[mem[64] + 32] = address(arg3)
    mem[mem[64] + 64] = address(arg8)
    mem[mem[64] + 96] = _109
    mem[mem[64] + 128] = _132
    mem[mem[64] + 160] = _137
    _142 = mem[64]
    mem[mem[64]] = 160
    mem[64] = mem[64] + 192
    if 0 >= _25:
        revert with 'NH{q', 50
    _148 = mem[ceil32(return_data.size) + 672]
    if 1 >= _25:
        revert with 'NH{q', 50
    _154 = mem[ceil32(return_data.size) + 704]
    mem[_138 + 192] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
    mem[_138 + 196] = _148
    mem[_138 + 228] = _154
    mem[_138 + 260] = address(arg8)
    mem[_138 + 292] = 128
    _158 = mem[_142]
    mem[_138 + 324] = mem[_142]
    mem[_138 + 356 len ceil32(_158)] = mem[_142 + 32 len ceil32(_158)]
    if ceil32(_158) > _158:
        mem[_138 + _158 + 356] = 0
    require ext_code.size(address(arg1))
    call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args _148, _154, address(arg8), 128, mem[_138 + 324 len ceil32(_158) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if _119 + _115 < _109:
        revert with 'NH{q', 17
    return _109, _119 + _115, _119 + _115 - _109
}



}

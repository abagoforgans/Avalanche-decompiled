contract main {




// =====================  Runtime code  =====================


#
#  - sub_7006918c(?)
#  - sub_8eaf435b(?)
#  - tokenURI(uint256 arg1)
#
array of struct stor101;
array of struct stor102;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor106;
address owner;
mapping of struct stor201;
mapping of uint256 sub_2b1331a8;
uint256 numMinted;
mapping of struct sub_be75288d;
uint256 presaleStartTime;
uint256 presaleEndTime;
uint8 transfersEnabled; offset 160
uint128 stor207; offset 160
address _signerAddress;

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function totalSupply() {
    return numMinted
}

function presaleEndTime() {
    return presaleEndTime
}

function sub_2b1331a8(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[arg1][arg2]
}

function sub_30ec18c2(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[address(arg1)][arg2]
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function owner() {
    return owner
}

function presaleStartTime() {
    return presaleStartTime
}

function sub_be75288d(?) {
    require calldata.size - 4 >= 32
    return sub_be75288d[arg1].field_256
}

function transfersEnabled() {
    return bool(transfersEnabled)
}

function _signerAddress() {
    return _signerAddress
}

function numMinted() {
    return numMinted
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor106[address(arg1)][address(arg2)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_ecdd42c2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    presaleStartTime = arg1
}

function sub_1593d8a5(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_256 = arg2
}

function sub_dcb2f4dc(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_768 = arg2
}

function sub_e345c564(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_512 = arg2
}

function sub_135ee927(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1536 = arg2
}

function sub_72c0ab83(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1024 = arg2
}

function sub_d010ad7f(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1280 = arg2
}

function updatePresaleEndTime(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    presaleEndTime = arg1
}

function updateSignerAddress(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _signerAddress = arg1
}

function setTransfersEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor207 = Mask(96, 0, arg1)
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor106[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function Sweep(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call arg1 with:
       value eth.balance(arg1) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor106[stor103[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function sub_3a0a52e4(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if sub_be75288d[arg1].field_1792:
        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while sub_be75288d[arg1].field_1793 + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function sub_d66fe70e(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= ('cd', 4).length:
            revert with 0, 50
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        approved[mem[(32 * idx) + 128]] = 0
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        emit Approval(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        if balanceOf[stor103[mem[(32 * idx) + 128]]] < 1:
            revert with 0, 17
        balanceOf[stor103[mem[(32 * idx) + 128]]]--
        ownerOf[mem[(32 * idx) + 128]] = 0
        emit Transfer(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        if numMinted < 1:
            revert with 0, 17
        numMinted--
        mem[0] = stor201[mem[(32 * idx) + 128]].field_0
        mem[32] = sha3(ownerOf[mem[(32 * idx) + 128]], 202)
        if sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0] < 1:
            revert with 0, 17
        sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0]--
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
        if not ext_call.success:
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if not transfersEnabled:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
        if not ext_call.success:
            if not return_data.size:
                if not arg4.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg4[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function name() {
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor101.length):
            if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor101.length):
                if 31 < uint255(stor101.length) * 0.5:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor101.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        else:
            if bool(stor101.length) == stor101.length.field_1 < 32:
                revert with 0, 34
            if stor101.length.field_1:
                if 31 < stor101.length.field_1:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while stor101.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        mem[ceil32(uint255(stor101.length) * 0.5) + 192 len ceil32(uint255(stor101.length) * 0.5)] = mem[128 len ceil32(uint255(stor101.length) * 0.5)]
        if ceil32(uint255(stor101.length) * 0.5) > uint255(stor101.length) * 0.5:
            mem[(uint255(stor101.length) * 0.5) + ceil32(uint255(stor101.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)], mem[(2 * ceil32(uint255(stor101.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor101.length) * 0.5)]), 
    if bool(stor101.length) == stor101.length.field_1 < 32:
        revert with 0, 34
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor101.length):
            if 31 < uint255(stor101.length) * 0.5:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while (uint255(stor101.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    else:
        if bool(stor101.length) == stor101.length.field_1 < 32:
            revert with 0, 34
        if stor101.length.field_1:
            if 31 < stor101.length.field_1:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while stor101.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    mem[ceil32(stor101.length.field_1) + 192 len ceil32(stor101.length.field_1)] = mem[128 len ceil32(stor101.length.field_1)]
    if ceil32(stor101.length.field_1) > stor101.length.field_1:
        mem[stor101.length.field_1 + ceil32(stor101.length.field_1) + 192] = 0
    return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)], mem[(2 * ceil32(stor101.length.field_1)) + 192 len 2 * ceil32(stor101.length.field_1)]), 
}

function symbol() {
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor102.length):
            if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor102.length):
                if 31 < uint255(stor102.length) * 0.5:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor102.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        else:
            if bool(stor102.length) == stor102.length.field_1 < 32:
                revert with 0, 34
            if stor102.length.field_1:
                if 31 < stor102.length.field_1:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while stor102.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        mem[ceil32(uint255(stor102.length) * 0.5) + 192 len ceil32(uint255(stor102.length) * 0.5)] = mem[128 len ceil32(uint255(stor102.length) * 0.5)]
        if ceil32(uint255(stor102.length) * 0.5) > uint255(stor102.length) * 0.5:
            mem[(uint255(stor102.length) * 0.5) + ceil32(uint255(stor102.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)], mem[(2 * ceil32(uint255(stor102.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor102.length) * 0.5)]), 
    if bool(stor102.length) == stor102.length.field_1 < 32:
        revert with 0, 34
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor102.length):
            if 31 < uint255(stor102.length) * 0.5:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while (uint255(stor102.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    else:
        if bool(stor102.length) == stor102.length.field_1 < 32:
            revert with 0, 34
        if stor102.length.field_1:
            if 31 < stor102.length.field_1:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while stor102.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    mem[ceil32(stor102.length.field_1) + 192 len ceil32(stor102.length.field_1)] = mem[128 len ceil32(stor102.length.field_1)]
    if ceil32(stor102.length.field_1) > stor102.length.field_1:
        mem[stor102.length.field_1 + ceil32(stor102.length.field_1) + 192] = 0
    return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)], mem[(2 * ceil32(stor102.length.field_1)) + 192 len 2 * ceil32(stor102.length.field_1)]), 
}

function sub_cf37c49a(?) {
    require calldata.size - 4 >= 32
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[128] = 256 * sub_be75288d[arg1].field_8
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if 31 >= sub_be75288d[arg1].field_1:
                    mem[128] = 256 * sub_be75288d[arg1].field_8
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while sub_be75288d[arg1].field_1 + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1792, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
               sub_be75288d[arg1].field_256,
               sub_be75288d[arg1].field_512,
               sub_be75288d[arg1].field_768,
               sub_be75288d[arg1].field_1024,
               sub_be75288d[arg1].field_1280,
               sub_be75288d[arg1].field_1536,
               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
    if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
        revert with 0, 34
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_be75288d[arg1].field_0):
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1) + 288
            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                revert with 0, 34
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793:
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                mem[128] = 256 * sub_be75288d[arg1].field_8
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1) + 288
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1) + 288
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                    mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
    else:
        if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
            revert with 0, 34
        if not sub_be75288d[arg1].field_1:
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1) + 288
            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                revert with 0, 34
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793:
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if 31 >= sub_be75288d[arg1].field_1:
                mem[128] = 256 * sub_be75288d[arg1].field_8
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while sub_be75288d[arg1].field_1 + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1) + 288
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1) + 288
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) <= sub_be75288d[arg1].field_1:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                    mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1792, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
           sub_be75288d[arg1].field_256,
           sub_be75288d[arg1].field_512,
           sub_be75288d[arg1].field_768,
           sub_be75288d[arg1].field_1024,
           sub_be75288d[arg1].field_1280,
           sub_be75288d[arg1].field_1536,
           ceil32(sub_be75288d[arg1].field_1) + 288
}

function sub_d871fea2(?) {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        mem[352] = uint255(sub_be75288d[arg1].field_0) * 0.5
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9715 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9715] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11371 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11371] = arg1
                                    mem[_11371 + 32] = 1000
                                    mem[_11371 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9715 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18747 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18747] == Mask(32, 224, mem[_18747])
                                    if Mask(32, 224, mem[_18747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _20907 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_20907] = arg1
                                    mem[_20907 + 32] = 1000
                                    mem[_20907 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9717 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9717] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11376 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11376] = arg1
                                        mem[_11376 + 32] = 1000
                                        mem[_11376 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9717 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18749 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18749] == Mask(32, 224, mem[_18749])
                                        if Mask(32, 224, mem[_18749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _20920 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_20920] = arg1
                                        mem[_20920 + 32] = 1000
                                        mem[_20920 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18541 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18541] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21883 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21883] = arg1
                                        mem[_21883 + 32] = 1000
                                        mem[_21883 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18541 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25691 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25691] == Mask(32, 224, mem[_25691])
                                        if Mask(32, 224, mem[_25691]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27355 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27355] = arg1
                                        mem[_27355 + 32] = 1000
                                        mem[_27355 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9718 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9718] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11381 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11381] = arg1
                                    mem[_11381 + 32] = 1000
                                    mem[_11381 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9718 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18751 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18751] == Mask(32, 224, mem[_18751])
                                    if Mask(32, 224, mem[_18751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _20932 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_20932] = arg1
                                    mem[_20932 + 32] = 1000
                                    mem[_20932 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9720 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9720] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11386 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11386] = arg1
                                        mem[_11386 + 32] = 1000
                                        mem[_11386 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9720 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18753 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18753] == Mask(32, 224, mem[_18753])
                                        if Mask(32, 224, mem[_18753]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _20945 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_20945] = arg1
                                        mem[_20945 + 32] = 1000
                                        mem[_20945 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18546 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18546] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21888 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21888] = arg1
                                        mem[_21888 + 32] = 1000
                                        mem[_21888 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18546 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25693 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25693] == Mask(32, 224, mem[_25693])
                                        if Mask(32, 224, mem[_25693]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27367 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27367] = arg1
                                        mem[_27367 + 32] = 1000
                                        mem[_27367 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9721 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9721] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11391 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11391] = arg1
                                    mem[_11391 + 32] = 1000
                                    mem[_11391 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9721 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18755 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18755] == Mask(32, 224, mem[_18755])
                                    if Mask(32, 224, mem[_18755]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _20957 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_20957] = arg1
                                    mem[_20957 + 32] = 1000
                                    mem[_20957 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9723 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9723] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11396 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11396] = arg1
                                        mem[_11396 + 32] = 1000
                                        mem[_11396 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9723 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18757 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18757] == Mask(32, 224, mem[_18757])
                                        if Mask(32, 224, mem[_18757]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _20970 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_20970] = arg1
                                        mem[_20970 + 32] = 1000
                                        mem[_20970 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18551 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18551] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21893 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21893] = arg1
                                        mem[_21893 + 32] = 1000
                                        mem[_21893 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18551 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25695 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25695] == Mask(32, 224, mem[_25695])
                                        if Mask(32, 224, mem[_25695]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27379 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27379] = arg1
                                        mem[_27379 + 32] = 1000
                                        mem[_27379 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9724 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9724] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11401 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11401] = arg1
                                    mem[_11401 + 32] = 1000
                                    mem[_11401 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9724 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18759 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18759] == Mask(32, 224, mem[_18759])
                                    if Mask(32, 224, mem[_18759]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _20982 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_20982] = arg1
                                    mem[_20982 + 32] = 1000
                                    mem[_20982 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9726 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9726] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11406 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11406] = arg1
                                        mem[_11406 + 32] = 1000
                                        mem[_11406 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9726 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18761 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18761] == Mask(32, 224, mem[_18761])
                                        if Mask(32, 224, mem[_18761]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _20995 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_20995] = arg1
                                        mem[_20995 + 32] = 1000
                                        mem[_20995 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18556 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18556] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21898 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21898] = arg1
                                        mem[_21898 + 32] = 1000
                                        mem[_21898 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18556 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25697 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25697] == Mask(32, 224, mem[_25697])
                                        if Mask(32, 224, mem[_25697]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27391 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27391] = arg1
                                        mem[_27391 + 32] = 1000
                                        mem[_27391 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9727 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9727] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11414 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11414] = arg1
                                        mem[_11414 + 32] = 1000
                                        mem[_11414 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9727 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18767 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18767] == Mask(32, 224, mem[_18767])
                                        if Mask(32, 224, mem[_18767]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21023 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21023] = arg1
                                        mem[_21023 + 32] = 1000
                                        mem[_21023 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9729 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9729] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11419 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11419] = arg1
                                            mem[_11419 + 32] = 1000
                                            mem[_11419 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9729 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18769 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18769] == Mask(32, 224, mem[_18769])
                                            if Mask(32, 224, mem[_18769]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21036 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21036] = arg1
                                            mem[_21036 + 32] = 1000
                                            mem[_21036 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18573 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18573] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21943 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21943] = arg1
                                            mem[_21943 + 32] = 1000
                                            mem[_21943 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18573 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25715 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25715] == Mask(32, 224, mem[_25715])
                                            if Mask(32, 224, mem[_25715]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27503 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27503] = arg1
                                            mem[_27503 + 32] = 1000
                                            mem[_27503 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9730 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9730] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11424 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11424] = arg1
                                        mem[_11424 + 32] = 1000
                                        mem[_11424 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9730 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18771 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18771] == Mask(32, 224, mem[_18771])
                                        if Mask(32, 224, mem[_18771]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21048 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21048] = arg1
                                        mem[_21048 + 32] = 1000
                                        mem[_21048 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9732 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9732] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11429 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11429] = arg1
                                            mem[_11429 + 32] = 1000
                                            mem[_11429 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9732 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18773 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18773] == Mask(32, 224, mem[_18773])
                                            if Mask(32, 224, mem[_18773]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21061 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21061] = arg1
                                            mem[_21061 + 32] = 1000
                                            mem[_21061 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18578 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18578] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21948 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21948] = arg1
                                            mem[_21948 + 32] = 1000
                                            mem[_21948 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18578 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25717 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25717] == Mask(32, 224, mem[_25717])
                                            if Mask(32, 224, mem[_25717]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27515 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27515] = arg1
                                            mem[_27515 + 32] = 1000
                                            mem[_27515 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9733 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9733] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11434 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11434] = arg1
                                        mem[_11434 + 32] = 1000
                                        mem[_11434 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9733 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18775 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18775] == Mask(32, 224, mem[_18775])
                                        if Mask(32, 224, mem[_18775]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21073 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21073] = arg1
                                        mem[_21073 + 32] = 1000
                                        mem[_21073 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9735 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9735] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11439 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11439] = arg1
                                            mem[_11439 + 32] = 1000
                                            mem[_11439 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9735 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18777 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18777] == Mask(32, 224, mem[_18777])
                                            if Mask(32, 224, mem[_18777]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21086 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21086] = arg1
                                            mem[_21086 + 32] = 1000
                                            mem[_21086 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18583 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18583] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21953 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21953] = arg1
                                            mem[_21953 + 32] = 1000
                                            mem[_21953 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18583 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25719 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25719] == Mask(32, 224, mem[_25719])
                                            if Mask(32, 224, mem[_25719]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27527 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27527] = arg1
                                            mem[_27527 + 32] = 1000
                                            mem[_27527 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9736 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9736] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11444 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11444] = arg1
                                        mem[_11444 + 32] = 1000
                                        mem[_11444 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9736 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18779 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18779] == Mask(32, 224, mem[_18779])
                                        if Mask(32, 224, mem[_18779]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21098 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21098] = arg1
                                        mem[_21098 + 32] = 1000
                                        mem[_21098 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9738 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9738] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11449 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11449] = arg1
                                            mem[_11449 + 32] = 1000
                                            mem[_11449 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9738 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18781 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18781] == Mask(32, 224, mem[_18781])
                                            if Mask(32, 224, mem[_18781]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21111 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21111] = arg1
                                            mem[_21111 + 32] = 1000
                                            mem[_21111 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18588 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18588] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21958 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21958] = arg1
                                            mem[_21958 + 32] = 1000
                                            mem[_21958 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18588 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25721 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25721] == Mask(32, 224, mem[_25721])
                                            if Mask(32, 224, mem[_25721]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27539 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27539] = arg1
                                            mem[_27539 + 32] = 1000
                                            mem[_27539 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18559 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18559] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21903 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21903] = arg1
                                        mem[_21903 + 32] = 1000
                                        mem[_21903 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18559 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25699 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25699] == Mask(32, 224, mem[_25699])
                                        if Mask(32, 224, mem[_25699]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27403 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27403] = arg1
                                        mem[_27403 + 32] = 1000
                                        mem[_27403 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18561 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18561] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21908 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21908] = arg1
                                            mem[_21908 + 32] = 1000
                                            mem[_21908 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18561 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25701 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25701] == Mask(32, 224, mem[_25701])
                                            if Mask(32, 224, mem[_25701]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27416 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27416] = arg1
                                            mem[_27416 + 32] = 1000
                                            mem[_27416 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25557 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25557] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28155 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28155] = arg1
                                            mem[_28155 + 32] = 1000
                                            mem[_28155 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25557 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28907 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28907] == Mask(32, 224, mem[_28907])
                                            if Mask(32, 224, mem[_28907]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29291 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29291] = arg1
                                            mem[_29291 + 32] = 1000
                                            mem[_29291 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18562 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18562] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21913 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21913] = arg1
                                        mem[_21913 + 32] = 1000
                                        mem[_21913 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18562 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25703 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25703] == Mask(32, 224, mem[_25703])
                                        if Mask(32, 224, mem[_25703]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27428 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27428] = arg1
                                        mem[_27428 + 32] = 1000
                                        mem[_27428 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18564 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18564] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21918 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21918] = arg1
                                            mem[_21918 + 32] = 1000
                                            mem[_21918 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18564 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25705] == Mask(32, 224, mem[_25705])
                                            if Mask(32, 224, mem[_25705]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27441 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27441] = arg1
                                            mem[_27441 + 32] = 1000
                                            mem[_27441 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25562 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25562] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28160 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28160] = arg1
                                            mem[_28160 + 32] = 1000
                                            mem[_28160 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25562 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28909 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28909] == Mask(32, 224, mem[_28909])
                                            if Mask(32, 224, mem[_28909]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29303 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29303] = arg1
                                            mem[_29303 + 32] = 1000
                                            mem[_29303 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18565 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18565] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21923 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21923] = arg1
                                        mem[_21923 + 32] = 1000
                                        mem[_21923 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18565 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25707 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25707] == Mask(32, 224, mem[_25707])
                                        if Mask(32, 224, mem[_25707]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27453 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27453] = arg1
                                        mem[_27453 + 32] = 1000
                                        mem[_27453 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18567 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18567] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21928 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21928] = arg1
                                            mem[_21928 + 32] = 1000
                                            mem[_21928 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18567 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25709 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25709] == Mask(32, 224, mem[_25709])
                                            if Mask(32, 224, mem[_25709]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27466 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27466] = arg1
                                            mem[_27466 + 32] = 1000
                                            mem[_27466 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25567 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25567] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28165 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28165] = arg1
                                            mem[_28165 + 32] = 1000
                                            mem[_28165 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25567 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28911 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28911] == Mask(32, 224, mem[_28911])
                                            if Mask(32, 224, mem[_28911]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29315 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29315] = arg1
                                            mem[_29315 + 32] = 1000
                                            mem[_29315 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18568 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18568] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21933 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21933] = arg1
                                        mem[_21933 + 32] = 1000
                                        mem[_21933 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18568 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25711 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25711] == Mask(32, 224, mem[_25711])
                                        if Mask(32, 224, mem[_25711]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27478 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27478] = arg1
                                        mem[_27478 + 32] = 1000
                                        mem[_27478 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18570 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18570] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21938 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21938] = arg1
                                            mem[_21938 + 32] = 1000
                                            mem[_21938 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18570 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25713 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25713] == Mask(32, 224, mem[_25713])
                                            if Mask(32, 224, mem[_25713]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27491 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27491] = arg1
                                            mem[_27491 + 32] = 1000
                                            mem[_27491 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25572 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25572] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28170 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28170] = arg1
                                            mem[_28170 + 32] = 1000
                                            mem[_28170 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25572 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28913 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28913] == Mask(32, 224, mem[_28913])
                                            if Mask(32, 224, mem[_28913]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29327 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29327] = arg1
                                            mem[_29327 + 32] = 1000
                                            mem[_29327 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9739 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9739] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11454 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11454] = arg1
                                    mem[_11454 + 32] = 1000
                                    mem[_11454 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9739 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18783 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18783] == Mask(32, 224, mem[_18783])
                                    if Mask(32, 224, mem[_18783]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21123 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21123] = arg1
                                    mem[_21123 + 32] = 1000
                                    mem[_21123 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9741 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9741] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11459 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11459] = arg1
                                        mem[_11459 + 32] = 1000
                                        mem[_11459 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9741 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18785 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18785] == Mask(32, 224, mem[_18785])
                                        if Mask(32, 224, mem[_18785]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21136 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21136] = arg1
                                        mem[_21136 + 32] = 1000
                                        mem[_21136 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18593 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18593] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21963 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21963] = arg1
                                        mem[_21963 + 32] = 1000
                                        mem[_21963 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18593 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25723 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25723] == Mask(32, 224, mem[_25723])
                                        if Mask(32, 224, mem[_25723]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27551 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27551] = arg1
                                        mem[_27551 + 32] = 1000
                                        mem[_27551 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9742 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9742] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11464 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11464] = arg1
                                    mem[_11464 + 32] = 1000
                                    mem[_11464 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9742 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18787 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18787] == Mask(32, 224, mem[_18787])
                                    if Mask(32, 224, mem[_18787]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21148 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21148] = arg1
                                    mem[_21148 + 32] = 1000
                                    mem[_21148 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9744 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9744] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11469 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11469] = arg1
                                        mem[_11469 + 32] = 1000
                                        mem[_11469 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9744 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18789 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18789] == Mask(32, 224, mem[_18789])
                                        if Mask(32, 224, mem[_18789]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21161 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21161] = arg1
                                        mem[_21161 + 32] = 1000
                                        mem[_21161 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18598 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18598] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21968 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21968] = arg1
                                        mem[_21968 + 32] = 1000
                                        mem[_21968 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18598 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25725] == Mask(32, 224, mem[_25725])
                                        if Mask(32, 224, mem[_25725]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27563 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27563] = arg1
                                        mem[_27563 + 32] = 1000
                                        mem[_27563 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9745 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9745] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11474 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11474] = arg1
                                    mem[_11474 + 32] = 1000
                                    mem[_11474 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9745 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18791 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18791] == Mask(32, 224, mem[_18791])
                                    if Mask(32, 224, mem[_18791]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21173 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21173] = arg1
                                    mem[_21173 + 32] = 1000
                                    mem[_21173 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9747 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9747] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11479 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11479] = arg1
                                        mem[_11479 + 32] = 1000
                                        mem[_11479 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9747 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18793 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18793] == Mask(32, 224, mem[_18793])
                                        if Mask(32, 224, mem[_18793]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21186 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21186] = arg1
                                        mem[_21186 + 32] = 1000
                                        mem[_21186 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18603 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18603] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21973 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21973] = arg1
                                        mem[_21973 + 32] = 1000
                                        mem[_21973 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18603 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25727 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25727] == Mask(32, 224, mem[_25727])
                                        if Mask(32, 224, mem[_25727]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27575 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27575] = arg1
                                        mem[_27575 + 32] = 1000
                                        mem[_27575 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9748 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9748] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11484 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11484] = arg1
                                    mem[_11484 + 32] = 1000
                                    mem[_11484 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9748 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18795 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18795] == Mask(32, 224, mem[_18795])
                                    if Mask(32, 224, mem[_18795]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21198 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21198] = arg1
                                    mem[_21198 + 32] = 1000
                                    mem[_21198 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9750 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9750] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11489 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11489] = arg1
                                        mem[_11489 + 32] = 1000
                                        mem[_11489 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9750 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18797 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18797] == Mask(32, 224, mem[_18797])
                                        if Mask(32, 224, mem[_18797]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21211 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21211] = arg1
                                        mem[_21211 + 32] = 1000
                                        mem[_21211 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18608 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18608] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21978 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21978] = arg1
                                        mem[_21978 + 32] = 1000
                                        mem[_21978 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18608 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25729 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25729] == Mask(32, 224, mem[_25729])
                                        if Mask(32, 224, mem[_25729]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27587 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27587] = arg1
                                        mem[_27587 + 32] = 1000
                                        mem[_27587 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9751 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9751] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11497 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11497] = arg1
                                        mem[_11497 + 32] = 1000
                                        mem[_11497 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9751 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18803 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18803] == Mask(32, 224, mem[_18803])
                                        if Mask(32, 224, mem[_18803]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21239 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21239] = arg1
                                        mem[_21239 + 32] = 1000
                                        mem[_21239 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9753 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9753] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11502 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11502] = arg1
                                            mem[_11502 + 32] = 1000
                                            mem[_11502 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9753 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18805 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18805] == Mask(32, 224, mem[_18805])
                                            if Mask(32, 224, mem[_18805]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21252 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21252] = arg1
                                            mem[_21252 + 32] = 1000
                                            mem[_21252 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18625 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18625] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22023 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22023] = arg1
                                            mem[_22023 + 32] = 1000
                                            mem[_22023 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18625 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25747 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25747] == Mask(32, 224, mem[_25747])
                                            if Mask(32, 224, mem[_25747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27699 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27699] = arg1
                                            mem[_27699 + 32] = 1000
                                            mem[_27699 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9754 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9754] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11507 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11507] = arg1
                                        mem[_11507 + 32] = 1000
                                        mem[_11507 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9754 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18807 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18807] == Mask(32, 224, mem[_18807])
                                        if Mask(32, 224, mem[_18807]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21264 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21264] = arg1
                                        mem[_21264 + 32] = 1000
                                        mem[_21264 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9756 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9756] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11512 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11512] = arg1
                                            mem[_11512 + 32] = 1000
                                            mem[_11512 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9756 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18809 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18809] == Mask(32, 224, mem[_18809])
                                            if Mask(32, 224, mem[_18809]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21277 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21277] = arg1
                                            mem[_21277 + 32] = 1000
                                            mem[_21277 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18630 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18630] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22028 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22028] = arg1
                                            mem[_22028 + 32] = 1000
                                            mem[_22028 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18630 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25749] == Mask(32, 224, mem[_25749])
                                            if Mask(32, 224, mem[_25749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27711 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27711] = arg1
                                            mem[_27711 + 32] = 1000
                                            mem[_27711 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9757 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9757] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11517 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11517] = arg1
                                        mem[_11517 + 32] = 1000
                                        mem[_11517 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9757 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18811 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18811] == Mask(32, 224, mem[_18811])
                                        if Mask(32, 224, mem[_18811]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21289 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21289] = arg1
                                        mem[_21289 + 32] = 1000
                                        mem[_21289 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9759 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9759] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11522 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11522] = arg1
                                            mem[_11522 + 32] = 1000
                                            mem[_11522 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9759 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18813 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18813] == Mask(32, 224, mem[_18813])
                                            if Mask(32, 224, mem[_18813]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21302 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21302] = arg1
                                            mem[_21302 + 32] = 1000
                                            mem[_21302 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18635 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18635] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22033 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22033] = arg1
                                            mem[_22033 + 32] = 1000
                                            mem[_22033 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18635 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25751 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25751] == Mask(32, 224, mem[_25751])
                                            if Mask(32, 224, mem[_25751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27723 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27723] = arg1
                                            mem[_27723 + 32] = 1000
                                            mem[_27723 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9760 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9760] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11527 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11527] = arg1
                                        mem[_11527 + 32] = 1000
                                        mem[_11527 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9760 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18815 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18815] == Mask(32, 224, mem[_18815])
                                        if Mask(32, 224, mem[_18815]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21314 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21314] = arg1
                                        mem[_21314 + 32] = 1000
                                        mem[_21314 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9762 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9762] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11532 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11532] = arg1
                                            mem[_11532 + 32] = 1000
                                            mem[_11532 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9762 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18817 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18817] == Mask(32, 224, mem[_18817])
                                            if Mask(32, 224, mem[_18817]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21327 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21327] = arg1
                                            mem[_21327 + 32] = 1000
                                            mem[_21327 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18640 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18640] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22038 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22038] = arg1
                                            mem[_22038 + 32] = 1000
                                            mem[_22038 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18640 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25753 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25753] == Mask(32, 224, mem[_25753])
                                            if Mask(32, 224, mem[_25753]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27735 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27735] = arg1
                                            mem[_27735 + 32] = 1000
                                            mem[_27735 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18611 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18611] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21983 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21983] = arg1
                                        mem[_21983 + 32] = 1000
                                        mem[_21983 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18611 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25731 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25731] == Mask(32, 224, mem[_25731])
                                        if Mask(32, 224, mem[_25731]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27599 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27599] = arg1
                                        mem[_27599 + 32] = 1000
                                        mem[_27599 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18613 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18613] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21988 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21988] = arg1
                                            mem[_21988 + 32] = 1000
                                            mem[_21988 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18613 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25733 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25733] == Mask(32, 224, mem[_25733])
                                            if Mask(32, 224, mem[_25733]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27612 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27612] = arg1
                                            mem[_27612 + 32] = 1000
                                            mem[_27612 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25593 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25593] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28175 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28175] = arg1
                                            mem[_28175 + 32] = 1000
                                            mem[_28175 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25593 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28915 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28915] == Mask(32, 224, mem[_28915])
                                            if Mask(32, 224, mem[_28915]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29339 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29339] = arg1
                                            mem[_29339 + 32] = 1000
                                            mem[_29339 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18614 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18614] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _21993 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21993] = arg1
                                        mem[_21993 + 32] = 1000
                                        mem[_21993 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18614 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25735 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25735] == Mask(32, 224, mem[_25735])
                                        if Mask(32, 224, mem[_25735]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27624 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27624] = arg1
                                        mem[_27624 + 32] = 1000
                                        mem[_27624 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18616 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18616] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _21998 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21998] = arg1
                                            mem[_21998 + 32] = 1000
                                            mem[_21998 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18616 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25737 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25737] == Mask(32, 224, mem[_25737])
                                            if Mask(32, 224, mem[_25737]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27637 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27637] = arg1
                                            mem[_27637 + 32] = 1000
                                            mem[_27637 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25598 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25598] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28180 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28180] = arg1
                                            mem[_28180 + 32] = 1000
                                            mem[_28180 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25598 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28917 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28917] == Mask(32, 224, mem[_28917])
                                            if Mask(32, 224, mem[_28917]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29351 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29351] = arg1
                                            mem[_29351 + 32] = 1000
                                            mem[_29351 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18617 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18617] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22003 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22003] = arg1
                                        mem[_22003 + 32] = 1000
                                        mem[_22003 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18617 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25739 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25739] == Mask(32, 224, mem[_25739])
                                        if Mask(32, 224, mem[_25739]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27649 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27649] = arg1
                                        mem[_27649 + 32] = 1000
                                        mem[_27649 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18619 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18619] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22008 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22008] = arg1
                                            mem[_22008 + 32] = 1000
                                            mem[_22008 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18619 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25741 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25741] == Mask(32, 224, mem[_25741])
                                            if Mask(32, 224, mem[_25741]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27662 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27662] = arg1
                                            mem[_27662 + 32] = 1000
                                            mem[_27662 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25603 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25603] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28185 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28185] = arg1
                                            mem[_28185 + 32] = 1000
                                            mem[_28185 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25603 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28919 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28919] == Mask(32, 224, mem[_28919])
                                            if Mask(32, 224, mem[_28919]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29363 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29363] = arg1
                                            mem[_29363 + 32] = 1000
                                            mem[_29363 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18620 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18620] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22013 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22013] = arg1
                                        mem[_22013 + 32] = 1000
                                        mem[_22013 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18620 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25743] == Mask(32, 224, mem[_25743])
                                        if Mask(32, 224, mem[_25743]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27674 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27674] = arg1
                                        mem[_27674 + 32] = 1000
                                        mem[_27674 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18622 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18622] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22018 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22018] = arg1
                                            mem[_22018 + 32] = 1000
                                            mem[_22018 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18622 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25745] == Mask(32, 224, mem[_25745])
                                            if Mask(32, 224, mem[_25745]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27687 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27687] = arg1
                                            mem[_27687 + 32] = 1000
                                            mem[_27687 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25608 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25608] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28190 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28190] = arg1
                                            mem[_28190 + 32] = 1000
                                            mem[_28190 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25608 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28921 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28921] == Mask(32, 224, mem[_28921])
                                            if Mask(32, 224, mem[_28921]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29375 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29375] = arg1
                                            mem[_29375 + 32] = 1000
                                            mem[_29375 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
    else:
        if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
            revert with 0, 34
        mem[352] = sub_be75288d[arg1].field_1
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9763 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9763] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11537 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11537] = arg1
                                    mem[_11537 + 32] = 1000
                                    mem[_11537 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9763 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18819 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18819] == Mask(32, 224, mem[_18819])
                                    if Mask(32, 224, mem[_18819]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21339 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21339] = arg1
                                    mem[_21339 + 32] = 1000
                                    mem[_21339 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9765 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9765] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11542 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11542] = arg1
                                        mem[_11542 + 32] = 1000
                                        mem[_11542 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9765 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18821 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18821] == Mask(32, 224, mem[_18821])
                                        if Mask(32, 224, mem[_18821]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21352 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21352] = arg1
                                        mem[_21352 + 32] = 1000
                                        mem[_21352 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18645 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18645] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22043 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22043] = arg1
                                        mem[_22043 + 32] = 1000
                                        mem[_22043 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18645 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25755 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25755] == Mask(32, 224, mem[_25755])
                                        if Mask(32, 224, mem[_25755]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27747 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27747] = arg1
                                        mem[_27747 + 32] = 1000
                                        mem[_27747 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9766 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9766] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11547 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11547] = arg1
                                    mem[_11547 + 32] = 1000
                                    mem[_11547 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9766 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18823 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18823] == Mask(32, 224, mem[_18823])
                                    if Mask(32, 224, mem[_18823]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21364 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21364] = arg1
                                    mem[_21364 + 32] = 1000
                                    mem[_21364 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9768 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9768] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11552 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11552] = arg1
                                        mem[_11552 + 32] = 1000
                                        mem[_11552 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9768 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18825 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18825] == Mask(32, 224, mem[_18825])
                                        if Mask(32, 224, mem[_18825]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21377 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21377] = arg1
                                        mem[_21377 + 32] = 1000
                                        mem[_21377 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18650 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18650] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22048 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22048] = arg1
                                        mem[_22048 + 32] = 1000
                                        mem[_22048 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18650 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25757 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25757] == Mask(32, 224, mem[_25757])
                                        if Mask(32, 224, mem[_25757]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27759 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27759] = arg1
                                        mem[_27759 + 32] = 1000
                                        mem[_27759 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9769 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9769] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11557 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11557] = arg1
                                    mem[_11557 + 32] = 1000
                                    mem[_11557 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9769 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18827 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18827] == Mask(32, 224, mem[_18827])
                                    if Mask(32, 224, mem[_18827]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21389 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21389] = arg1
                                    mem[_21389 + 32] = 1000
                                    mem[_21389 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9771 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9771] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11562 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11562] = arg1
                                        mem[_11562 + 32] = 1000
                                        mem[_11562 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9771 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18829 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18829] == Mask(32, 224, mem[_18829])
                                        if Mask(32, 224, mem[_18829]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21402 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21402] = arg1
                                        mem[_21402 + 32] = 1000
                                        mem[_21402 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18655 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18655] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22053 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22053] = arg1
                                        mem[_22053 + 32] = 1000
                                        mem[_22053 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18655 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25759 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25759] == Mask(32, 224, mem[_25759])
                                        if Mask(32, 224, mem[_25759]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27771 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27771] = arg1
                                        mem[_27771 + 32] = 1000
                                        mem[_27771 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9772 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9772] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11567 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11567] = arg1
                                    mem[_11567 + 32] = 1000
                                    mem[_11567 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9772 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18831 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18831] == Mask(32, 224, mem[_18831])
                                    if Mask(32, 224, mem[_18831]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21414 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21414] = arg1
                                    mem[_21414 + 32] = 1000
                                    mem[_21414 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9774 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9774] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11572 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11572] = arg1
                                        mem[_11572 + 32] = 1000
                                        mem[_11572 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9774 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18833 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18833] == Mask(32, 224, mem[_18833])
                                        if Mask(32, 224, mem[_18833]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21427 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21427] = arg1
                                        mem[_21427 + 32] = 1000
                                        mem[_21427 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18660 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18660] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22058 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22058] = arg1
                                        mem[_22058 + 32] = 1000
                                        mem[_22058 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18660 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25761 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25761] == Mask(32, 224, mem[_25761])
                                        if Mask(32, 224, mem[_25761]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27783 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27783] = arg1
                                        mem[_27783 + 32] = 1000
                                        mem[_27783 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9775 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9775] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11580 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11580] = arg1
                                        mem[_11580 + 32] = 1000
                                        mem[_11580 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9775 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18839 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18839] == Mask(32, 224, mem[_18839])
                                        if Mask(32, 224, mem[_18839]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21455 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21455] = arg1
                                        mem[_21455 + 32] = 1000
                                        mem[_21455 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9777 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9777] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11585 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11585] = arg1
                                            mem[_11585 + 32] = 1000
                                            mem[_11585 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9777 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18841 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18841] == Mask(32, 224, mem[_18841])
                                            if Mask(32, 224, mem[_18841]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21468 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21468] = arg1
                                            mem[_21468 + 32] = 1000
                                            mem[_21468 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18677 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18677] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22103 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22103] = arg1
                                            mem[_22103 + 32] = 1000
                                            mem[_22103 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18677 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25779 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25779] == Mask(32, 224, mem[_25779])
                                            if Mask(32, 224, mem[_25779]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27895 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27895] = arg1
                                            mem[_27895 + 32] = 1000
                                            mem[_27895 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9778 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9778] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11590 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11590] = arg1
                                        mem[_11590 + 32] = 1000
                                        mem[_11590 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9778 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18843 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18843] == Mask(32, 224, mem[_18843])
                                        if Mask(32, 224, mem[_18843]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21480 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21480] = arg1
                                        mem[_21480 + 32] = 1000
                                        mem[_21480 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9780 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9780] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11595 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11595] = arg1
                                            mem[_11595 + 32] = 1000
                                            mem[_11595 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9780 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18845 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18845] == Mask(32, 224, mem[_18845])
                                            if Mask(32, 224, mem[_18845]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21493 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21493] = arg1
                                            mem[_21493 + 32] = 1000
                                            mem[_21493 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18682 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18682] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22108 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22108] = arg1
                                            mem[_22108 + 32] = 1000
                                            mem[_22108 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18682 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25781 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25781] == Mask(32, 224, mem[_25781])
                                            if Mask(32, 224, mem[_25781]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27907 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27907] = arg1
                                            mem[_27907 + 32] = 1000
                                            mem[_27907 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9781 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9781] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11600 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11600] = arg1
                                        mem[_11600 + 32] = 1000
                                        mem[_11600 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9781 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18847 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18847] == Mask(32, 224, mem[_18847])
                                        if Mask(32, 224, mem[_18847]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21505 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21505] = arg1
                                        mem[_21505 + 32] = 1000
                                        mem[_21505 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9783 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9783] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11605 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11605] = arg1
                                            mem[_11605 + 32] = 1000
                                            mem[_11605 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9783 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18849 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18849] == Mask(32, 224, mem[_18849])
                                            if Mask(32, 224, mem[_18849]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21518 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21518] = arg1
                                            mem[_21518 + 32] = 1000
                                            mem[_21518 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18687 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18687] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22113 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22113] = arg1
                                            mem[_22113 + 32] = 1000
                                            mem[_22113 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18687 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25783 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25783] == Mask(32, 224, mem[_25783])
                                            if Mask(32, 224, mem[_25783]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27919 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27919] = arg1
                                            mem[_27919 + 32] = 1000
                                            mem[_27919 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9784 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9784] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11610 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11610] = arg1
                                        mem[_11610 + 32] = 1000
                                        mem[_11610 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9784 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18851 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18851] == Mask(32, 224, mem[_18851])
                                        if Mask(32, 224, mem[_18851]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21530 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21530] = arg1
                                        mem[_21530 + 32] = 1000
                                        mem[_21530 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9786 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9786] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11615 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11615] = arg1
                                            mem[_11615 + 32] = 1000
                                            mem[_11615 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9786 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18853 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18853] == Mask(32, 224, mem[_18853])
                                            if Mask(32, 224, mem[_18853]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21543 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21543] = arg1
                                            mem[_21543 + 32] = 1000
                                            mem[_21543 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18692 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18692] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22118 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22118] = arg1
                                            mem[_22118 + 32] = 1000
                                            mem[_22118 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18692 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25785 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25785] == Mask(32, 224, mem[_25785])
                                            if Mask(32, 224, mem[_25785]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27931 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27931] = arg1
                                            mem[_27931 + 32] = 1000
                                            mem[_27931 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18663 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18663] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22063 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22063] = arg1
                                        mem[_22063 + 32] = 1000
                                        mem[_22063 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18663 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25763 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25763] == Mask(32, 224, mem[_25763])
                                        if Mask(32, 224, mem[_25763]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27795 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27795] = arg1
                                        mem[_27795 + 32] = 1000
                                        mem[_27795 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18665 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18665] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22068 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22068] = arg1
                                            mem[_22068 + 32] = 1000
                                            mem[_22068 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18665 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25765 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25765] == Mask(32, 224, mem[_25765])
                                            if Mask(32, 224, mem[_25765]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27808 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27808] = arg1
                                            mem[_27808 + 32] = 1000
                                            mem[_27808 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25629 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25629] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28195 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28195] = arg1
                                            mem[_28195 + 32] = 1000
                                            mem[_28195 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25629 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28923 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28923] == Mask(32, 224, mem[_28923])
                                            if Mask(32, 224, mem[_28923]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29387 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29387] = arg1
                                            mem[_29387 + 32] = 1000
                                            mem[_29387 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18666 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18666] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22073 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22073] = arg1
                                        mem[_22073 + 32] = 1000
                                        mem[_22073 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18666 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25767 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25767] == Mask(32, 224, mem[_25767])
                                        if Mask(32, 224, mem[_25767]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27820 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27820] = arg1
                                        mem[_27820 + 32] = 1000
                                        mem[_27820 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18668 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18668] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22078 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22078] = arg1
                                            mem[_22078 + 32] = 1000
                                            mem[_22078 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18668 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25769 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25769] == Mask(32, 224, mem[_25769])
                                            if Mask(32, 224, mem[_25769]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27833 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27833] = arg1
                                            mem[_27833 + 32] = 1000
                                            mem[_27833 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25634 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25634] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28200 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28200] = arg1
                                            mem[_28200 + 32] = 1000
                                            mem[_28200 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25634 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28925 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28925] == Mask(32, 224, mem[_28925])
                                            if Mask(32, 224, mem[_28925]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29399 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29399] = arg1
                                            mem[_29399 + 32] = 1000
                                            mem[_29399 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18669 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18669] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22083 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22083] = arg1
                                        mem[_22083 + 32] = 1000
                                        mem[_22083 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18669 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25771 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25771] == Mask(32, 224, mem[_25771])
                                        if Mask(32, 224, mem[_25771]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27845 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27845] = arg1
                                        mem[_27845 + 32] = 1000
                                        mem[_27845 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18671 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18671] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22088 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22088] = arg1
                                            mem[_22088 + 32] = 1000
                                            mem[_22088 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18671 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25773 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25773] == Mask(32, 224, mem[_25773])
                                            if Mask(32, 224, mem[_25773]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27858 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27858] = arg1
                                            mem[_27858 + 32] = 1000
                                            mem[_27858 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25639 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25639] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28205 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28205] = arg1
                                            mem[_28205 + 32] = 1000
                                            mem[_28205 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25639 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28927 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28927] == Mask(32, 224, mem[_28927])
                                            if Mask(32, 224, mem[_28927]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29411 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29411] = arg1
                                            mem[_29411 + 32] = 1000
                                            mem[_29411 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18672 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18672] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22093 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22093] = arg1
                                        mem[_22093 + 32] = 1000
                                        mem[_22093 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18672 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25775 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25775] == Mask(32, 224, mem[_25775])
                                        if Mask(32, 224, mem[_25775]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27870 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27870] = arg1
                                        mem[_27870 + 32] = 1000
                                        mem[_27870 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18674 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18674] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22098 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22098] = arg1
                                            mem[_22098 + 32] = 1000
                                            mem[_22098 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18674 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25777 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25777] == Mask(32, 224, mem[_25777])
                                            if Mask(32, 224, mem[_25777]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _27883 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27883] = arg1
                                            mem[_27883 + 32] = 1000
                                            mem[_27883 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25644 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25644] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28210 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28210] = arg1
                                            mem[_28210 + 32] = 1000
                                            mem[_28210 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25644 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28929 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28929] == Mask(32, 224, mem[_28929])
                                            if Mask(32, 224, mem[_28929]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29423 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29423] = arg1
                                            mem[_29423 + 32] = 1000
                                            mem[_29423 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9787 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9787] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11620 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11620] = arg1
                                    mem[_11620 + 32] = 1000
                                    mem[_11620 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9787 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18855 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18855] == Mask(32, 224, mem[_18855])
                                    if Mask(32, 224, mem[_18855]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21555 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21555] = arg1
                                    mem[_21555 + 32] = 1000
                                    mem[_21555 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9789 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9789] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11625 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11625] = arg1
                                        mem[_11625 + 32] = 1000
                                        mem[_11625 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9789 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18857 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18857] == Mask(32, 224, mem[_18857])
                                        if Mask(32, 224, mem[_18857]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21568 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21568] = arg1
                                        mem[_21568 + 32] = 1000
                                        mem[_21568 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18697 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18697] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22123 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22123] = arg1
                                        mem[_22123 + 32] = 1000
                                        mem[_22123 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18697 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25787 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25787] == Mask(32, 224, mem[_25787])
                                        if Mask(32, 224, mem[_25787]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27943 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27943] = arg1
                                        mem[_27943 + 32] = 1000
                                        mem[_27943 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9790 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9790] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11630 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11630] = arg1
                                    mem[_11630 + 32] = 1000
                                    mem[_11630 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9790 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18859 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18859] == Mask(32, 224, mem[_18859])
                                    if Mask(32, 224, mem[_18859]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21580 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21580] = arg1
                                    mem[_21580 + 32] = 1000
                                    mem[_21580 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9792 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9792] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11635 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11635] = arg1
                                        mem[_11635 + 32] = 1000
                                        mem[_11635 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9792 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18861 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18861] == Mask(32, 224, mem[_18861])
                                        if Mask(32, 224, mem[_18861]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21593 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21593] = arg1
                                        mem[_21593 + 32] = 1000
                                        mem[_21593 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18702 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18702] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22128 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22128] = arg1
                                        mem[_22128 + 32] = 1000
                                        mem[_22128 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18702 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25789 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25789] == Mask(32, 224, mem[_25789])
                                        if Mask(32, 224, mem[_25789]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27955 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27955] = arg1
                                        mem[_27955 + 32] = 1000
                                        mem[_27955 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9793 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9793] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11640 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11640] = arg1
                                    mem[_11640 + 32] = 1000
                                    mem[_11640 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9793 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18863 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18863] == Mask(32, 224, mem[_18863])
                                    if Mask(32, 224, mem[_18863]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21605 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21605] = arg1
                                    mem[_21605 + 32] = 1000
                                    mem[_21605 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9795 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9795] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11645 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11645] = arg1
                                        mem[_11645 + 32] = 1000
                                        mem[_11645 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9795 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18865 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18865] == Mask(32, 224, mem[_18865])
                                        if Mask(32, 224, mem[_18865]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21618 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21618] = arg1
                                        mem[_21618 + 32] = 1000
                                        mem[_21618 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18707 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18707] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22133 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22133] = arg1
                                        mem[_22133 + 32] = 1000
                                        mem[_22133 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18707 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25791 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25791] == Mask(32, 224, mem[_25791])
                                        if Mask(32, 224, mem[_25791]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27967 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27967] = arg1
                                        mem[_27967 + 32] = 1000
                                        mem[_27967 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _9796 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_9796] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11650 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_11650] = arg1
                                    mem[_11650 + 32] = 1000
                                    mem[_11650 + 64] = block.timestamp
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _9796 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18867 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_18867] == Mask(32, 224, mem[_18867])
                                    if Mask(32, 224, mem[_18867]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21630 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21630] = arg1
                                    mem[_21630 + 32] = 1000
                                    mem[_21630 + 64] = block.timestamp
                                mem[0] = numMinted
                                mem[32] = 201
                                stor201[stor203].field_0 = arg1
                                stor201[stor203].field_256 = 1000
                                stor201[stor203].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9798 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9798] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11655 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11655] = arg1
                                        mem[_11655 + 32] = 1000
                                        mem[_11655 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9798 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18869 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18869] == Mask(32, 224, mem[_18869])
                                        if Mask(32, 224, mem[_18869]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21643 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21643] = arg1
                                        mem[_21643 + 32] = 1000
                                        mem[_21643 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18712 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18712] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22138 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22138] = arg1
                                        mem[_22138 + 32] = 1000
                                        mem[_22138 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18712 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25793 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25793] == Mask(32, 224, mem[_25793])
                                        if Mask(32, 224, mem[_25793]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27979 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27979] = arg1
                                        mem[_27979 + 32] = 1000
                                        mem[_27979 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9799 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9799] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11663 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11663] = arg1
                                        mem[_11663 + 32] = 1000
                                        mem[_11663 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9799 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18875 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18875] == Mask(32, 224, mem[_18875])
                                        if Mask(32, 224, mem[_18875]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21671 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21671] = arg1
                                        mem[_21671 + 32] = 1000
                                        mem[_21671 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9801 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9801] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11668 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11668] = arg1
                                            mem[_11668 + 32] = 1000
                                            mem[_11668 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9801 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18877 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18877] == Mask(32, 224, mem[_18877])
                                            if Mask(32, 224, mem[_18877]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21684 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21684] = arg1
                                            mem[_21684 + 32] = 1000
                                            mem[_21684 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18729 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18729] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22183 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22183] = arg1
                                            mem[_22183 + 32] = 1000
                                            mem[_22183 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18729 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25811 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25811] == Mask(32, 224, mem[_25811])
                                            if Mask(32, 224, mem[_25811]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28091 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28091] = arg1
                                            mem[_28091 + 32] = 1000
                                            mem[_28091 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9802 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9802] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11673 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11673] = arg1
                                        mem[_11673 + 32] = 1000
                                        mem[_11673 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9802 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18879 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18879] == Mask(32, 224, mem[_18879])
                                        if Mask(32, 224, mem[_18879]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21696 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21696] = arg1
                                        mem[_21696 + 32] = 1000
                                        mem[_21696 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9804 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9804] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11678 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11678] = arg1
                                            mem[_11678 + 32] = 1000
                                            mem[_11678 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9804 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18881 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18881] == Mask(32, 224, mem[_18881])
                                            if Mask(32, 224, mem[_18881]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21709 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21709] = arg1
                                            mem[_21709 + 32] = 1000
                                            mem[_21709 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18734 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18734] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22188 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22188] = arg1
                                            mem[_22188 + 32] = 1000
                                            mem[_22188 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18734 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25813 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25813] == Mask(32, 224, mem[_25813])
                                            if Mask(32, 224, mem[_25813]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28103 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28103] = arg1
                                            mem[_28103 + 32] = 1000
                                            mem[_28103 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9805 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9805] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11683 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11683] = arg1
                                        mem[_11683 + 32] = 1000
                                        mem[_11683 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9805 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18883 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18883] == Mask(32, 224, mem[_18883])
                                        if Mask(32, 224, mem[_18883]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21721 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21721] = arg1
                                        mem[_21721 + 32] = 1000
                                        mem[_21721 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9807 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9807] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11688 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11688] = arg1
                                            mem[_11688 + 32] = 1000
                                            mem[_11688 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9807 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18885 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18885] == Mask(32, 224, mem[_18885])
                                            if Mask(32, 224, mem[_18885]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21734 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21734] = arg1
                                            mem[_21734 + 32] = 1000
                                            mem[_21734 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18739 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18739] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22193 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22193] = arg1
                                            mem[_22193 + 32] = 1000
                                            mem[_22193 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18739 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25815 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25815] == Mask(32, 224, mem[_25815])
                                            if Mask(32, 224, mem[_25815]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28115 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28115] = arg1
                                            mem[_28115 + 32] = 1000
                                            mem[_28115 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _9808 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_9808] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11693 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_11693] = arg1
                                        mem[_11693 + 32] = 1000
                                        mem[_11693 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _9808 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _18887 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_18887] == Mask(32, 224, mem[_18887])
                                        if Mask(32, 224, mem[_18887]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21746 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21746] = arg1
                                        mem[_21746 + 32] = 1000
                                        mem[_21746 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _9810 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_9810] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11698 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_11698] = arg1
                                            mem[_11698 + 32] = 1000
                                            mem[_11698 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _9810 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18889 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_18889] == Mask(32, 224, mem[_18889])
                                            if Mask(32, 224, mem[_18889]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21759 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21759] = arg1
                                            mem[_21759 + 32] = 1000
                                            mem[_21759 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18744 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18744] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22198 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22198] = arg1
                                            mem[_22198 + 32] = 1000
                                            mem[_22198 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18744 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25817 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25817] == Mask(32, 224, mem[_25817])
                                            if Mask(32, 224, mem[_25817]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28127 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28127] = arg1
                                            mem[_28127 + 32] = 1000
                                            mem[_28127 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18715 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18715] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22143 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22143] = arg1
                                        mem[_22143 + 32] = 1000
                                        mem[_22143 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18715 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25795 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25795] == Mask(32, 224, mem[_25795])
                                        if Mask(32, 224, mem[_25795]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _27991 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27991] = arg1
                                        mem[_27991 + 32] = 1000
                                        mem[_27991 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18717 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18717] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22148 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22148] = arg1
                                            mem[_22148 + 32] = 1000
                                            mem[_22148 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18717 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25797 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25797] == Mask(32, 224, mem[_25797])
                                            if Mask(32, 224, mem[_25797]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28004 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28004] = arg1
                                            mem[_28004 + 32] = 1000
                                            mem[_28004 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25665 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25665] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28215 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28215] = arg1
                                            mem[_28215 + 32] = 1000
                                            mem[_28215 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25665 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28931 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28931] == Mask(32, 224, mem[_28931])
                                            if Mask(32, 224, mem[_28931]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29435 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29435] = arg1
                                            mem[_29435 + 32] = 1000
                                            mem[_29435 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18718 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18718] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22153 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22153] = arg1
                                        mem[_22153 + 32] = 1000
                                        mem[_22153 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18718 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25799 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25799] == Mask(32, 224, mem[_25799])
                                        if Mask(32, 224, mem[_25799]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28016 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28016] = arg1
                                        mem[_28016 + 32] = 1000
                                        mem[_28016 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18720 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18720] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22158 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22158] = arg1
                                            mem[_22158 + 32] = 1000
                                            mem[_22158 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18720 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25801 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25801] == Mask(32, 224, mem[_25801])
                                            if Mask(32, 224, mem[_25801]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28029 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28029] = arg1
                                            mem[_28029 + 32] = 1000
                                            mem[_28029 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25670 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25670] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28220 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28220] = arg1
                                            mem[_28220 + 32] = 1000
                                            mem[_28220 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25670 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28933 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28933] == Mask(32, 224, mem[_28933])
                                            if Mask(32, 224, mem[_28933]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29447 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29447] = arg1
                                            mem[_29447 + 32] = 1000
                                            mem[_29447 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18721 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18721] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22163 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22163] = arg1
                                        mem[_22163 + 32] = 1000
                                        mem[_22163 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18721 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25803 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25803] == Mask(32, 224, mem[_25803])
                                        if Mask(32, 224, mem[_25803]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28041 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28041] = arg1
                                        mem[_28041 + 32] = 1000
                                        mem[_28041 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18723 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18723] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22168 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22168] = arg1
                                            mem[_22168 + 32] = 1000
                                            mem[_22168 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18723 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25805 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25805] == Mask(32, 224, mem[_25805])
                                            if Mask(32, 224, mem[_25805]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28054 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28054] = arg1
                                            mem[_28054 + 32] = 1000
                                            mem[_28054 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25675 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25675] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28225 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28225] = arg1
                                            mem[_28225 + 32] = 1000
                                            mem[_28225 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25675 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28935 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28935] == Mask(32, 224, mem[_28935])
                                            if Mask(32, 224, mem[_28935]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29459 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29459] = arg1
                                            mem[_29459 + 32] = 1000
                                            mem[_29459 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18724 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18724] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22173 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22173] = arg1
                                        mem[_22173 + 32] = 1000
                                        mem[_22173 + 64] = block.timestamp
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18724 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _25807 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_25807] == Mask(32, 224, mem[_25807])
                                        if Mask(32, 224, mem[_25807]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28066 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28066] = arg1
                                        mem[_28066 + 32] = 1000
                                        mem[_28066 + 64] = block.timestamp
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    stor201[stor203].field_0 = arg1
                                    stor201[stor203].field_256 = 1000
                                    stor201[stor203].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18726 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18726] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22178 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22178] = arg1
                                            mem[_22178 + 32] = 1000
                                            mem[_22178 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18726 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _25809 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_25809] == Mask(32, 224, mem[_25809])
                                            if Mask(32, 224, mem[_25809]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28079 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28079] = arg1
                                            mem[_28079 + 32] = 1000
                                            mem[_28079 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _25680 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_25680] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _28230 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28230] = arg1
                                            mem[_28230 + 32] = 1000
                                            mem[_28230 + 64] = block.timestamp
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _25680 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28937 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_28937] == Mask(32, 224, mem[_28937])
                                            if Mask(32, 224, mem[_28937]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _29471 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29471] = arg1
                                            mem[_29471 + 32] = 1000
                                            mem[_29471 + 64] = block.timestamp
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        stor201[stor203].field_0 = arg1
                                        stor201[stor203].field_256 = 1000
                                        stor201[stor203].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
}



}

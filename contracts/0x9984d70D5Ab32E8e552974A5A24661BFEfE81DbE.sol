contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
array of struct multLP;
mapping of uint256 stor2;
address HCTAddress;
uint256 hCTPerBlock;
array of struct poolInfo;
mapping of struct userInfo;
mapping of uint256 poolCorrespond;
mapping of uint256 lpOfPid;
uint8 paused;
uint256 stor9;
uint256 totalAllocPoint;
uint256 startBlock;
address multLpChefAddress;
address multLpTokenAddress;
uint256 halvingPeriod;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699761;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699762;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699763;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699764;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699765;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024,
           poolInfo[arg1].field_1280
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function HCTPerBlock() payable {
    return hCTPerBlock
}

function getMultLPAddress(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 > multLP.length - 1:
        revert with 0, 'not find this multLP'
    if arg1 >= multLP.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0xfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64,
                    mem[198 len 30]
    return multLP[arg1].field_0
}

function startBlock() payable {
    return startBlock
}

function halvingPeriod() payable {
    return halvingPeriod
}

function paused() payable {
    return bool(uint8(paused))
}

function multLpToken() payable {
    return multLpTokenAddress
}

function isMultLP(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor2[address(arg1)])
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256, userInfo[arg1][arg2].field_512
}

function LpOfPid(address arg1) payable {
    require calldata.size - 4 >= 32
    return lpOfPid[arg1]
}

function HCT() payable {
    return HCTAddress
}

function poolCorrespond(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    return poolCorrespond[arg1]
}

function multLpChef() payable {
    return multLpChefAddress
}

function getMultLPLength() payable {
    return multLP.length
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setPause() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    uint256(stor9) = not uint8(paused) or Mask(248, 8, uint256(stor9))
}

function setHalvingPeriod(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    halvingPeriod = arg1
}

function setPoolCorr(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 > poolInfo.length - 1:
        revert with 0, 'not find this pool'
    poolCorrespond[arg1] = arg2
}

function setMultLP(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'is the zero address'
    if not arg2:
        revert with 0, 'is the zero address'
    multLpTokenAddress = arg1
    multLpChefAddress = arg2
}

function phase(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == halvingPeriod:
        return 0
    if arg1 <= startBlock:
        return 0
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > arg1 - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if halvingPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require halvingPeriod
    return (arg1 + -startBlock - 1 / halvingPeriod)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function reward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == halvingPeriod:
        return hCTPerBlock
    if arg1 <= startBlock:
        return hCTPerBlock
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > arg1 - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if halvingPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require halvingPeriod
    if 2^(arg1 + -startBlock - 1 / halvingPeriod) <= 0:
        revert with 0, 'SafeMath: division by zero'
    require 2^(arg1 + -startBlock - 1 / halvingPeriod)
    return (hCTPerBlock / 2^(arg1 + -startBlock - 1 / halvingPeriod))
}

function addMultLP(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'LP is the zero address'
    require ext_code.size(arg1)
    call arg1.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args multLpChefAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if stor2[address(arg1)]:
        return 0
    multLP.length++
    multLP[multLP.length].field_0 = arg1
    multLP[multLP.length].field_160 = 0
    stor2[address(arg1)] = multLP.length
    return 1
}

function replaceMultLP(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'is the zero address'
    if not arg2:
        revert with 0, 'is the zero address'
    if bool(uint8(paused)) != 1:
        revert with 0, 'No mining suspension'
    multLpTokenAddress = arg1
    multLpChefAddress = arg2
    idx = multLP.length
    while idx:
        if 0 >= multLP.length:
            revert with 0, 32, 34, 0xfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64, mem[198 len 30]
        mem[96] = 0x5312ea8e00000000000000000000000000000000000000000000000000000000
        mem[100] = poolCorrespond[stor8[address(stor1.field_0)]]
        require ext_code.size(multLpChefAddress)
        call multLpChefAddress.0x5312ea8e with:
             gas gas_remaining wei
            args poolCorrespond[stor8[address(stor1.field_0)]]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[0] = address(multLP.field_0)
        mem[32] = 2
        if stor2[address(stor1.field_0)]:
            require multLP.length - 1 < multLP.length
            require stor2[address(stor1.field_0)] - 1 < multLP.length
            multLP[stor2[address(multLP.field_0)]].field_0 = multLP[multLP.length].field_0
            stor2[stor1[stor1.length].field_0] = stor2[address(stor1.field_0)]
            require multLP.length
            multLP[multLP.length].field_0 = 0
            multLP.length--
            mem[0] = address(multLP.field_0)
            mem[32] = 2
            stor2[address(stor1.field_0)] = 0
        idx = idx - 1
        continue 
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if uint8(paused):
        revert with 0, 'Mining has been suspended'
    if arg1 >= poolInfo.length:
        revert with 0, 'pid over length'
    require arg1 < poolInfo.length
    if not stor2[stor5[arg1].field_0]:
    else:
        require ext_code.size(multLpTokenAddress)
        staticcall multLpTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(multLpChefAddress)
        call multLpChefAddress.0x441a3e70 with:
             gas gas_remaining wei
            args poolCorrespond[arg1], userInfo[arg1][address(msg.sender)].field_0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(multLpTokenAddress)
        staticcall multLpTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
            revert with 0, 'SafeMath: addition overflow'
        poolInfo[arg1].field_1024 += 0 / poolInfo[arg1].field_1280
    userInfo[arg1][address(msg.sender)].field_0 = 0
    userInfo[arg1][address(msg.sender)].field_256 = 0
    userInfo[arg1][address(msg.sender)].field_512 = 0
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = transfer(address rg1, uint256 rg2), msg.sender, userInfo[arg1][address(msg.sender)].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][address(msg.sender)].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with transfer(address rg1, uint256 rg2), msg.sender, userInfo[arg1][address(msg.sender)].field_0
        if not transfer(address rg1, uint256 rg2), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    if userInfo[arg1][address(msg.sender)].field_0 > poolInfo[arg1].field_1280:
        revert with 0, 'SafeMath: subtraction overflow'
    poolInfo[arg1].field_1280 -= userInfo[arg1][address(msg.sender)].field_0
    emit EmergencyWithdraw(userInfo[arg1][address(msg.sender)].field_0, msg.sender, arg1);
}

function getHCTBlockReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == halvingPeriod:
        if 0 == halvingPeriod:
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
        if block.number <= startBlock:
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
            revert with 0, 'SafeMath: division by zero'
        require 2^(block.number + -startBlock - 1 / halvingPeriod)
        if arg1 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - arg1:
            return 0
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - arg1 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)))
    if arg1 <= startBlock:
        if 0 == halvingPeriod:
            if 0 == halvingPeriod:
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
            if block.number <= startBlock:
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - arg1 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)))
        if block.number <= startBlock:
            if 0 == halvingPeriod:
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
            if block.number <= startBlock:
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) / block.number - arg1 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (arg1 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * hCTPerBlock) - (arg1 * hCTPerBlock))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - arg1 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (arg1 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        idx = 0
        s = arg1
        while idx < block.number + -startBlock - 1 / halvingPeriod:
            if not idx + 1:
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if halvingPeriod != 0:
                    if startBlock > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                if s > startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock - s:
                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock
                continue 
            if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if startBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if 0 == halvingPeriod:
                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
            else:
                if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                            revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = startBlock + halvingPeriod + (idx * halvingPeriod)
            continue 
    else:
        if startBlock > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > arg1 - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 0 == halvingPeriod:
            idx = arg1 + -startBlock - 1 / halvingPeriod
            s = arg1
            while idx < 0:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if halvingPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == halvingPeriod:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                continue 
        else:
            if block.number <= startBlock:
                idx = arg1 + -startBlock - 1 / halvingPeriod
                s = arg1
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                idx = arg1 + -startBlock - 1 / halvingPeriod
                s = arg1
                while idx < block.number + -startBlock - 1 / halvingPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
    if 0 == halvingPeriod:
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * hCTPerBlock) - (s * hCTPerBlock))
    if block.number <= startBlock:
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * hCTPerBlock) - (s * hCTPerBlock))
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if halvingPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require halvingPeriod
    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
        revert with 0, 'SafeMath: division by zero'
    require 2^(block.number + -startBlock - 1 / halvingPeriod)
    if s > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - s:
        return 0
    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
        revert with 0, 'SafeMath: addition overflow'
    return ((block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)))
}

function massUpdatePools() payable {
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 5
        if block.number > poolInfo[idx].field_512:
            mem[0] = poolInfo[idx].field_0
            mem[32] = 2
            if stor2[stor5[idx].field_0]:
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == halvingPeriod:
                        if 0 == halvingPeriod:
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[100] = this.address
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if poolInfo[idx].field_1280 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require poolInfo[idx].field_1280
                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == halvingPeriod:
                                if 0 == halvingPeriod:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                    if 0 == halvingPeriod:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 0 == halvingPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + halvingPeriod + (s * halvingPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                            if 0 == halvingPeriod:
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
            else:
                mem[100] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == halvingPeriod:
                        if 0 == halvingPeriod:
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[100] = this.address
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == halvingPeriod:
                                if 0 == halvingPeriod:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                    if 0 == halvingPeriod:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 0 == halvingPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + halvingPeriod + (s * halvingPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                            if 0 == halvingPeriod:
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
        idx = idx + 1
        continue 
}

function setHCTPerBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 5
        if block.number > poolInfo[idx].field_512:
            mem[0] = poolInfo[idx].field_0
            mem[32] = 2
            if stor2[stor5[idx].field_0]:
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == halvingPeriod:
                        if 0 == halvingPeriod:
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[100] = this.address
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if poolInfo[idx].field_1280 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require poolInfo[idx].field_1280
                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == halvingPeriod:
                                if 0 == halvingPeriod:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                    if 0 == halvingPeriod:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 0 == halvingPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + halvingPeriod + (s * halvingPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                            if 0 == halvingPeriod:
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
            else:
                mem[100] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == halvingPeriod:
                        if 0 == halvingPeriod:
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[100] = this.address
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == halvingPeriod:
                                if 0 == halvingPeriod:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                    if 0 == halvingPeriod:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 0 == halvingPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + halvingPeriod + (s * halvingPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / halvingPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                            if 0 == halvingPeriod:
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
        idx = idx + 1
        continue 
    hCTPerBlock = arg1
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        if stor2[stor5[arg1].field_0]:
            if not poolInfo[arg1].field_1280:
                poolInfo[arg1].field_512 = block.number
            else:
                if 0 == halvingPeriod:
                    if 0 == halvingPeriod:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if block.number - poolInfo[arg1].field_512:
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(HCTAddress)
                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(HCTAddress)
                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(HCTAddress)
                                staticcall HCTAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                poolInfo[arg1].field_512 = block.number
                    else:
                        if block.number <= startBlock:
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if poolInfo[arg1].field_1280 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require poolInfo[arg1].field_1280
                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if startBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > block.number - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if poolInfo[arg1].field_1280 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require poolInfo[arg1].field_1280
                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                else:
                    if poolInfo[arg1].field_512 <= startBlock:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[arg1].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[arg1].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[arg1].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[arg1].field_1280
                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 == halvingPeriod:
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                idx = 0
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / halvingPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                                if 0 == halvingPeriod:
                                    if s > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - s:
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                    else:
                        if startBlock > poolInfo[arg1].field_512:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > poolInfo[arg1].field_512 - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 0 == halvingPeriod:
                            idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                            s = poolInfo[arg1].field_512
                            while idx < 0:
                                if not idx + 1:
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if halvingPeriod != 0:
                                        if startBlock > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    if s > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock - s:
                                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock
                                    continue 
                                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 == halvingPeriod:
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                continue 
                        else:
                            if block.number <= startBlock:
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                                s = poolInfo[arg1].field_512
                                while idx < 0:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / halvingPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                        if 0 == halvingPeriod:
                            if s > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - s:
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if poolInfo[arg1].field_1280 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require poolInfo[arg1].field_1280
                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[arg1].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[arg1].field_1280
                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[arg1].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[arg1].field_1280
                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
        else:
            require ext_code.size(poolInfo[arg1].field_0)
            staticcall poolInfo[arg1].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                poolInfo[arg1].field_512 = block.number
            else:
                if 0 == halvingPeriod:
                    if 0 == halvingPeriod:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if block.number - poolInfo[arg1].field_512:
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(HCTAddress)
                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(HCTAddress)
                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(HCTAddress)
                                staticcall HCTAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                    else:
                        if block.number <= startBlock:
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if startBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > block.number - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                else:
                    if poolInfo[arg1].field_512 <= startBlock:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[arg1].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[arg1].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 == halvingPeriod:
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                idx = 0
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / halvingPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                                if 0 == halvingPeriod:
                                    if s > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - s:
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                    else:
                        if startBlock > poolInfo[arg1].field_512:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > poolInfo[arg1].field_512 - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 0 == halvingPeriod:
                            idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                            s = poolInfo[arg1].field_512
                            while idx < 0:
                                if not idx + 1:
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if halvingPeriod != 0:
                                        if startBlock > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    if s > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock - s:
                                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock
                                    continue 
                                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 == halvingPeriod:
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                continue 
                        else:
                            if block.number <= startBlock:
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                                s = poolInfo[arg1].field_512
                                while idx < 0:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / halvingPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if halvingPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == halvingPeriod:
                                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                                    continue 
                        if 0 == halvingPeriod:
                            if s > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - s:
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                    if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(HCTAddress)
                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(HCTAddress)
                                    staticcall HCTAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (s * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 >= poolInfo.length:
        revert with 0, 'pid over length'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 5
            if block.number > poolInfo[idx].field_512:
                mem[0] = poolInfo[idx].field_0
                mem[32] = 2
                if stor2[stor5[idx].field_0]:
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == halvingPeriod:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == halvingPeriod:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                        if 0 == halvingPeriod:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 0 == halvingPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                if 0 == halvingPeriod:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                else:
                    mem[100] = this.address
                    require ext_code.size(poolInfo[idx].field_0)
                    staticcall poolInfo[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == halvingPeriod:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == halvingPeriod:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                        if 0 == halvingPeriod:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 0 == halvingPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                if 0 == halvingPeriod:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = arg2 + totalAllocPoint - poolInfo[arg1].field_256
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
}

function add(uint256 arg1, address arg2, bool arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg2:
        revert with 0, '_lpToken is the zero address'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 5
            if block.number > poolInfo[idx].field_512:
                mem[0] = poolInfo[idx].field_0
                mem[32] = 2
                if stor2[stor5[idx].field_0]:
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if poolInfo[idx].field_1280 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require poolInfo[idx].field_1280
                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == halvingPeriod:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == halvingPeriod:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                        if 0 == halvingPeriod:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 0 == halvingPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                if 0 == halvingPeriod:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if poolInfo[idx].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[idx].field_1280
                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                else:
                    mem[100] = this.address
                    require ext_code.size(poolInfo[idx].field_0)
                    staticcall poolInfo[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == halvingPeriod:
                            if 0 == halvingPeriod:
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(HCTAddress)
                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[100] = this.address
                                        require ext_code.size(HCTAddress)
                                        staticcall HCTAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == halvingPeriod:
                                    if 0 == halvingPeriod:
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if halvingPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require halvingPeriod
                                            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == halvingPeriod:
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) / block.number - poolInfo[idx].field_512 != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (poolInfo[idx].field_512 * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[idx].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                        if 0 == halvingPeriod:
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                    if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                    else:
                                                        if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(HCTAddress)
                                                        call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[100] = this.address
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                        if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                        else:
                                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            staticcall HCTAddress.0x70a08231 with:
                                                                    gas gas_remaining wei
                                                                   args this.address
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(HCTAddress)
                                                            call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[100] = this.address
                                                        require ext_code.size(HCTAddress)
                                                        staticcall HCTAddress.0x70a08231 with:
                                                                gas gas_remaining wei
                                                               args this.address
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 0 == halvingPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if halvingPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == halvingPeriod:
                                            if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if halvingPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require halvingPeriod
                                                if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + halvingPeriod + (s * halvingPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / halvingPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / halvingPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if halvingPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) / startBlock - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if halvingPeriod + (s * halvingPeriod) / s + 1 != halvingPeriod:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == halvingPeriod:
                                                if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + halvingPeriod + (s * halvingPeriod) <= startBlock:
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock:
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (s * halvingPeriod * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if halvingPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require halvingPeriod
                                                    if 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)
                                                    if t > startBlock + halvingPeriod + (s * halvingPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + halvingPeriod + (s * halvingPeriod) - t:
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (s * halvingPeriod) - t != hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod):
                                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) + (s * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(halvingPeriod + (s * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + halvingPeriod + (s * halvingPeriod)
                                            continue 
                                if 0 == halvingPeriod:
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                            if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                            else:
                                                if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(HCTAddress)
                                                call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[100] = this.address
                                            require ext_code.size(HCTAddress)
                                            staticcall HCTAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) / block.number - t != hCTPerBlock:
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock) - (t * hCTPerBlock) > 0:
                                                if not (block.number * hCTPerBlock) - (t * hCTPerBlock):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / (block.number * hCTPerBlock) - (t * hCTPerBlock) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock * poolInfo[idx].field_256) - (t * hCTPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if halvingPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require halvingPeriod
                                        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require 2^(block.number + -startBlock - 1 / halvingPeriod)
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - t != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) > 0:
                                                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                else:
                                                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    staticcall HCTAddress.0x70a08231 with:
                                                            gas gas_remaining wei
                                                           args this.address
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    mem[132] = (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(HCTAddress)
                                                    call HCTAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) - (t * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[idx].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[100] = this.address
                                                require ext_code.size(HCTAddress)
                                                staticcall HCTAddress.0x70a08231 with:
                                                        gas gas_remaining wei
                                                       args this.address
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
    if arg1 + totalAllocPoint < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += arg1
    poolInfo.length++
    stor36B6[stor5.length] = arg2
    stor36B6[stor5.length] = arg1
    if block.number > startBlock:
        stor36B6[stor5.length] = block.number
    else:
        stor36B6[stor5.length] = startBlock
    stor36B6[stor5.length] = 0
    stor36B6[stor5.length] = 0
    stor36B6[stor5.length] = 0
    lpOfPid[address(arg2)] = poolInfo.length - 1
}

function pending(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 >= poolInfo.length:
        revert with 0, 'Hurricane: Pid Non-Existent'
    require arg1 < poolInfo.length
    if not stor2[stor5[arg1].field_0]:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not userInfo[arg1][address(arg2)].field_0:
            return 0
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 0
        if 0 == halvingPeriod:
            if 0 == halvingPeriod:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if block.number <= startBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == halvingPeriod:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if block.number <= startBlock:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / halvingPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if halvingPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == halvingPeriod:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 0 == halvingPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / halvingPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
        if 0 == halvingPeriod:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if block.number <= startBlock:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
            revert with 0, 'SafeMath: division by zero'
        require 2^(block.number + -startBlock - 1 / halvingPeriod)
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 0
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               0
    if not userInfo[arg1][address(arg2)].field_0:
        return 0
    require ext_code.size(multLpChefAddress)
    staticcall multLpChefAddress.0xe4c75c27 with:
            gas gas_remaining wei
           args poolCorrespond[arg1], this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_512 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if block.number <= poolInfo[arg1].field_512:
                if poolInfo[arg1].field_512 != block.number:
                    return 0
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 0 == halvingPeriod:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_512 <= startBlock:
                if 0 == halvingPeriod:
                    if 0 == halvingPeriod:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if block.number <= startBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 == halvingPeriod:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if block.number <= startBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require 2^(block.number + -startBlock - 1 / halvingPeriod)
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                idx = 0
                s = poolInfo[arg1].field_512
                while idx < block.number + -startBlock - 1 / halvingPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if startBlock > poolInfo[arg1].field_512:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > poolInfo[arg1].field_512 - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 0 == halvingPeriod:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
                else:
                    if block.number <= startBlock:
                        idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                        s = poolInfo[arg1].field_512
                        while idx < 0:
                            if not idx + 1:
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if halvingPeriod != 0:
                                    if startBlock > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                if s > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock - s:
                                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock
                                continue 
                            if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 == halvingPeriod:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock + halvingPeriod + (idx * halvingPeriod)
                            continue 
                    else:
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > block.number - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                        s = poolInfo[arg1].field_512
                        while idx < block.number + -startBlock - 1 / halvingPeriod:
                            if not idx + 1:
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if halvingPeriod != 0:
                                    if startBlock > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                if s > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock - s:
                                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock
                                continue 
                            if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 == halvingPeriod:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if halvingPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require halvingPeriod
                                    if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock + halvingPeriod + (idx * halvingPeriod)
                            continue 
            if 0 == halvingPeriod:
                if s > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - s:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if s > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - s:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_512 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 0 == halvingPeriod:
            if 0 == halvingPeriod:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == halvingPeriod:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / halvingPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if halvingPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == halvingPeriod:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 0 == halvingPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / halvingPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
        if 0 == halvingPeriod:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
            revert with 0, 'SafeMath: division by zero'
        require 2^(block.number + -startBlock - 1 / halvingPeriod)
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if poolInfo[arg1].field_1280 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require poolInfo[arg1].field_1280
    if (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_512 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if 0 == halvingPeriod:
            if 0 == halvingPeriod:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == halvingPeriod:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 == halvingPeriod:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require 2^(block.number + -startBlock - 1 / halvingPeriod)
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / halvingPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if halvingPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == halvingPeriod:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 0 == halvingPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / halvingPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if halvingPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == halvingPeriod:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if halvingPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require halvingPeriod
                                if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + halvingPeriod + (idx * halvingPeriod)
                        continue 
        if 0 == halvingPeriod:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
            revert with 0, 'SafeMath: division by zero'
        require 2^(block.number + -startBlock - 1 / halvingPeriod)
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               -userInfo[arg1][address(arg2)].field_512
    if (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userInfo[arg1][address(arg2)].field_512 > (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    if block.number <= poolInfo[arg1].field_512:
        if poolInfo[arg1].field_512 != block.number:
            return 0
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 0 == halvingPeriod:
        if 0 == halvingPeriod:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
            revert with 0, 'SafeMath: division by zero'
        require 2^(block.number + -startBlock - 1 / halvingPeriod)
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if poolInfo[arg1].field_512 <= startBlock:
        if 0 == halvingPeriod:
            if 0 == halvingPeriod:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if 0 == halvingPeriod:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) / block.number - poolInfo[arg1].field_512 != hCTPerBlock:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (poolInfo[arg1].field_512 * hCTPerBlock) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if halvingPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require halvingPeriod
            if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
                revert with 0, 'SafeMath: division by zero'
            require 2^(block.number + -startBlock - 1 / halvingPeriod)
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - poolInfo[arg1].field_512 != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        idx = 0
        s = poolInfo[arg1].field_512
        while idx < block.number + -startBlock - 1 / halvingPeriod:
            if not idx + 1:
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if halvingPeriod != 0:
                    if startBlock > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                if s > startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock - s:
                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock
                continue 
            if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if startBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if 0 == halvingPeriod:
                if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                        revert with 0, 'SafeMath: addition overflow'
            else:
                if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if halvingPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require halvingPeriod
                    if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                            revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = startBlock + halvingPeriod + (idx * halvingPeriod)
            continue 
    else:
        if startBlock > poolInfo[arg1].field_512:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > poolInfo[arg1].field_512 - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if halvingPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require halvingPeriod
        if 0 == halvingPeriod:
            idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
            s = poolInfo[arg1].field_512
            while idx < 0:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if halvingPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == halvingPeriod:
                    if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if halvingPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require halvingPeriod
                        if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + halvingPeriod + (idx * halvingPeriod)
                continue 
        else:
            if block.number <= startBlock:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
            else:
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if halvingPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require halvingPeriod
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / halvingPeriod
                s = poolInfo[arg1].field_512
                while idx < block.number + -startBlock - 1 / halvingPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if halvingPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) / startBlock - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if halvingPeriod + (idx * halvingPeriod) / idx + 1 != halvingPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == halvingPeriod:
                        if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + halvingPeriod + (idx * halvingPeriod) <= startBlock:
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock) + (halvingPeriod * hCTPerBlock) + (idx * halvingPeriod * hCTPerBlock) - (s * hCTPerBlock) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if halvingPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require halvingPeriod
                            if 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod) <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)
                            if s > startBlock + halvingPeriod + (idx * halvingPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + halvingPeriod + (idx * halvingPeriod) - s:
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) / startBlock + halvingPeriod + (idx * halvingPeriod) - s != hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod):
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) + (idx * halvingPeriod * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(halvingPeriod + (idx * halvingPeriod) - 1 / halvingPeriod)) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + halvingPeriod + (idx * halvingPeriod)
                    continue 
    if 0 == halvingPeriod:
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if block.number <= startBlock:
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) / block.number - s != hCTPerBlock:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * hCTPerBlock) - (s * hCTPerBlock) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * hCTPerBlock) - (s * hCTPerBlock):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / (block.number * hCTPerBlock) - (s * hCTPerBlock) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * hCTPerBlock * poolInfo[arg1].field_256) - (s * hCTPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if halvingPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require halvingPeriod
    if 2^(block.number + -startBlock - 1 / halvingPeriod) <= 0:
        revert with 0, 'SafeMath: division by zero'
    require 2^(block.number + -startBlock - 1 / halvingPeriod)
    if s > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - s:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) / block.number - s != hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)):
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod)) != poolInfo[arg1].field_256:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalAllocPoint
    if not (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint:
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if poolInfo[arg1].field_1280 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require poolInfo[arg1].field_1280
    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return ((10^12 * (block.number * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) - (s * hCTPerBlock / 2^(block.number + -startBlock - 1 / halvingPeriod) * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
}



}

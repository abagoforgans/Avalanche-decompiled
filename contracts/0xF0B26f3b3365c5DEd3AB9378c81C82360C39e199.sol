contract main {




// =====================  Runtime code  =====================


#
#  - sub_480738ad(?)
#
const name = '', 0

const decimals = 18

const symbol = '', 0


address owner;
uint256 totalSupply;
mapping of uint256 balanceOf;
mapping of struct allowance;
address nodeRewardManagementAddress;
address uniswapV2RouterAddress;
address uniswapV2PairAddress;
address deadWalletAddress;
uint256 rewardsFee;
uint256 liquidityPoolFee;
uint256 devFee;
uint256 burnFee;
uint256 totalFees;
uint256 sub_c733da3b;
uint256 sub_d92c842c;
uint256 sub_3705b392;
uint256 sub_c912cc46;
uint256 sub_18b9b19a;
uint256 sub_00afb325;
uint256 swapTokensAmount;
address uniV2RouterAddress;
address stor21;
address stor22;
address sub_e8b7a2b9Address;
address distributionPoolAddress;
address devPoolAddress;
address autoLiquidityReceiverAddress;
uint256 cashoutFee;
mapping of uint8 stor28;
uint256 stor29;
uint8 stor30;
uint8 stor30; offset 8
uint256 stor30; offset 8
uint256 startTime;
uint256 interval;
mapping of uint8 stor33;
mapping of uint8 stor34;
mapping of uint256 sub_6d29ab70;
mapping of uint256 sub_6d79210f;

function sub_00afb325(?) {
    return sub_00afb325
}

function totalFees() {
    return totalFees
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function totalSupply() {
    return totalSupply
}

function sub_18b9b19a(?) {
    return sub_18b9b19a
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor33[arg1])
}

function rewardsFee() {
    return rewardsFee
}

function sub_3705b392(?) {
    return sub_3705b392
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function liquidityPoolFee() {
    return liquidityPoolFee
}

function swapTokensAmount() {
    return swapTokensAmount
}

function devFee() {
    return devFee
}

function nodeRewardManagement() {
    return nodeRewardManagementAddress
}

function sub_6d29ab70(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_6d29ab70[arg1]
}

function sub_6d79210f(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_6d79210f[arg1]
}

function cashoutFee() {
    return cashoutFee
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function startTime() {
    return startTime
}

function deadWallet() {
    return deadWalletAddress
}

function getOwner() {
    return owner
}

function owner() {
    return owner
}

function interval() {
    return interval
}

function uniV2Router() {
    return uniV2RouterAddress
}

function devPool() {
    return devPoolAddress
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor34[arg1])
}

function distributionPool() {
    return distributionPoolAddress
}

function sub_c733da3b(?) {
    return sub_c733da3b
}

function sub_c912cc46(?) {
    return sub_c912cc46
}

function autoLiquidityReceiver() {
    return autoLiquidityReceiverAddress
}

function sub_d92c842c(?) {
    return sub_d92c842c
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)].field_0
}

function sub_e8b7a2b9(?) {
    return sub_e8b7a2b9Address
}

function burnFee() {
    return burnFee
}

function shouldTakeFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return not bool(stor28[address(arg1)])
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateInterval(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    interval = arg1
}

function updateSwapTokensAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapTokensAmount = arg1
}

function approveMax(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    allowance[msg.sender][address(arg1)].field_0 = -1
    emit Approval(-1, msg.sender, arg1);
    return 1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    allowance[msg.sender][address(arg1)].field_0 = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function changeSwapLiquify(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor30.field_8) = Mask(248, 0, arg1)
}

function blacklistMalicious(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor33[address(arg1)] = uint8(arg2)
}

function sub_231a1ce7(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    devPoolAddress = address(arg1)
    distributionPoolAddress = address(arg2)
}

function publiDistriRewards() {
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._distributeRewards() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
}

function recoverLostAVAX() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getTotalNodesCreated() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0xb8527aef with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getGasDistri() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.gasForDistribution() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getDistriCount() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.lastDistributionCount() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getTotalRewardStaked() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.totalRewardStaked() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_c1f96b3b(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0xea55e24e with:
         gas gas_remaining wei
        args arg1, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getAutoDistri() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.autoDistri() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    return bool(ext_call.return_data[0])
}

function changeGasDistri(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._changeGasDistri(uint256 arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_a52a8678(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x4e09a5f6 with:
         gas gas_remaining wei
        args uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_baf8879e(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x58e1cd45 with:
         gas gas_remaining wei
        args uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_ada1a6a8(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x9d3c20ba with:
            gas gas_remaining wei
           args msg.sender, uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function changeAutoDistri(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._changeAutoDistri(bool arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getNodeNumberOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getNodeNumberOf(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_4d2e5119(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x3add38de with:
            gas gas_remaining wei
           args arg1 << 248, balanceOf[address(msg.sender)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getCirculatingSupply() {
    if balanceOf[stor21] > totalSupply:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply < balanceOf[stor21]:
        revert with 0, 17
    if balanceOf[stor22] > totalSupply - balanceOf[stor21]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply - balanceOf[stor21] < balanceOf[stor22]:
        revert with 0, 17
    return (totalSupply - balanceOf[stor21] - balanceOf[stor22])
}

function sub_9922b4c9(?) {
    require calldata.size - 4 >= 224
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x9867ae29 with:
         gas gas_remaining wei
        args 0, 0, arg2, arg3, arg4, arg5, arg6, arg7
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function distributeRewards() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._distributeRewards() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    return ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64]
}

function sub_149d5660(?) {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x7c942fa6 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    require 191 < return_data.size + 160
    if not bool(ceil32(return_data.size) + 224 <= test266151307()):
        revert with 0, 65
    require 64 <= return_data.size
    return ext_call.return_data[0 len 64]
}

function sub_466f6311(?) {
    if balanceOf[address(msg.sender)] > !sub_6d29ab70[msg.sender]:
        revert with 0, 17
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x6591f30a with:
            gas gas_remaining wei
           args msg.sender, balanceOf[address(msg.sender)] + sub_6d29ab70[msg.sender]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getRewardAmountOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_5d7e9c2a(?) {
    require calldata.size - 4 >= 224
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3 and 10^18 > -1 / arg3:
        revert with 0, 17
    if arg5 and 10^18 > -1 / arg5:
        revert with 0, 17
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x9867ae29 with:
         gas gas_remaining wei
        args 0, 0, arg2, 10^18 * arg3, arg4, 10^18 * arg5, arg6, arg7
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updateFees(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6) {
    require calldata.size - 4 >= 192
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    burnFee = arg1
    rewardsFee = arg4
    liquidityPoolFee = arg2
    devFee = arg3
    cashoutFee = arg5
    stor29 = arg6
    if arg4 > !arg2:
        revert with 0, 17
    if arg4 + arg2 < arg4:
        revert with 0, 'SafeMath: addition overflow'
    if arg4 + arg2 > !arg3:
        revert with 0, 17
    if arg3 < 0:
        revert with 0, 'SafeMath: addition overflow'
    if arg4 + arg2 + arg3 > !arg1:
        revert with 0, 17
    if arg1 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = arg4 + arg2 + arg3 + arg1
}

function getRewardAmount() {
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'NO NODE OWNER'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor33[address(msg.sender)]:
        revert with 0, 'Blacklisted address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if balanceOf[address(arg1)] > !arg2:
        revert with 0, 17
    if balanceOf[address(arg1)] + arg2 < balanceOf[address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg1)] += arg2
    if arg2 > balanceOf[msg.sender]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if balanceOf[msg.sender] < arg2:
        revert with 0, 17
    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - arg2
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function sub_9725cd5b(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not this.address:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not owner:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor33[address(this.address)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor0]:
        revert with 0, 'Blacklisted address'
    if balanceOf[stor0] > !balanceOf[address(this.address)]:
        revert with 0, 17
    if balanceOf[stor0] + balanceOf[address(this.address)] < balanceOf[stor0]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[stor0] += balanceOf[address(this.address)]
    if balanceOf[address(this.address)] > balanceOf[this.address]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if balanceOf[this.address] < balanceOf[address(this.address)]:
        revert with 0, 17
    balanceOf[address(this.address)] = balanceOf[this.address] - balanceOf[address(this.address)]
    emit Transfer(balanceOf[address(this.address)], this.address, owner);
}

function swapTokensForEth(uint256 arg1) {
    require calldata.size - 4 >= 32
    mem[128] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WAVAX() with:
            gas gas_remaining wei
    mem[192] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    allowance[msg.sender][stor20].field_0 = arg1
    emit Approval(arg1, msg.sender, uniV2RouterAddress);
    mem[ceil32(return_data.size) + 192] = 0x762b156200000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = arg1
    idx = 0
    s = ceil32(return_data.size) + 388
    t = 128
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg1, 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_0406c49c(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require calldata.size > cd[4] + 35
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == uint8(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[36] == address(cd[36])
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _18 = mem[(32 * idx) + 128]
        mem[ceil32(32 * ('cd', 4).length) + 97] = 0x37696eec00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + 101] = address(cd[36])
        mem[ceil32(32 * ('cd', 4).length) + 133] = uint8(_18)
        require ext_code.size(nodeRewardManagementAddress)
        call nodeRewardManagementAddress.0x37696eec with:
             gas gas_remaining wei
            args address(cd[36]), uint8(_18)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function types() {
    mem[96] = 0xb2e853e300000000000000000000000000000000000000000000000000000000
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0xb2e853e3 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _4 = mem[96]
    require mem[96] <= test266151307()
    require return_data.size + 96 > mem[96] + 127
    _5 = mem[mem[96] + 96]
    if mem[mem[96] + 96] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[mem[96] + 96]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
    mem[ceil32(return_data.size) + 96] = _5
    require _4 + (32 * _5) + 32 <= return_data.size
    s = _4 + 128
    t = ceil32(return_data.size) + 128
    idx = 0
    while idx < _5:
        require mem[s] == mem[s + 31 len 1]
        mem[t] = mem[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    _13 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _5
    idx = 0
    s = mem[64] + 64
    t = ceil32(return_data.size) + 128
    while idx < _5:
        mem[s] = mem[t + 31 len 1]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len _13 + (32 * _5) + -mem[64] + 64
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if -1 == allowance[address(arg1)][msg.sender].field_0:
        if not arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
        if not arg2:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    else:
        if arg3 > allowance[address(arg1)][address(msg.sender)].field_0:
            revert with 0, 'Insufficient Allowance', 0
        if allowance[address(arg1)][address(msg.sender)].field_0 < arg3:
            revert with 0, 17
        allowance[address(arg1)][msg.sender].field_0 = allowance[address(arg1)][address(msg.sender)].field_0 - arg3
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not arg2:
            revert with 0, 'ERC20: transfer to the zero address'
    ('bool', ('param', 'arg2'))
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[address(arg2)]:
        revert with 0, 'Blacklisted address'
    if balanceOf[address(arg2)] > !arg3:
        revert with 0, 17
    if balanceOf[address(arg2)] + arg3 < balanceOf[address(arg2)]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg2)] += arg3
    if arg3 > balanceOf[arg1]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if balanceOf[arg1] < arg3:
        revert with 0, 17
    balanceOf[address(arg1)] = balanceOf[arg1] - arg3
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function swapAndLiquify(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 / 2 > arg1:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg1 < arg1 / 2:
        revert with 0, 17
    mem[256] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WAVAX() with:
            gas gas_remaining wei
    mem[320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[288] = ext_call.return_data[12 len 20]
    allowance[msg.sender][stor20].field_0 = arg1 / 2
    allowance[msg.sender][stor20].field_255 = 0
    emit Approval((arg1 / 2), msg.sender, uniV2RouterAddress);
    mem[ceil32(return_data.size) + 320] = 0x762b156200000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 324] = arg1 / 2
    idx = 0
    s = ceil32(return_data.size) + 516
    t = 256
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args Mask(255, 1, arg1), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 516 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if eth.balance(this.address) > eth.balance(this.address):
        revert with 0, 'SafeMath: subtraction overflow', 0
    if eth.balance(this.address) < eth.balance(this.address):
        revert with 0, 17
    allowance[msg.sender][stor20].field_0 = arg1 - (arg1 / 2)
    emit Approval((arg1 - (arg1 / 2)), msg.sender, uniV2RouterAddress);
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
         gas gas_remaining wei
        args this.address, arg1 - (arg1 / 2), 0, 0, 0, block.timestamp
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    emit SwapAndLiquify(Mask(255, 1, arg1), 0, arg1 - (arg1 / 2));
}

function takeBuyFee(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg2:
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not sub_e8b7a2b9Address:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[address(arg1)]:
            revert with 0, 'Blacklisted address'
        if stor33[stor23]:
            revert with 0, 'Blacklisted address'
        if balanceOf[stor23] > -1:
            revert with 0, 17
        if balanceOf[stor23] < balanceOf[stor23]:
            revert with 0, 'SafeMath: addition overflow'
        if 0 > balanceOf[arg1]:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if balanceOf[arg1] < 0:
            revert with 0, 17
        balanceOf[address(arg1)] = balanceOf[arg1]
        emit Transfer(0, arg1, sub_e8b7a2b9Address);
        if 0 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < 0:
            revert with 0, 17
        return arg2
    if arg2 and sub_3705b392 > -1 / arg2:
        revert with 0, 17
    if not arg2:
        revert with 0, 18
    if arg2 * sub_3705b392 / arg2 != sub_3705b392:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not arg1:
        revert with 0, 'ERC20: transfer from the zero address'
    if not sub_e8b7a2b9Address:
        revert with 0, 'ERC20: transfer to the zero address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor23]:
        revert with 0, 'Blacklisted address'
    if balanceOf[stor23] > !(arg2 * sub_3705b392 / 100):
        revert with 0, 17
    if balanceOf[stor23] + (arg2 * sub_3705b392 / 100) < balanceOf[stor23]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[stor23] += arg2 * sub_3705b392 / 100
    if arg2 * sub_3705b392 / 100 > balanceOf[arg1]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if balanceOf[arg1] < arg2 * sub_3705b392 / 100:
        revert with 0, 17
    balanceOf[address(arg1)] = balanceOf[arg1] - (arg2 * sub_3705b392 / 100)
    emit Transfer((arg2 * sub_3705b392 / 100), arg1, sub_e8b7a2b9Address);
    if arg2 * sub_3705b392 / 100 > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < arg2 * sub_3705b392 / 100:
        revert with 0, 17
    return (arg2 - (arg2 * sub_3705b392 / 100))
}

function takeSellFee(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg2:
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not sub_e8b7a2b9Address:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[address(arg1)]:
            revert with 0, 'Blacklisted address'
        if stor33[stor23]:
            revert with 0, 'Blacklisted address'
        if balanceOf[stor23] > -1:
            revert with 0, 17
        if balanceOf[stor23] < balanceOf[stor23]:
            revert with 0, 'SafeMath: addition overflow'
        if 0 > balanceOf[arg1]:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if balanceOf[arg1] < 0:
            revert with 0, 17
        balanceOf[address(arg1)] = balanceOf[arg1]
        emit Transfer(0, arg1, sub_e8b7a2b9Address);
        if 0 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < 0:
            revert with 0, 17
        return arg2
    if arg2 and sub_00afb325 > -1 / arg2:
        revert with 0, 17
    if not arg2:
        revert with 0, 18
    if arg2 * sub_00afb325 / arg2 != sub_00afb325:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not arg1:
        revert with 0, 'ERC20: transfer from the zero address'
    if not sub_e8b7a2b9Address:
        revert with 0, 'ERC20: transfer to the zero address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor23]:
        revert with 0, 'Blacklisted address'
    if balanceOf[stor23] > !(arg2 * sub_00afb325 / 100):
        revert with 0, 17
    if balanceOf[stor23] + (arg2 * sub_00afb325 / 100) < balanceOf[stor23]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[stor23] += arg2 * sub_00afb325 / 100
    if arg2 * sub_00afb325 / 100 > balanceOf[arg1]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if balanceOf[arg1] < arg2 * sub_00afb325 / 100:
        revert with 0, 17
    balanceOf[address(arg1)] = balanceOf[arg1] - (arg2 * sub_00afb325 / 100)
    emit Transfer((arg2 * sub_00afb325 / 100), arg1, sub_e8b7a2b9Address);
    if arg2 * sub_00afb325 / 100 > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < arg2 * sub_00afb325 / 100:
        revert with 0, 17
    return (arg2 - (arg2 * sub_00afb325 / 100))
}

function cashoutAll() {
    require not stor33[msg.sender]
    mem[100] = msg.sender
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] > 0
    if not uint8(stor30.field_8):
        if not distributionPoolAddress:
            revert with 0, 'ERC20: transfer from the zero address'
        if not msg.sender:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[stor24]:
            revert with 0, 'Blacklisted address'
        if stor33[address(msg.sender)]:
            revert with 0, 'Blacklisted address'
        if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
            revert with 0, 17
        if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
            revert with 0, 'SafeMath: addition overflow'
        balanceOf[address(msg.sender)] += ext_call.return_data[0]
        if ext_call.return_data[0] > balanceOf[stor24]:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if balanceOf[stor24] < ext_call.return_data[0]:
            revert with 0, 17
        balanceOf[stor24] -= ext_call.return_data[0]
        emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
    else:
        if not cashoutFee:
            if ext_call.return_data[0] < 0:
                revert with 0, 17
            if not distributionPoolAddress:
                revert with 0, 'ERC20: transfer from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: transfer to the zero address'
            if stor33[stor24]:
                revert with 0, 'Blacklisted address'
            if stor33[address(msg.sender)]:
                revert with 0, 'Blacklisted address'
            if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
                revert with 0, 17
            if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(msg.sender)] += ext_call.return_data[0]
            if ext_call.return_data[0] > balanceOf[stor24]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if balanceOf[stor24] < ext_call.return_data[0]:
                revert with 0, 17
            balanceOf[stor24] -= ext_call.return_data[0]
            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
        else:
            if not ext_call.return_data[0]:
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                mem[ceil32(return_data.size) + 160] = 2
                mem[ceil32(return_data.size) + 192] = this.address
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.WAVAX() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 256
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                mem[0] = uniV2RouterAddress
                mem[32] = sha3(msg.sender, 3)
                allowance[msg.sender][stor20].field_0 = 0
                mem[(2 * ceil32(return_data.size)) + 256] = 0
                emit Approval(mem[(2 * ceil32(return_data.size)) + 256 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                mem[(2 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 260] = 0
                mem[(2 * ceil32(return_data.size)) + 292] = 0
                mem[(2 * ceil32(return_data.size)) + 324] = 160
                mem[(2 * ceil32(return_data.size)) + 420] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 452
                t = ceil32(return_data.size) + 192
                while idx < mem[ceil32(return_data.size) + 160]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 356] = this.address
                mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 512]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call devPoolAddress with:
                     gas 30000 wei
                if ext_call.return_data[0] < 0:
                    revert with 0, 17
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[stor24]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(msg.sender)]:
                    revert with 0, 'Blacklisted address'
                if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
                    revert with 0, 17
                if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] += ext_call.return_data[0]
                if ext_call.return_data[0] > balanceOf[stor24]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if balanceOf[stor24] < ext_call.return_data[0]:
                    revert with 0, 17
                balanceOf[stor24] -= ext_call.return_data[0]
                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
            else:
                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                mem[ceil32(return_data.size) + 160] = 2
                mem[ceil32(return_data.size) + 192] = this.address
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.WAVAX() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 256
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                mem[0] = uniV2RouterAddress
                mem[32] = sha3(msg.sender, 3)
                allowance[msg.sender][stor20].field_0 = ext_call.return_data[0] * cashoutFee / 100
                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0] * cashoutFee / 100
                emit Approval(mem[(2 * ceil32(return_data.size)) + 256 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                mem[(2 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 260] = ext_call.return_data[0] * cashoutFee / 100
                mem[(2 * ceil32(return_data.size)) + 292] = 0
                mem[(2 * ceil32(return_data.size)) + 324] = 160
                mem[(2 * ceil32(return_data.size)) + 420] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 452
                t = ceil32(return_data.size) + 192
                while idx < mem[ceil32(return_data.size) + 160]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 356] = this.address
                mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 512]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call devPoolAddress with:
                     gas 30000 wei
                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                    revert with 0, 17
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[stor24]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(msg.sender)]:
                    revert with 0, 'Blacklisted address'
                if balanceOf[address(msg.sender)] > !(ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)):
                    revert with 0, 17
                if balanceOf[address(msg.sender)] + ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100) < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] + ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                if ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100) > balanceOf[stor24]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if balanceOf[stor24] < ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100):
                    revert with 0, 17
                balanceOf[stor24] = balanceOf[stor24] - ext_call.return_data[0] + (ext_call.return_data[0] * cashoutFee / 100)
                emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)), distributionPoolAddress, msg.sender);
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._cashoutAllNodesReward(address arg1) with:
         gas gas_remaining wei
        args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
    else:
        if unknown_0x77c0ef1d(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xb96392c1(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x9725cd5b(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x893d20e8(?????) <= uint32(call.func_hash) >> 224:
                        if unknown_0x893d20e8(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        if unknown_0x947a36fb(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return interval
                        if unknown_0x958c2e52(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return uniV2RouterAddress
                        require unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return '', 0
                    if uint32(call.func_hash) >> 224 != unknown_0x77c0ef1d(?????):
                        if unknown_0x78e97925(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return startTime
                        if unknown_0x823349b3(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.0xb8527aef with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if unknown_0x85141a77(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return deadWalletAddress
                        require unknown_0x8743ef6d(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress._distributeRewards() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if not cd[36]:
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not sub_e8b7a2b9Address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(cd[4])]:
                            revert with 0, 'Blacklisted address'
                        if stor33[stor23]:
                            revert with 0, 'Blacklisted address'
                        if balanceOf[stor23] > -1:
                            revert with 0, 17
                        if balanceOf[stor23] < balanceOf[stor23]:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 > balanceOf[address(cd[4])]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if balanceOf[address(cd[4])] < 0:
                            revert with 0, 17
                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])]
                        emit Transfer(0, address(cd[4]), sub_e8b7a2b9Address);
                        if 0 > cd[36]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if cd[36] < 0:
                            revert with 0, 17
                        return cd[36]
                    if cd[36] and sub_3705b392 > -1 / cd[36]:
                        revert with 0, 17
                    if not cd[36]:
                        revert with 0, 18
                    if cd[36] * sub_3705b392 / cd[36] != sub_3705b392:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not address(cd[4]):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not sub_e8b7a2b9Address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if stor33[address(cd[4])]:
                        revert with 0, 'Blacklisted address'
                    if stor33[stor23]:
                        revert with 0, 'Blacklisted address'
                    if balanceOf[stor23] > !(cd[36] * sub_3705b392 / 100):
                        revert with 0, 17
                    if balanceOf[stor23] + (cd[36] * sub_3705b392 / 100) < balanceOf[stor23]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[stor23] += cd[36] * sub_3705b392 / 100
                    if cd[36] * sub_3705b392 / 100 > balanceOf[address(cd[4])]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if balanceOf[address(cd[4])] < cd[36] * sub_3705b392 / 100:
                        revert with 0, 17
                    balanceOf[address(cd[4])] -= cd[36] * sub_3705b392 / 100
                    emit Transfer((cd[36] * sub_3705b392 / 100), address(cd[4]), sub_e8b7a2b9Address);
                    if cd[36] * sub_3705b392 / 100 > cd[36]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if cd[36] < cd[36] * sub_3705b392 / 100:
                        revert with 0, 17
                    return (cd[36] - (cd[36] * sub_3705b392 / 100))
                if unknown_0xa9059cbb(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x9725cd5b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not this.address:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not owner:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(this.address)]:
                            revert with 0, 'Blacklisted address'
                        if stor33[stor0]:
                            revert with 0, 'Blacklisted address'
                        if balanceOf[stor0] > !balanceOf[address(this.address)]:
                            revert with 0, 17
                        if balanceOf[stor0] + balanceOf[address(this.address)] < balanceOf[stor0]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[stor0] += balanceOf[address(this.address)]
                        if balanceOf[address(this.address)] > balanceOf[this.address]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if balanceOf[this.address] < balanceOf[address(this.address)]:
                            revert with 0, 17
                        balanceOf[address(this.address)] = balanceOf[this.address] - balanceOf[address(this.address)]
                        emit Transfer(balanceOf[address(this.address)], this.address, owner);
                    else:
                        if unknown_0x9922b4c9(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 224
                            require cd[4] == uint8(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x9867ae29 with:
                                 gas gas_remaining wei
                                args 0, 0, cd[36], cd[68], cd[100], cd[132], cd[164], cd[196]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x992c58e4(?????):
                                if uint32(call.func_hash) >> 224 != unknown_0xa52a8678(?????):
                                    require unknown_0xa647c9ff(?????) == uint32(call.func_hash) >> 224
                                    require not msg.value
                                    if owner != msg.sender:
                                        revert with 0, 'Ownable: caller is not the owner'
                                    call msg.sender with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    require not msg.value
                                    require calldata.size - 4 >= 32
                                    require cd[4] == uint8(cd[4])
                                    if owner != msg.sender:
                                        revert with 0, 'Ownable: caller is not the owner'
                                    require ext_code.size(nodeRewardManagementAddress)
                                    call nodeRewardManagementAddress.0x4e09a5f6 with:
                                         gas gas_remaining wei
                                        args uint8(cd[4])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require not msg.value
                                require calldata.size - 4 >= 192
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                burnFee = cd[4]
                                rewardsFee = cd[100]
                                liquidityPoolFee = cd[36]
                                devFee = cd[68]
                                cashoutFee = cd[132]
                                stor29 = cd[164]
                                if cd[100] > !cd[36]:
                                    revert with 0, 17
                                if cd[100] + cd[36] < cd[100]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if cd[100] + cd[36] > !cd[68]:
                                    revert with 0, 17
                                if cd[68] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if cd[100] + cd[36] + cd[68] > !cd[4]:
                                    revert with 0, 17
                                if cd[4] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees = cd[100] + cd[36] + cd[68] + cd[4]
                else:
                    if unknown_0xa9059cbb(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(msg.sender)]:
                            revert with 0, 'Blacklisted address'
                        if stor33[address(cd[4])]:
                            revert with 0, 'Blacklisted address'
                        if balanceOf[address(cd[4])] > !cd[36]:
                            revert with 0, 17
                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[4])] += cd[36]
                        if cd[36] > balanceOf[msg.sender]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if balanceOf[msg.sender] < cd[36]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - cd[36]
                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                        return 1
                    if unknown_0xada1a6a8(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == uint8(cd[4])
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.0x9d3c20ba with:
                                gas gas_remaining wei
                               args msg.sender, uint8(cd[4])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if uint32(call.func_hash) >> 224 != unknown_0xb28805f4(?????):
                        if unknown_0xb5838a27(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return devPoolAddress
                        require unknown_0xb62496f5(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return bool(stor34[cd[4]])
                    require not msg.value
                    require calldata.size - 4 >= 32
                    mem[160] = this.address
                    require ext_code.size(uniswapV2RouterAddress)
                    staticcall uniswapV2RouterAddress.WAVAX() with:
                            gas gas_remaining wei
                    mem[224] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[192] = ext_call.return_data[12 len 20]
                    allowance[msg.sender][stor20].field_0 = cd[4]
                    emit Approval(cd[4], msg.sender, uniV2RouterAddress);
                    mem[ceil32(return_data.size) + 224] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(return_data.size) + 228] = cd[4]
                    idx = 0
                    s = ceil32(return_data.size) + 420
                    t = 160
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[4], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 420 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            if unknown_0xd8929342(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xe8b7a2b9(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0xd8929342(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == bool(cd[36])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        stor33[address(cd[4])] = uint8(bool(cd[36]))
                    if unknown_0xd92c842c(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_d92c842c
                    if unknown_0xda41b333(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.lastDistributionCount() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == address(cd[36])
                        return allowance[address(cd[4])][address(cd[36])].field_0
                    require unknown_0xe7c44c69(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return not bool(stor28[address(cd[4])])
                if unknown_0xe8b7a2b9(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_e8b7a2b9Address
                if unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not address(cd[4]):
                        revert with 0, 'Ownable: new owner is the zero address'
                    emit OwnershipTransferred(owner, address(cd[4]));
                    owner = address(cd[4])
                if unknown_0xf74c9934(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0xf7b9f943(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress.gasForDistribution() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if uint32(call.func_hash) >> 224 != unknown_0xf9afc763(?????):
                    require unknown_0xfce589d8(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    return burnFee
                require not msg.value
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress.autoDistri() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                return bool(ext_call.return_data[0])
            if unknown_0xc912cc46(?????) > uint32(call.func_hash) >> 224:
                if unknown_0xb96392c1(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0xbaf8879e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == uint8(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress.0x58e1cd45 with:
                         gas gas_remaining wei
                        args uint8(cd[4])
                else:
                    if uint32(call.func_hash) >> 224 != unknown_0xc1f96b3b(?????):
                        if unknown_0xc5ca7d6d(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return distributionPoolAddress
                        require unknown_0xc733da3b(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return sub_c733da3b
                    require not msg.value
                    require calldata.size - 4 >= 64
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress.0xea55e24e with:
                         gas gas_remaining wei
                        args cd[4], cd[36]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if unknown_0xc912cc46(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_c912cc46
            if unknown_0xca33e64c(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return autoLiquidityReceiverAddress
            if uint32(call.func_hash) >> 224 != unknown_0xccbff979(?????):
                if unknown_0xd0f07926(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    interval = cd[4]
                else:
                    require unknown_0xd0f77474(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == bool(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress._changeAutoDistri(bool arg1) with:
                         gas gas_remaining wei
                        args bool(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            require not msg.value
            mem[128] = 0xb2e853e300000000000000000000000000000000000000000000000000000000
            require ext_code.size(nodeRewardManagementAddress)
            staticcall nodeRewardManagementAddress.0xb2e853e3 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _124 = mem[128]
            require mem[128] <= test266151307()
            require return_data.size + 128 > mem[128] + 159
            _178 = mem[mem[128] + 128]
            if mem[mem[128] + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[mem[128] + 128]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129
            mem[ceil32(return_data.size) + 128] = mem[mem[128] + 128]
            require _124 + (32 * _178) + 32 <= return_data.size
            s = _124 + 160
            t = ceil32(return_data.size) + 160
            idx = 0
            while idx < _178:
                require mem[s] == mem[s + 31 len 1]
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx + 1
                continue 
            _3555 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _178
            idx = 0
            s = mem[64] + 64
            t = ceil32(return_data.size) + 160
            while idx < _178:
                mem[s] = mem[t + 31 len 1]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _3555 + (32 * _178) + -mem[64] + 64
        if unknown_0x480738ad(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x18160ddd(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x2b112e49(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x2b112e49(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if balanceOf[stor21] > totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if totalSupply < balanceOf[stor21]:
                            revert with 0, 17
                        if balanceOf[stor22] > totalSupply - balanceOf[stor21]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if totalSupply - balanceOf[stor21] < balanceOf[stor22]:
                            revert with 0, 17
                        return (totalSupply - balanceOf[stor21] - balanceOf[stor22])
                    if unknown_0x2bb14e1d(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return rewardsFee
                    if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return 18
                    if unknown_0x3705b392(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_3705b392
                    require unknown_0x466f6311(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    if balanceOf[address(msg.sender)] > !sub_6d29ab70[msg.sender]:
                        revert with 0, 17
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress.0x6591f30a with:
                            gas gas_remaining wei
                           args msg.sender, balanceOf[address(msg.sender)] + sub_6d29ab70[msg.sender]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return totalSupply
                if unknown_0x18b9b19a(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_18b9b19a
                if unknown_0x1cdd3be3(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return bool(stor33[cd[4]])
                if unknown_0x231a1ce7(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == address(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    devPoolAddress = address(cd[4])
                    distributionPoolAddress = address(cd[36])
                require unknown_0x23b872dd(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 96
                require cd[4] == address(cd[4])
                require cd[36] == address(cd[36])
                if allowance[address(cd[4])][msg.sender].field_0 != -1:
                    if cd[68] > allowance[address(cd[4])][address(msg.sender)].field_0:
                        revert with 0, 'Insufficient Allowance', 0
                    if allowance[address(cd[4])][address(msg.sender)].field_0 < cd[68]:
                        revert with 0, 17
                    allowance[address(cd[4])][msg.sender].field_0 = allowance[address(cd[4])][address(msg.sender)].field_0 - cd[68]
                if not address(cd[4]):
                    revert with 0, 'ERC20: transfer from the zero address'
                if not address(cd[36]):
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[address(cd[4])]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(cd[36])]:
                    revert with 0, 'Blacklisted address'
                if balanceOf[address(cd[36])] > !cd[68]:
                    revert with 0, 17
                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(cd[36])] += cd[68]
                if cd[68] > balanceOf[address(cd[4])]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if balanceOf[address(cd[4])] < cd[68]:
                    revert with 0, 17
                balanceOf[address(cd[4])] -= cd[68]
                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                return 1
            if unknown_0x13114a9d(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x00afb325(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_00afb325
                if unknown_0x0406c49c(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] <= test266151307()
                    require calldata.size > cd[4] + 35
                    if ('cd', 4).length > test266151307():
                        revert with 0, 65
                    if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                        revert with 0, 65
                    mem[128] = ('cd', 4).length
                    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                    s = cd[4] + 36
                    t = 160
                    idx = 0
                    while idx < ('cd', 4).length:
                        require cd[s] == uint8(cd[s])
                        mem[t] = cd[s]
                        s = s + 32
                        t = t + 32
                        idx = idx + 1
                        continue 
                    require cd[36] == address(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= mem[128]:
                            revert with 0, 50
                        _9975 = mem[(32 * idx) + 160]
                        mem[ceil32(32 * ('cd', 4).length) + 129] = 0x37696eec00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * ('cd', 4).length) + 133] = address(cd[36])
                        mem[ceil32(32 * ('cd', 4).length) + 165] = uint8(_9975)
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress.0x37696eec with:
                             gas gas_remaining wei
                            args address(cd[36]), uint8(_9975)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                if name() == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return '', 0
                if approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    allowance[msg.sender][address(cd[4])].field_0 = cd[36]
                    emit Approval(cd[36], msg.sender, address(cd[4]));
                    return 1
                require getRewardAmount() == uint32(call.func_hash) >> 224
                require not msg.value
                if not msg.sender:
                    revert with 0, 'SENDER CAN'T BE ZERO'
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                return ext_call.return_data[0]
            if unknown_0x13114a9d(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return totalFees
            if unknown_0x144236d3(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if not cd[36]:
                    if not address(cd[4]):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not sub_e8b7a2b9Address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if stor33[address(cd[4])]:
                        revert with 0, 'Blacklisted address'
                    if stor33[stor23]:
                        revert with 0, 'Blacklisted address'
                    if balanceOf[stor23] > -1:
                        revert with 0, 17
                    if balanceOf[stor23] < balanceOf[stor23]:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 > balanceOf[address(cd[4])]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if balanceOf[address(cd[4])] < 0:
                        revert with 0, 17
                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])]
                    emit Transfer(0, address(cd[4]), sub_e8b7a2b9Address);
                    if 0 > cd[36]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if cd[36] < 0:
                        revert with 0, 17
                    return cd[36]
                if cd[36] and sub_00afb325 > -1 / cd[36]:
                    revert with 0, 17
                if not cd[36]:
                    revert with 0, 18
                if cd[36] * sub_00afb325 / cd[36] != sub_00afb325:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not address(cd[4]):
                    revert with 0, 'ERC20: transfer from the zero address'
                if not sub_e8b7a2b9Address:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[address(cd[4])]:
                    revert with 0, 'Blacklisted address'
                if stor33[stor23]:
                    revert with 0, 'Blacklisted address'
                if balanceOf[stor23] > !(cd[36] * sub_00afb325 / 100):
                    revert with 0, 17
                if balanceOf[stor23] + (cd[36] * sub_00afb325 / 100) < balanceOf[stor23]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[stor23] += cd[36] * sub_00afb325 / 100
                if cd[36] * sub_00afb325 / 100 > balanceOf[address(cd[4])]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if balanceOf[address(cd[4])] < cd[36] * sub_00afb325 / 100:
                    revert with 0, 17
                balanceOf[address(cd[4])] -= cd[36] * sub_00afb325 / 100
                emit Transfer((cd[36] * sub_00afb325 / 100), address(cd[4]), sub_e8b7a2b9Address);
                if cd[36] * sub_00afb325 / 100 > cd[36]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if cd[36] < cd[36] * sub_00afb325 / 100:
                    revert with 0, 17
                return (cd[36] - (cd[36] * sub_00afb325 / 100))
            if unknown_0x149d5660(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress.0x7c942fa6 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                require 223 < return_data.size + 192
                if not bool(ceil32(return_data.size) + 256 <= test266151307()):
                    revert with 0, 65
                require 64 <= return_data.size
                return ext_call.return_data[0 len 64]
            if unknown_0x1694505e(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return uniswapV2RouterAddress
            require unknown_0x173865ad(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 32
            if cd[4] / 2 > cd[4]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if cd[4] < cd[4] / 2:
                revert with 0, 17
            mem[288] = this.address
            require ext_code.size(uniswapV2RouterAddress)
            staticcall uniswapV2RouterAddress.WAVAX() with:
                    gas gas_remaining wei
            mem[352] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[320] = ext_call.return_data[12 len 20]
            allowance[msg.sender][stor20].field_0 = cd[4] / 2
            allowance[msg.sender][stor20].field_255 = 0
            emit Approval((cd[4] / 2), msg.sender, uniV2RouterAddress);
            mem[ceil32(return_data.size) + 352] = 0x762b156200000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 356] = cd[4] / 2
            idx = 0
            s = ceil32(return_data.size) + 548
            t = 288
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(uniswapV2RouterAddress)
            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args Mask(255, 1, cd[4]), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 548 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if eth.balance(this.address) > eth.balance(this.address):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if eth.balance(this.address) < eth.balance(this.address):
                revert with 0, 17
            allowance[msg.sender][stor20].field_0 = cd[4] - (cd[4] / 2)
            emit Approval((cd[4] - (cd[4] / 2)), msg.sender, uniV2RouterAddress);
            require ext_code.size(uniswapV2RouterAddress)
            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                 gas gas_remaining wei
                args this.address, cd[4] - (cd[4] / 2), 0, 0, 0, block.timestamp
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            emit SwapAndLiquify(Mask(255, 1, cd[4]), 0, cd[4] - (cd[4] / 2));
        else:
            if unknown_0x5f1c3182(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x6d79210f(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x5f1c3182(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return swapTokensAmount
                    if unknown_0x6770474b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        swapTokensAmount = cd[4]
                    if unknown_0x6827e764(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return devFee
                    if unknown_0x697e2f8e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return nodeRewardManagementAddress
                    require unknown_0x6d29ab70(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return sub_6d29ab70[cd[4]]
                if unknown_0x6d79210f(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return sub_6d79210f[cd[4]]
                if unknown_0x6d9ae0be(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return cashoutFee
                if unknown_0x6f4a2cd0(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress._distributeRewards() with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    return ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64]
                if unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return balanceOf[address(cd[4])]
                require unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                emit OwnershipTransferred(owner, 0);
                owner = 0
            else:
                if unknown_0x54f12f1f(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x54f12f1f(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return liquidityPoolFee
                    if unknown_0x571ac8b0(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        allowance[msg.sender][address(cd[4])].field_0 = -1
                        emit Approval(-1, msg.sender, address(cd[4]));
                        return 1
                    if unknown_0x583bd7a6(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == bool(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        Mask(248, 0, stor30.field_8) = Mask(248, 0, bool(cd[4]))
                    else:
                        if unknown_0x59640ed9(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress._changeGasDistri(uint256 arg1) with:
                                 gas gas_remaining wei
                                args cd[4]
                        else:
                            require unknown_0x5d7e9c2a(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 224
                            require cd[4] == uint8(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if cd[68] and 10^18 > -1 / cd[68]:
                                revert with 0, 17
                            if cd[132] and 10^18 > -1 / cd[132]:
                                revert with 0, 17
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x9867ae29 with:
                                 gas gas_remaining wei
                                args 0, 0, cd[36], 10^18 * cd[68], cd[100], 10^18 * cd[132], cd[164], cd[196]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    if uint32(call.func_hash) >> 224 != unknown_0x480738ad(?????):
                        if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return uniswapV2PairAddress
                        if unknown_0x4d2e5119(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == uint8(cd[4])
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.0x3add38de with:
                                    gas gas_remaining wei
                                   args cd[4] << 248, balanceOf[address(msg.sender)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if unknown_0x4dc9b819(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.totalRewardStaked() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        require unknown_0x54557973(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require not stor33[msg.sender]
                        mem[132] = msg.sender
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] > 0
                        if not uint8(stor30.field_8):
                            if not distributionPoolAddress:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if stor33[stor24]:
                                revert with 0, 'Blacklisted address'
                            if stor33[address(msg.sender)]:
                                revert with 0, 'Blacklisted address'
                            if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(msg.sender)] += ext_call.return_data[0]
                            if ext_call.return_data[0] > balanceOf[stor24]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if balanceOf[stor24] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[stor24] -= ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if stor33[stor24]:
                                    revert with 0, 'Blacklisted address'
                                if stor33[address(msg.sender)]:
                                    revert with 0, 'Blacklisted address'
                                if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += ext_call.return_data[0]
                                if ext_call.return_data[0] > balanceOf[stor24]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[stor24] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[stor24] -= ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(return_data.size) + 128] = 26
                                    mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    mem[ceil32(return_data.size) + 192] = 2
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[0] = uniV2RouterAddress
                                    mem[32] = sha3(msg.sender, 3)
                                    allowance[msg.sender][stor20].field_0 = 0
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 0
                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 484
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call devPoolAddress with:
                                         gas 30000 wei
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[stor24]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    if balanceOf[address(msg.sender)] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)] + ext_call.return_data[0] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += ext_call.return_data[0]
                                    if ext_call.return_data[0] > balanceOf[stor24]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[stor24] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[stor24] -= ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(return_data.size) + 128] = 26
                                    mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    mem[ceil32(return_data.size) + 192] = 2
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[0] = uniV2RouterAddress
                                    mem[32] = sha3(msg.sender, 3)
                                    allowance[msg.sender][stor20].field_0 = ext_call.return_data[0] * cashoutFee / 100
                                    mem[(2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0] * cashoutFee / 100
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 484
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call devPoolAddress with:
                                         gas 30000 wei
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[stor24]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    if balanceOf[address(msg.sender)] > !(ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)):
                                        revert with 0, 17
                                    if balanceOf[address(msg.sender)] + ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100) < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] + ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    if ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100) > balanceOf[stor24]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[stor24] < ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100):
                                        revert with 0, 17
                                    balanceOf[stor24] = balanceOf[stor24] - ext_call.return_data[0] + (ext_call.return_data[0] * cashoutFee / 100)
                                    emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)), distributionPoolAddress, msg.sender);
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == uint8(cd[4])
                        require not stor33[msg.sender]
                        require devPoolAddress != msg.sender
                        require distributionPoolAddress != msg.sender
                        mem[132] = uint8(cd[4])
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.0xd04375ed with:
                                gas gas_remaining wei
                               args uint8(cd[4])
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require balanceOf[address(msg.sender)] >= ext_call.return_data[0]
                        if balanceOf[address(this.address)] < swapTokensAmount:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if stor33[address(msg.sender)]:
                                revert with 0, 'Blacklisted address'
                            if stor33[address(this.address)]:
                                revert with 0, 'Blacklisted address'
                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] += ext_call.return_data[0]
                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x37696eec with:
                                 gas gas_remaining wei
                                args msg.sender, uint8(cd[4])
                        else:
                            if not uint8(stor30.field_8):
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if stor33[address(msg.sender)]:
                                    revert with 0, 'Blacklisted address'
                                if stor33[address(this.address)]:
                                    revert with 0, 'Blacklisted address'
                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                require ext_code.size(nodeRewardManagementAddress)
                                call nodeRewardManagementAddress.0x37696eec with:
                                     gas gas_remaining wei
                                    args msg.sender, uint8(cd[4])
                            else:
                                if uint8(stor30.field_0):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(this.address)]:
                                        revert with 0, 'Blacklisted address'
                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    require ext_code.size(nodeRewardManagementAddress)
                                    call nodeRewardManagementAddress.0x37696eec with:
                                         gas gas_remaining wei
                                        args msg.sender, uint8(cd[4])
                                else:
                                    if owner == msg.sender:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if stor33[address(msg.sender)]:
                                            revert with 0, 'Blacklisted address'
                                        if stor33[address(this.address)]:
                                            revert with 0, 'Blacklisted address'
                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                            revert with 0, 17
                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                        require ext_code.size(nodeRewardManagementAddress)
                                        call nodeRewardManagementAddress.0x37696eec with:
                                             gas gas_remaining wei
                                            args msg.sender, uint8(cd[4])
                                    else:
                                        if uniswapV2PairAddress == msg.sender:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if stor33[address(msg.sender)]:
                                                revert with 0, 'Blacklisted address'
                                            if stor33[address(this.address)]:
                                                revert with 0, 'Blacklisted address'
                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            require ext_code.size(nodeRewardManagementAddress)
                                            call nodeRewardManagementAddress.0x37696eec with:
                                                 gas gas_remaining wei
                                                args msg.sender, uint8(cd[4])
                                        else:
                                            uint8(stor30.field_0) = 1
                                            if not swapTokensAmount:
                                                mem[ceil32(return_data.size) + 128] = 26
                                                mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if not swapTokensAmount:
                                                    mem[ceil32(return_data.size) + 192] = 26
                                                    mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not deadWalletAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[stor7]:
                                                        revert with 0, 'Blacklisted address'
                                                    if balanceOf[stor7] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[stor7] < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[ceil32(return_data.size) + 256] = 30
                                                    mem[ceil32(return_data.size) + 288] = 'SafeMath: subtraction overflow'
                                                    if 0 > balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] < 0:
                                                        revert with 0, 17
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, this.address, deadWalletAddress);
                                                    if not swapTokensAmount:
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 384] = 26
                                                        mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 448] = 30
                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor24]:
                                                            revert with 0, 'Blacklisted address'
                                                        if balanceOf[stor24] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[stor24] < balanceOf[stor24]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[ceil32(return_data.size) + 512] = 30
                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                        if 0 > balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] < 0:
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, this.address, distributionPoolAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 576] = 26
                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 640] = 2
                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                            mem[0] = uniV2RouterAddress
                                                            mem[32] = sha3(msg.sender, 3)
                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                            idx = 0
                                                            s = (2 * ceil32(return_data.size)) + 932
                                                            t = ceil32(return_data.size) + 672
                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                        else:
                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 576] = 26
                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                mem[ceil32(return_data.size) + 640] = 26
                                                                mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 704] = 30
                                                                mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[ceil32(return_data.size) + 768] = 2
                                                                mem[ceil32(return_data.size) + 800] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 1060
                                                                t = ceil32(return_data.size) + 800
                                                                while idx < mem[ceil32(return_data.size) + 768]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _3649 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_3649] = 30
                                                                mem[_3649 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                _4718 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_4718 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_4718]:
                                                                    revert with 0, 50
                                                                mem[_4718 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_4718 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _4718 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_4718]:
                                                                    revert with 0, 50
                                                                mem[_4718 + 64] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                mem[_4718 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_4718 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                mem[_4718 + ceil32(return_data.size) + 132] = 0
                                                                mem[_4718 + ceil32(return_data.size) + 164] = 160
                                                                mem[_4718 + ceil32(return_data.size) + 260] = mem[_4718]
                                                                idx = 0
                                                                s = _4718 + ceil32(return_data.size) + 292
                                                                t = _4718 + 32
                                                                while idx < mem[_4718]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_4718 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_4718 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _4718 + ceil32(return_data.size) + (32 * mem[_4718]) + -mem[64] + 288]
                                                    else:
                                                        if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        if not swapTokensAmount * rewardsFee / 100:
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 448] = 30
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            if 0 > swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if swapTokensAmount * rewardsFee / 100 < 0:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                            mem[ceil32(return_data.size) + 512] = 30
                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                            if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                            emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 640] = 26
                                                                    mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 704] = 30
                                                                    mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 768] = 2
                                                                    mem[ceil32(return_data.size) + 800] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 1060
                                                                    t = ceil32(return_data.size) + 800
                                                                    while idx < mem[ceil32(return_data.size) + 768]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _3648 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_3648] = 30
                                                                    mem[_3648 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4716 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4716 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4716]:
                                                                        revert with 0, 50
                                                                    mem[_4716 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4716 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4716 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4716]:
                                                                        revert with 0, 50
                                                                    mem[_4716 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4716 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4716 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4716 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4716 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4716 + ceil32(return_data.size) + 260] = mem[_4716]
                                                                    idx = 0
                                                                    s = _4716 + ceil32(return_data.size) + 292
                                                                    t = _4716 + 32
                                                                    while idx < mem[_4716]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_4716 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_4716 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _4716 + ceil32(return_data.size) + (32 * mem[_4716]) + -mem[64] + 288]
                                                        else:
                                                            if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                mem[ceil32(return_data.size) + 448] = 30
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                mem[ceil32(return_data.size) + 512] = 30
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 640] = 26
                                                                        mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 704] = 30
                                                                        mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 768] = 2
                                                                        mem[ceil32(return_data.size) + 800] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 1060
                                                                        t = ceil32(return_data.size) + 800
                                                                        while idx < mem[ceil32(return_data.size) + 768]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10284 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10284] = 30
                                                                        mem[_10284 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _12139 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_12139 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_12139]:
                                                                            revert with 0, 50
                                                                        mem[_12139 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_12139 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _12139 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_12139]:
                                                                            revert with 0, 50
                                                                        mem[_12139 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_12139 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_12139 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_12139 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_12139 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_12139 + ceil32(return_data.size) + 260] = mem[_12139]
                                                                        idx = 0
                                                                        s = _12139 + ceil32(return_data.size) + 292
                                                                        t = _12139 + 32
                                                                        while idx < mem[_12139]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_12139 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_12139 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _12139 + ceil32(return_data.size) + (32 * mem[_12139]) + -mem[64] + 288]
                                                            else:
                                                                mem[ceil32(return_data.size) + 448] = 2
                                                                mem[ceil32(return_data.size) + 480] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 544] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 544
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 512] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 544] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 544 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 544] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 548] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 580] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 612] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 708] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 740
                                                                t = ceil32(return_data.size) + 480
                                                                while idx < mem[ceil32(return_data.size) + 448]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 644] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 676] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _3647 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_3647] = 30
                                                                mem[_3647 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call distributionPoolAddress with:
                                                                     gas 30000 wei
                                                                if return_data.size:
                                                                    _4033 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                    mem[_4033] = return_data.size
                                                                    mem[_4033 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    _4104 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4104] = 30
                                                                    mem[_4104 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[0] = this.address
                                                                    _4941 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4941] = 30
                                                                    mem[_4941 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5213 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5213] = 26
                                                                        mem[_5213 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5396 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5396 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5396]:
                                                                            revert with 0, 50
                                                                        mem[_5396 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5396 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5396 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5396]:
                                                                            revert with 0, 50
                                                                        mem[_5396 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5396 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5396 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5396 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5396 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5396 + ceil32(return_data.size) + 260] = mem[_5396]
                                                                        idx = 0
                                                                        s = _5396 + ceil32(return_data.size) + 292
                                                                        t = _5396 + 32
                                                                        while idx < mem[_5396]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5396 + ceil32(return_data.size) + 260 len (32 * mem[_5396]) + 32]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5318 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5318] = 26
                                                                        mem[_5318 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5545 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5545 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5545]:
                                                                                revert with 0, 50
                                                                            mem[_5545 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5545 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5545 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5545]:
                                                                                revert with 0, 50
                                                                            mem[_5545 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5545 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5545 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5545 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5545 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5545 + ceil32(return_data.size) + 260] = mem[_5545]
                                                                            idx = 0
                                                                            s = _5545 + ceil32(return_data.size) + 292
                                                                            t = _5545 + 32
                                                                            while idx < mem[_5545]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5545 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5545 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5545 + ceil32(return_data.size) + (32 * mem[_5545]) + -mem[64] + 288]
                                                                        else:
                                                                            _5526 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5526] = 26
                                                                            mem[_5526 + 32] = 'SafeMath: division by zero'
                                                                            _5730 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5730] = 30
                                                                            mem[_5730 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5922 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5922 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5922]:
                                                                                revert with 0, 50
                                                                            mem[_5922 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5922 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5922 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5922]:
                                                                                revert with 0, 50
                                                                            mem[_5922 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5922 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5922 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5922 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5922 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5922 + ceil32(return_data.size) + 260] = mem[_5922]
                                                                            idx = 0
                                                                            s = _5922 + ceil32(return_data.size) + 292
                                                                            t = _5922 + 32
                                                                            while idx < mem[_5922]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5922 + ceil32(return_data.size) + 260 len (32 * mem[_5922]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_5922 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_5922 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_5922 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_5922 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_5922 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_5922 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_5922 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_5922 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_5922 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5922 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5922 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_5922 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _5922 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _5922 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_5922 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_5922 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5922 + (4 * ceil32(return_data.size)) + (32 * mem[_5922 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                else:
                                                                    _4103 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4103] = 30
                                                                    mem[_4103 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[0] = this.address
                                                                    _4940 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4940] = 30
                                                                    mem[_4940 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5212 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5212] = 26
                                                                        mem[_5212 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5394 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5394 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5394]:
                                                                            revert with 0, 50
                                                                        mem[_5394 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5394 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5394 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5394]:
                                                                            revert with 0, 50
                                                                        mem[_5394 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5394 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5394 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5394 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5394 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5394 + ceil32(return_data.size) + 260] = mem[_5394]
                                                                        idx = 0
                                                                        s = _5394 + ceil32(return_data.size) + 292
                                                                        t = _5394 + 32
                                                                        while idx < mem[_5394]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5394 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5394 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5394 + ceil32(return_data.size) + (32 * mem[_5394]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5317 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5317] = 26
                                                                        mem[_5317 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5543 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5543 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5543]:
                                                                                revert with 0, 50
                                                                            mem[_5543 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5543 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5543 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5543]:
                                                                                revert with 0, 50
                                                                            mem[_5543 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5543 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5543 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5543 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5543 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5543 + ceil32(return_data.size) + 260] = mem[_5543]
                                                                            idx = 0
                                                                            s = _5543 + ceil32(return_data.size) + 292
                                                                            t = _5543 + 32
                                                                            while idx < mem[_5543]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5543 + ceil32(return_data.size) + 260 len (32 * mem[_5543]) + 32]
                                                                        else:
                                                                            _5524 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5524] = 26
                                                                            mem[_5524 + 32] = 'SafeMath: division by zero'
                                                                            _5729 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5729] = 30
                                                                            mem[_5729 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5918 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5918 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5918]:
                                                                                revert with 0, 50
                                                                            mem[_5918 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5918 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5918 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5918]:
                                                                                revert with 0, 50
                                                                            mem[_5918 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5918 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5918 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5918 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5918 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5918 + ceil32(return_data.size) + 260] = mem[_5918]
                                                                            idx = 0
                                                                            s = _5918 + ceil32(return_data.size) + 292
                                                                            t = _5918 + 32
                                                                            while idx < mem[_5918]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5918 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5918 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5918 + ceil32(return_data.size) + (32 * mem[_5918]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10285 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10285] = 30
                                                                            mem[_10285 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12141 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12141 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12141]:
                                                                                revert with 0, 50
                                                                            mem[_12141 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12141 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12141 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12141]:
                                                                                revert with 0, 50
                                                                            mem[_12141 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12141 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12141 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12141 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12141 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12141 + ceil32(return_data.size) + 260] = mem[_12141]
                                                                            idx = 0
                                                                            s = _12141 + ceil32(return_data.size) + 292
                                                                            t = _12141 + 32
                                                                            while idx < mem[_12141]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_12141 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_12141 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _12141 + ceil32(return_data.size) + (32 * mem[_12141]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor30.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(msg.sender)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    require ext_code.size(nodeRewardManagementAddress)
                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                         gas gas_remaining wei
                                                        args msg.sender, uint8(cd[4])
                                                else:
                                                    if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                        revert with 0, 17
                                                    if not swapTokensAmount:
                                                        revert with 0, 18
                                                    if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[ceil32(return_data.size) + 192] = 26
                                                    mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not deadWalletAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[stor7]:
                                                        revert with 0, 'Blacklisted address'
                                                    if balanceOf[stor7] > !(swapTokensAmount * burnFee / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (swapTokensAmount * burnFee / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor7] += swapTokensAmount * burnFee / 100
                                                    mem[ceil32(return_data.size) + 256] = 30
                                                    mem[ceil32(return_data.size) + 288] = 'SafeMath: subtraction overflow'
                                                    if swapTokensAmount * burnFee / 100 > balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] < swapTokensAmount * burnFee / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * burnFee / 100)
                                                    emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                    if not swapTokensAmount:
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 384] = 26
                                                        mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 448] = 30
                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor24]:
                                                            revert with 0, 'Blacklisted address'
                                                        if balanceOf[stor24] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[stor24] < balanceOf[stor24]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[ceil32(return_data.size) + 512] = 30
                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                        if 0 > balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] < 0:
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, this.address, distributionPoolAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 576] = 26
                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 640] = 2
                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                            mem[0] = uniV2RouterAddress
                                                            mem[32] = sha3(msg.sender, 3)
                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                            idx = 0
                                                            s = (2 * ceil32(return_data.size)) + 932
                                                            t = ceil32(return_data.size) + 672
                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                        else:
                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 576] = 26
                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                mem[ceil32(return_data.size) + 640] = 26
                                                                mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 704] = 30
                                                                mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[ceil32(return_data.size) + 768] = 2
                                                                mem[ceil32(return_data.size) + 800] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 1060
                                                                t = ceil32(return_data.size) + 800
                                                                while idx < mem[ceil32(return_data.size) + 768]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _3646 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_3646] = 30
                                                                mem[_3646 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                _4710 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_4710 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_4710]:
                                                                    revert with 0, 50
                                                                mem[_4710 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_4710 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _4710 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_4710]:
                                                                    revert with 0, 50
                                                                mem[_4710 + 64] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                mem[_4710 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_4710 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                mem[_4710 + ceil32(return_data.size) + 132] = 0
                                                                mem[_4710 + ceil32(return_data.size) + 164] = 160
                                                                mem[_4710 + ceil32(return_data.size) + 260] = mem[_4710]
                                                                idx = 0
                                                                s = _4710 + ceil32(return_data.size) + 292
                                                                t = _4710 + 32
                                                                while idx < mem[_4710]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4710 + ceil32(return_data.size) + 260 len (32 * mem[_4710]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor30.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(msg.sender)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                            revert with 0, 17
                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        require ext_code.size(nodeRewardManagementAddress)
                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                             gas gas_remaining wei
                                                            args msg.sender, uint8(cd[4])
                                                    else:
                                                        if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        if not swapTokensAmount * rewardsFee / 100:
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 448] = 30
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            if 0 > swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if swapTokensAmount * rewardsFee / 100 < 0:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                            mem[ceil32(return_data.size) + 512] = 30
                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                            if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                            emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 640] = 26
                                                                    mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 704] = 30
                                                                    mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 768] = 2
                                                                    mem[ceil32(return_data.size) + 800] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 1060
                                                                    t = ceil32(return_data.size) + 800
                                                                    while idx < mem[ceil32(return_data.size) + 768]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _10283 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_10283] = 30
                                                                    mem[_10283 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _12137 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_12137 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_12137]:
                                                                        revert with 0, 50
                                                                    mem[_12137 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_12137 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12137 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_12137]:
                                                                        revert with 0, 50
                                                                    mem[_12137 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_12137 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_12137 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_12137 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_12137 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_12137 + ceil32(return_data.size) + 260] = mem[_12137]
                                                                    idx = 0
                                                                    s = _12137 + ceil32(return_data.size) + 292
                                                                    t = _12137 + 32
                                                                    while idx < mem[_12137]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12137 + ceil32(return_data.size) + 260 len (32 * mem[_12137]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor30.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(msg.sender)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                revert with 0, 17
                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                            require ext_code.size(nodeRewardManagementAddress)
                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, uint8(cd[4])
                                                        else:
                                                            if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                mem[ceil32(return_data.size) + 448] = 30
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                mem[ceil32(return_data.size) + 512] = 30
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 640] = 26
                                                                        mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 704] = 30
                                                                        mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 768] = 2
                                                                        mem[ceil32(return_data.size) + 800] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 1060
                                                                        t = ceil32(return_data.size) + 800
                                                                        while idx < mem[ceil32(return_data.size) + 768]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10280 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10280] = 30
                                                                        mem[_10280 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _12131 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_12131 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_12131]:
                                                                            revert with 0, 50
                                                                        mem[_12131 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_12131 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _12131 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_12131]:
                                                                            revert with 0, 50
                                                                        mem[_12131 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_12131 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_12131 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_12131 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_12131 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_12131 + ceil32(return_data.size) + 260] = mem[_12131]
                                                                        idx = 0
                                                                        s = _12131 + ceil32(return_data.size) + 292
                                                                        t = _12131 + 32
                                                                        while idx < mem[_12131]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_12131 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_12131 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _12131 + ceil32(return_data.size) + (32 * mem[_12131]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                mem[ceil32(return_data.size) + 448] = 2
                                                                mem[ceil32(return_data.size) + 480] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 544] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 544
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 512] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 544] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 544 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 544] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 548] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 580] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 612] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 708] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 740
                                                                t = ceil32(return_data.size) + 480
                                                                while idx < mem[ceil32(return_data.size) + 448]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 644] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 676] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _3645 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_3645] = 30
                                                                mem[_3645 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call distributionPoolAddress with:
                                                                     gas 30000 wei
                                                                if not return_data.size:
                                                                    _4093 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4093] = 30
                                                                    mem[_4093 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[0] = this.address
                                                                    _4937 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4937] = 30
                                                                    mem[_4937 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5210 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5210] = 26
                                                                        mem[_5210 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5389 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5389 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5389]:
                                                                            revert with 0, 50
                                                                        mem[_5389 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5389 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5389 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5389]:
                                                                            revert with 0, 50
                                                                        mem[_5389 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5389 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5389 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5389 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5389 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5389 + ceil32(return_data.size) + 260] = mem[_5389]
                                                                        idx = 0
                                                                        s = _5389 + ceil32(return_data.size) + 292
                                                                        t = _5389 + 32
                                                                        while idx < mem[_5389]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5389 + ceil32(return_data.size) + 260 len (32 * mem[_5389]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5306 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5306] = 26
                                                                        mem[_5306 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5539 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5539 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5539]:
                                                                                revert with 0, 50
                                                                            mem[_5539 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5539 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5539 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5539]:
                                                                                revert with 0, 50
                                                                            mem[_5539 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5539 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5539 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5539 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5539 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5539 + ceil32(return_data.size) + 260] = mem[_5539]
                                                                            idx = 0
                                                                            s = _5539 + ceil32(return_data.size) + 292
                                                                            t = _5539 + 32
                                                                            while idx < mem[_5539]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5539 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5539 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5539 + ceil32(return_data.size) + (32 * mem[_5539]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            _5517 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5517] = 26
                                                                            mem[_5517 + 32] = 'SafeMath: division by zero'
                                                                            _5721 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5721] = 30
                                                                            mem[_5721 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5910 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5910 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5910]:
                                                                                revert with 0, 50
                                                                            mem[_5910 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5910 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5910 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5910]:
                                                                                revert with 0, 50
                                                                            mem[_5910 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5910 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5910 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5910 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5910 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5910 + ceil32(return_data.size) + 260] = mem[_5910]
                                                                            idx = 0
                                                                            s = _5910 + ceil32(return_data.size) + 292
                                                                            t = _5910 + 32
                                                                            while idx < mem[_5910]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5910 + ceil32(return_data.size) + 260 len (32 * mem[_5910]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_5910 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_5910 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_5910 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_5910 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_5910 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_5910 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_5910 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_5910 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_5910 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5910 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5910 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_5910 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _5910 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _5910 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_5910 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5910 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_5910 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if not this.address:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if stor33[address(msg.sender)]:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if stor33[address(this.address)]:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 292] = 27
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 'SafeMath: addition overflow'
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                                mem[_5910 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                                revert with memory
                                                                                  from _5910 + (4 * ceil32(return_data.size)) + 320
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 324] = msg.sender
                                                                            mem[_5910 + (4 * ceil32(return_data.size)) + 356] = uint8(cd[4])
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args mem[_5910 + (4 * ceil32(return_data.size)) + 324 len (5 * ceil32(return_data.size)) + 64]
                                                                else:
                                                                    _4028 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                    mem[_4028] = return_data.size
                                                                    mem[_4028 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    _4094 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4094] = 30
                                                                    mem[_4094 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[0] = this.address
                                                                    _4938 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4938] = 30
                                                                    mem[_4938 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5211 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5211] = 26
                                                                        mem[_5211 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5391 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5391 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5391]:
                                                                            revert with 0, 50
                                                                        mem[_5391 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5391 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5391 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5391]:
                                                                            revert with 0, 50
                                                                        mem[_5391 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5391 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5391 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5391 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5391 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5391 + ceil32(return_data.size) + 260] = mem[_5391]
                                                                        idx = 0
                                                                        s = _5391 + ceil32(return_data.size) + 292
                                                                        t = _5391 + 32
                                                                        while idx < mem[_5391]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5391 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5391 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5391 + ceil32(return_data.size) + (32 * mem[_5391]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5307 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5307] = 26
                                                                        mem[_5307 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5541 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5541 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5541]:
                                                                                revert with 0, 50
                                                                            mem[_5541 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5541 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5541 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5541]:
                                                                                revert with 0, 50
                                                                            mem[_5541 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5541 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5541 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5541 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5541 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5541 + ceil32(return_data.size) + 260] = mem[_5541]
                                                                            idx = 0
                                                                            s = _5541 + ceil32(return_data.size) + 292
                                                                            t = _5541 + 32
                                                                            while idx < mem[_5541]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5541 + ceil32(return_data.size) + 260 len (32 * mem[_5541]) + 32]
                                                                        else:
                                                                            _5519 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5519] = 26
                                                                            mem[_5519 + 32] = 'SafeMath: division by zero'
                                                                            _5722 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5722] = 30
                                                                            mem[_5722 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5914 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5914 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5914]:
                                                                                revert with 0, 50
                                                                            mem[_5914 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5914 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5914 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5914]:
                                                                                revert with 0, 50
                                                                            mem[_5914 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5914 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5914 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5914 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5914 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5914 + ceil32(return_data.size) + 260] = mem[_5914]
                                                                            idx = 0
                                                                            s = _5914 + ceil32(return_data.size) + 292
                                                                            t = _5914 + 32
                                                                            while idx < mem[_5914]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5914 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5914 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5914 + ceil32(return_data.size) + (32 * mem[_5914]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10282 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10282] = 30
                                                                            mem[_10282 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12135 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12135 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12135]:
                                                                                revert with 0, 50
                                                                            mem[_12135 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12135 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12135 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12135]:
                                                                                revert with 0, 50
                                                                            mem[_12135 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12135 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12135 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12135 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12135 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12135 + ceil32(return_data.size) + 260] = mem[_12135]
                                                                            idx = 0
                                                                            s = _12135 + ceil32(return_data.size) + 292
                                                                            t = _12135 + 32
                                                                            while idx < mem[_12135]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_12135 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_12135 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _12135 + ceil32(return_data.size) + (32 * mem[_12135]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                            else:
                                                if swapTokensAmount and devFee > -1 / swapTokensAmount:
                                                    revert with 0, 17
                                                if not swapTokensAmount:
                                                    revert with 0, 18
                                                if swapTokensAmount * devFee / swapTokensAmount != devFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(return_data.size) + 128] = 26
                                                mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if not swapTokensAmount * devFee / 100:
                                                    if not swapTokensAmount:
                                                        mem[ceil32(return_data.size) + 192] = 26
                                                        mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not deadWalletAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor7]:
                                                            revert with 0, 'Blacklisted address'
                                                        if balanceOf[stor7] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[stor7] < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[ceil32(return_data.size) + 256] = 30
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: subtraction overflow'
                                                        if 0 > balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] < 0:
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, this.address, deadWalletAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 448] = 30
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor24] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[stor24] < balanceOf[stor24]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[ceil32(return_data.size) + 512] = 30
                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                            if 0 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < 0:
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 640] = 26
                                                                    mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 704] = 30
                                                                    mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 768] = 2
                                                                    mem[ceil32(return_data.size) + 800] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 1060
                                                                    t = ceil32(return_data.size) + 800
                                                                    while idx < mem[ceil32(return_data.size) + 768]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _3643 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_3643] = 30
                                                                    mem[_3643 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4704 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4704 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4704]:
                                                                        revert with 0, 50
                                                                    mem[_4704 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4704 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4704 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4704]:
                                                                        revert with 0, 50
                                                                    mem[_4704 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4704 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4704 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4704 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4704 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4704 + ceil32(return_data.size) + 260] = mem[_4704]
                                                                    idx = 0
                                                                    s = _4704 + ceil32(return_data.size) + 292
                                                                    t = _4704 + 32
                                                                    while idx < mem[_4704]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_4704 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_4704 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _4704 + ceil32(return_data.size) + (32 * mem[_4704]) + -mem[64] + 288]
                                                        else:
                                                            if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                mem[ceil32(return_data.size) + 384] = 26
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 448] = 30
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if 0 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < 0:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                mem[ceil32(return_data.size) + 512] = 30
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 640] = 26
                                                                        mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 704] = 30
                                                                        mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 768] = 2
                                                                        mem[ceil32(return_data.size) + 800] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 1060
                                                                        t = ceil32(return_data.size) + 800
                                                                        while idx < mem[ceil32(return_data.size) + 768]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10263 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10263] = 30
                                                                        mem[_10263 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _12089 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_12089 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_12089]:
                                                                            revert with 0, 50
                                                                        mem[_12089 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_12089 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _12089 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_12089]:
                                                                            revert with 0, 50
                                                                        mem[_12089 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_12089 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_12089 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_12089 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_12089 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_12089 + ceil32(return_data.size) + 260] = mem[_12089]
                                                                        idx = 0
                                                                        s = _12089 + ceil32(return_data.size) + 292
                                                                        t = _12089 + 32
                                                                        while idx < mem[_12089]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12089 + ceil32(return_data.size) + 260 len (32 * mem[_12089]) + 32]
                                                            else:
                                                                if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 384] = 26
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    mem[ceil32(return_data.size) + 448] = 30
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[ceil32(return_data.size) + 512] = 30
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        mem[ceil32(return_data.size) + 576] = 26
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        mem[ceil32(return_data.size) + 576] = 26
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[ceil32(return_data.size) + 640] = 2
                                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 932
                                                                            t = ceil32(return_data.size) + 672
                                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        else:
                                                                            mem[ceil32(return_data.size) + 640] = 26
                                                                            mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                            mem[ceil32(return_data.size) + 704] = 30
                                                                            mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            mem[ceil32(return_data.size) + 768] = 2
                                                                            mem[ceil32(return_data.size) + 800] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 1060
                                                                            t = ceil32(return_data.size) + 800
                                                                            while idx < mem[ceil32(return_data.size) + 768]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10260 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10260] = 30
                                                                            mem[_10260 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12083 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12083 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12083]:
                                                                                revert with 0, 50
                                                                            mem[_12083 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12083 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12083 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12083]:
                                                                                revert with 0, 50
                                                                            mem[_12083 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12083 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12083 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12083 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12083 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12083 + ceil32(return_data.size) + 260] = mem[_12083]
                                                                            idx = 0
                                                                            s = _12083 + ceil32(return_data.size) + 292
                                                                            t = _12083 + 32
                                                                            while idx < mem[_12083]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12083 + ceil32(return_data.size) + 260 len (32 * mem[_12083]) + 32]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 448] = 2
                                                                    mem[ceil32(return_data.size) + 480] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 544] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 544
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 512] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 544] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 544 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 544] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 548] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 580] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 740
                                                                    t = ceil32(return_data.size) + 480
                                                                    while idx < mem[ceil32(return_data.size) + 448]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 800]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _3642 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_3642] = 30
                                                                    mem[_3642 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    call distributionPoolAddress with:
                                                                         gas 30000 wei
                                                                    if return_data.size:
                                                                        _4022 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                        mem[_4022] = return_data.size
                                                                        mem[_4022 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        _4084 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4084] = 30
                                                                        mem[_4084 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _4927 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4927] = 30
                                                                        mem[_4927 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5207 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5207] = 26
                                                                            mem[_5207 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5385 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5385 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5385]:
                                                                                revert with 0, 50
                                                                            mem[_5385 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5385 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5385 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5385]:
                                                                                revert with 0, 50
                                                                            mem[_5385 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5385 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5385 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5385 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5385 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5385 + ceil32(return_data.size) + 260] = mem[_5385]
                                                                            idx = 0
                                                                            s = _5385 + ceil32(return_data.size) + 292
                                                                            t = _5385 + 32
                                                                            while idx < mem[_5385]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5385 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5385 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5385 + ceil32(return_data.size) + (32 * mem[_5385]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5299 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5299] = 26
                                                                            mem[_5299 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5537 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5537 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5537]:
                                                                                    revert with 0, 50
                                                                                mem[_5537 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5537 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5537 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5537]:
                                                                                    revert with 0, 50
                                                                                mem[_5537 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5537 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5537 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5537 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5537 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5537 + ceil32(return_data.size) + 260] = mem[_5537]
                                                                                idx = 0
                                                                                s = _5537 + ceil32(return_data.size) + 292
                                                                                t = _5537 + 32
                                                                                while idx < mem[_5537]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5537 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5537 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5537 + ceil32(return_data.size) + (32 * mem[_5537]) + -mem[64] + 288]
                                                                            else:
                                                                                _5508 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5508] = 26
                                                                                mem[_5508 + 32] = 'SafeMath: division by zero'
                                                                                _5716 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5716] = 30
                                                                                mem[_5716 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5904 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5904 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5904]:
                                                                                    revert with 0, 50
                                                                                mem[_5904 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5904 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5904 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5904]:
                                                                                    revert with 0, 50
                                                                                mem[_5904 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5904 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5904 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5904 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5904 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5904 + ceil32(return_data.size) + 260] = mem[_5904]
                                                                                idx = 0
                                                                                s = _5904 + ceil32(return_data.size) + 292
                                                                                t = _5904 + 32
                                                                                while idx < mem[_5904]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5904 + ceil32(return_data.size) + 260 len (32 * mem[_5904]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_5904 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_5904 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_5904 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_5904 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_5904 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_5904 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_5904 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_5904 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_5904 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5904 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5904 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_5904 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _5904 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _5904 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_5904 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_5904 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5904 + (4 * ceil32(return_data.size)) + (32 * mem[_5904 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    else:
                                                                        _4083 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4083] = 30
                                                                        mem[_4083 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _4926 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4926] = 30
                                                                        mem[_4926 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5206 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5206] = 26
                                                                            mem[_5206 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5383 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5383 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5383]:
                                                                                revert with 0, 50
                                                                            mem[_5383 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5383 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5383 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5383]:
                                                                                revert with 0, 50
                                                                            mem[_5383 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5383 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5383 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5383 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5383 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5383 + ceil32(return_data.size) + 260] = mem[_5383]
                                                                            idx = 0
                                                                            s = _5383 + ceil32(return_data.size) + 292
                                                                            t = _5383 + 32
                                                                            while idx < mem[_5383]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5383 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5383 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5383 + ceil32(return_data.size) + (32 * mem[_5383]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5298 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5298] = 26
                                                                            mem[_5298 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5535 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5535 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5535]:
                                                                                    revert with 0, 50
                                                                                mem[_5535 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5535 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5535 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5535]:
                                                                                    revert with 0, 50
                                                                                mem[_5535 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5535 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5535 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5535 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5535 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5535 + ceil32(return_data.size) + 260] = mem[_5535]
                                                                                idx = 0
                                                                                s = _5535 + ceil32(return_data.size) + 292
                                                                                t = _5535 + 32
                                                                                while idx < mem[_5535]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5535 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5535 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5535 + ceil32(return_data.size) + (32 * mem[_5535]) + -mem[64] + 288]
                                                                            else:
                                                                                _5506 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5506] = 26
                                                                                mem[_5506 + 32] = 'SafeMath: division by zero'
                                                                                _5715 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5715] = 30
                                                                                mem[_5715 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5900 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5900 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5900]:
                                                                                    revert with 0, 50
                                                                                mem[_5900 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5900 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5900 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5900]:
                                                                                    revert with 0, 50
                                                                                mem[_5900 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5900 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5900 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5900 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5900 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5900 + ceil32(return_data.size) + 260] = mem[_5900]
                                                                                idx = 0
                                                                                s = _5900 + ceil32(return_data.size) + 292
                                                                                t = _5900 + 32
                                                                                while idx < mem[_5900]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5900 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5900 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5900 + ceil32(return_data.size) + (32 * mem[_5900]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _10261 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10261] = 30
                                                                                mem[_10261 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _12085 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_12085 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_12085]:
                                                                                    revert with 0, 50
                                                                                mem[_12085 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_12085 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _12085 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_12085]:
                                                                                    revert with 0, 50
                                                                                mem[_12085 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_12085 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_12085 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_12085 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_12085 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_12085 + ceil32(return_data.size) + 260] = mem[_12085]
                                                                                idx = 0
                                                                                s = _12085 + ceil32(return_data.size) + 292
                                                                                t = _12085 + 32
                                                                                while idx < mem[_12085]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_12085 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_12085 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _12085 + ceil32(return_data.size) + (32 * mem[_12085]) + -mem[64] + 288]
                                                    else:
                                                        if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 192] = 26
                                                        mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not deadWalletAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor7]:
                                                            revert with 0, 'Blacklisted address'
                                                        if balanceOf[stor7] > !(swapTokensAmount * burnFee / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (swapTokensAmount * burnFee / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[stor7] += swapTokensAmount * burnFee / 100
                                                        mem[ceil32(return_data.size) + 256] = 30
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: subtraction overflow'
                                                        if swapTokensAmount * burnFee / 100 > balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] < swapTokensAmount * burnFee / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * burnFee / 100)
                                                        emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 26
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 448] = 30
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor24] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[stor24] < balanceOf[stor24]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[ceil32(return_data.size) + 512] = 30
                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                            if 0 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < 0:
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 576] = 26
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 640] = 26
                                                                    mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 704] = 30
                                                                    mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 768] = 2
                                                                    mem[ceil32(return_data.size) + 800] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 1060
                                                                    t = ceil32(return_data.size) + 800
                                                                    while idx < mem[ceil32(return_data.size) + 768]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _10259 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_10259] = 30
                                                                    mem[_10259 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _12081 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_12081 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_12081]:
                                                                        revert with 0, 50
                                                                    mem[_12081 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_12081 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _12081 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_12081]:
                                                                        revert with 0, 50
                                                                    mem[_12081 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_12081 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_12081 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_12081 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_12081 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_12081 + ceil32(return_data.size) + 260] = mem[_12081]
                                                                    idx = 0
                                                                    s = _12081 + ceil32(return_data.size) + 292
                                                                    t = _12081 + 32
                                                                    while idx < mem[_12081]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12081 + ceil32(return_data.size) + 260 len (32 * mem[_12081]) + 32]
                                                        else:
                                                            if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                mem[ceil32(return_data.size) + 384] = 26
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 448] = 30
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if 0 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < 0:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                mem[ceil32(return_data.size) + 512] = 30
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 576] = 26
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 640] = 26
                                                                        mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 704] = 30
                                                                        mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 768] = 2
                                                                        mem[ceil32(return_data.size) + 800] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 1060
                                                                        t = ceil32(return_data.size) + 800
                                                                        while idx < mem[ceil32(return_data.size) + 768]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10258 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10258] = 30
                                                                        mem[_10258 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _12079 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_12079 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_12079]:
                                                                            revert with 0, 50
                                                                        mem[_12079 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_12079 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _12079 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_12079]:
                                                                            revert with 0, 50
                                                                        mem[_12079 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_12079 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_12079 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_12079 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_12079 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_12079 + ceil32(return_data.size) + 260] = mem[_12079]
                                                                        idx = 0
                                                                        s = _12079 + ceil32(return_data.size) + 292
                                                                        t = _12079 + 32
                                                                        while idx < mem[_12079]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_12079 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_12079 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _12079 + ceil32(return_data.size) + (32 * mem[_12079]) + -mem[64] + 288]
                                                            else:
                                                                if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 384] = 26
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    mem[ceil32(return_data.size) + 448] = 30
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    mem[ceil32(return_data.size) + 512] = 30
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: subtraction overflow'
                                                                    if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        mem[ceil32(return_data.size) + 576] = 26
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        mem[ceil32(return_data.size) + 576] = 26
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[ceil32(return_data.size) + 640] = 2
                                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = balanceOf[address(this.address)]
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 932
                                                                            t = ceil32(return_data.size) + 672
                                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        else:
                                                                            mem[ceil32(return_data.size) + 640] = 26
                                                                            mem[ceil32(return_data.size) + 672] = 'SafeMath: division by zero'
                                                                            mem[ceil32(return_data.size) + 704] = 30
                                                                            mem[ceil32(return_data.size) + 736] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            mem[ceil32(return_data.size) + 768] = 2
                                                                            mem[ceil32(return_data.size) + 800] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 864
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 832] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 864] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 864 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 864] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 932] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 1028] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 1060
                                                                            t = ceil32(return_data.size) + 800
                                                                            while idx < mem[ceil32(return_data.size) + 768]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 964] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 996] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 1120]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10255 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10255] = 30
                                                                            mem[_10255 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12073 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12073 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12073]:
                                                                                revert with 0, 50
                                                                            mem[_12073 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12073 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12073 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12073]:
                                                                                revert with 0, 50
                                                                            mem[_12073 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12073 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12073 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12073 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12073 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12073 + ceil32(return_data.size) + 260] = mem[_12073]
                                                                            idx = 0
                                                                            s = _12073 + ceil32(return_data.size) + 292
                                                                            t = _12073 + 32
                                                                            while idx < mem[_12073]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_12073 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_12073 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _12073 + ceil32(return_data.size) + (32 * mem[_12073]) + -mem[64] + 288]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 448] = 2
                                                                    mem[ceil32(return_data.size) + 480] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 544] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 544
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 512] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 544] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 544 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 544] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 548] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 580] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 740
                                                                    t = ceil32(return_data.size) + 480
                                                                    while idx < mem[ceil32(return_data.size) + 448]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 800]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _3641 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_3641] = 30
                                                                    mem[_3641 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    call distributionPoolAddress with:
                                                                         gas 30000 wei
                                                                    if return_data.size:
                                                                        _4019 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                        mem[_4019] = return_data.size
                                                                        mem[_4019 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        _4073 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4073] = 30
                                                                        mem[_4073 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _4921 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4921] = 30
                                                                        mem[_4921 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5205 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5205] = 26
                                                                            mem[_5205 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5379 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5379 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5379]:
                                                                                revert with 0, 50
                                                                            mem[_5379 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5379 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5379 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5379]:
                                                                                revert with 0, 50
                                                                            mem[_5379 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5379 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5379 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5379 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5379 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5379 + ceil32(return_data.size) + 260] = mem[_5379]
                                                                            idx = 0
                                                                            s = _5379 + ceil32(return_data.size) + 292
                                                                            t = _5379 + 32
                                                                            while idx < mem[_5379]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5379 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5379 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5379 + ceil32(return_data.size) + (32 * mem[_5379]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5294 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5294] = 26
                                                                            mem[_5294 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5533 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5533 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5533]:
                                                                                    revert with 0, 50
                                                                                mem[_5533 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5533 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5533 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5533]:
                                                                                    revert with 0, 50
                                                                                mem[_5533 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5533 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5533 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5533 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5533 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5533 + ceil32(return_data.size) + 260] = mem[_5533]
                                                                                idx = 0
                                                                                s = _5533 + ceil32(return_data.size) + 292
                                                                                t = _5533 + 32
                                                                                while idx < mem[_5533]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5533 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5533 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5533 + ceil32(return_data.size) + (32 * mem[_5533]) + -mem[64] + 288]
                                                                            else:
                                                                                _5501 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5501] = 26
                                                                                mem[_5501 + 32] = 'SafeMath: division by zero'
                                                                                _5709 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5709] = 30
                                                                                mem[_5709 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5896 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5896 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5896]:
                                                                                    revert with 0, 50
                                                                                mem[_5896 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5896 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5896 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5896]:
                                                                                    revert with 0, 50
                                                                                mem[_5896 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5896 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5896 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5896 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5896 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5896 + ceil32(return_data.size) + 260] = mem[_5896]
                                                                                idx = 0
                                                                                s = _5896 + ceil32(return_data.size) + 292
                                                                                t = _5896 + 32
                                                                                while idx < mem[_5896]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5896 + ceil32(return_data.size) + 260 len (32 * mem[_5896]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_5896 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_5896 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_5896 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_5896 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_5896 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_5896 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_5896 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_5896 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_5896 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5896 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5896 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_5896 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _5896 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _5896 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_5896 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_5896 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5896 + (4 * ceil32(return_data.size)) + (32 * mem[_5896 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    else:
                                                                        _4072 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4072] = 30
                                                                        mem[_4072 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _4920 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4920] = 30
                                                                        mem[_4920 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5204 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5204] = 26
                                                                            mem[_5204 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5377 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5377 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5377]:
                                                                                revert with 0, 50
                                                                            mem[_5377 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5377 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5377 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5377]:
                                                                                revert with 0, 50
                                                                            mem[_5377 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5377 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5377 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5377 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5377 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5377 + ceil32(return_data.size) + 260] = mem[_5377]
                                                                            idx = 0
                                                                            s = _5377 + ceil32(return_data.size) + 292
                                                                            t = _5377 + 32
                                                                            while idx < mem[_5377]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5377 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5377 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5377 + ceil32(return_data.size) + (32 * mem[_5377]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5293 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5293] = 26
                                                                            mem[_5293 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5531 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5531 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5531]:
                                                                                    revert with 0, 50
                                                                                mem[_5531 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5531 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5531 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5531]:
                                                                                    revert with 0, 50
                                                                                mem[_5531 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5531 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5531 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5531 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5531 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5531 + ceil32(return_data.size) + 260] = mem[_5531]
                                                                                idx = 0
                                                                                s = _5531 + ceil32(return_data.size) + 292
                                                                                t = _5531 + 32
                                                                                while idx < mem[_5531]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5531 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5531 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5531 + ceil32(return_data.size) + (32 * mem[_5531]) + -mem[64] + 288]
                                                                            else:
                                                                                _5499 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5499] = 26
                                                                                mem[_5499 + 32] = 'SafeMath: division by zero'
                                                                                _5708 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5708] = 30
                                                                                mem[_5708 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5892 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5892 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5892]:
                                                                                    revert with 0, 50
                                                                                mem[_5892 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5892 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5892 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5892]:
                                                                                    revert with 0, 50
                                                                                mem[_5892 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5892 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5892 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5892 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5892 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5892 + ceil32(return_data.size) + 260] = mem[_5892]
                                                                                idx = 0
                                                                                s = _5892 + ceil32(return_data.size) + 292
                                                                                t = _5892 + 32
                                                                                while idx < mem[_5892]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5892 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5892 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5892 + ceil32(return_data.size) + (32 * mem[_5892]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _10256 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10256] = 30
                                                                                mem[_10256 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _12075 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_12075 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_12075]:
                                                                                    revert with 0, 50
                                                                                mem[_12075 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_12075 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _12075 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_12075]:
                                                                                    revert with 0, 50
                                                                                mem[_12075 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_12075 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_12075 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_12075 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_12075 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_12075 + ceil32(return_data.size) + 260] = mem[_12075]
                                                                                idx = 0
                                                                                s = _12075 + ceil32(return_data.size) + 292
                                                                                t = _12075 + 32
                                                                                while idx < mem[_12075]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12075 + ceil32(return_data.size) + 260 len (32 * mem[_12075]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor30.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(msg.sender)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    require ext_code.size(nodeRewardManagementAddress)
                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                         gas gas_remaining wei
                                                        args msg.sender, uint8(cd[4])
                                                else:
                                                    mem[ceil32(return_data.size) + 192] = 2
                                                    mem[ceil32(return_data.size) + 224] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                                    mem[0] = uniV2RouterAddress
                                                    mem[32] = sha3(msg.sender, 3)
                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * devFee / 100
                                                    mem[(2 * ceil32(return_data.size)) + 288] = swapTokensAmount * devFee / 100
                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[(2 * ceil32(return_data.size)) + 292] = swapTokensAmount * devFee / 100
                                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                                    idx = 0
                                                    s = (2 * ceil32(return_data.size)) + 484
                                                    t = ceil32(return_data.size) + 224
                                                    while idx < mem[ceil32(return_data.size) + 192]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _3644 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3644] = 30
                                                    mem[_3644 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call devPoolAddress with:
                                                         gas 30000 wei
                                                    if not return_data.size:
                                                        if swapTokensAmount:
                                                            if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _4635 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4635] = 26
                                                            mem[_4635 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor7] > !(swapTokensAmount * burnFee / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (swapTokensAmount * burnFee / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[32] = 2
                                                            balanceOf[stor7] += swapTokensAmount * burnFee / 100
                                                            mem[0] = this.address
                                                            _5169 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5169] = 30
                                                            mem[_5169 + 32] = 'SafeMath: subtraction overflow'
                                                            if swapTokensAmount * burnFee / 100 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < swapTokensAmount * burnFee / 100:
                                                                revert with 0, 17
                                                            mem[0] = this.address
                                                            mem[32] = 2
                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * burnFee / 100)
                                                            emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5370 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5370] = 26
                                                                mem[_5370 + 32] = 'SafeMath: division by zero'
                                                                _5663 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5663] = 26
                                                                mem[_5663 + 32] = 'SafeMath: division by zero'
                                                                _5879 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5879] = 30
                                                                mem[_5879 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[32] = 2
                                                                mem[0] = this.address
                                                                _6531 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6531] = 30
                                                                mem[_6531 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < 0:
                                                                    revert with 0, 17
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6923 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6923] = 26
                                                                    mem[_6923 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _7122 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_7122 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_7122]:
                                                                        revert with 0, 50
                                                                    mem[_7122 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_7122 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _7122 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_7122]:
                                                                        revert with 0, 50
                                                                    mem[_7122 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_7122 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_7122 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_7122 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_7122 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_7122 + ceil32(return_data.size) + 260] = mem[_7122]
                                                                    idx = 0
                                                                    s = _7122 + ceil32(return_data.size) + 292
                                                                    t = _7122 + 32
                                                                    while idx < mem[_7122]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_7122 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_7122 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _7122 + ceil32(return_data.size) + (32 * mem[_7122]) + -mem[64] + 288]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _7028 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_7028] = 26
                                                                    mem[_7028 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7264 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7264 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7264]:
                                                                            revert with 0, 50
                                                                        mem[_7264 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7264 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7264 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7264]:
                                                                            revert with 0, 50
                                                                        mem[_7264 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7264 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7264 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7264 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7264 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7264 + ceil32(return_data.size) + 260] = mem[_7264]
                                                                        idx = 0
                                                                        s = _7264 + ceil32(return_data.size) + 292
                                                                        t = _7264 + 32
                                                                        while idx < mem[_7264]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7264 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7264 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7264 + ceil32(return_data.size) + (32 * mem[_7264]) + -mem[64] + 288]
                                                                    else:
                                                                        _7234 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7234] = 26
                                                                        mem[_7234 + 32] = 'SafeMath: division by zero'
                                                                        _7499 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7499] = 30
                                                                        mem[_7499 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _7759 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7759 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7759]:
                                                                            revert with 0, 50
                                                                        mem[_7759 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7759 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7759 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7759]:
                                                                            revert with 0, 50
                                                                        mem[_7759 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_7759 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7759 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_7759 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7759 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7759 + ceil32(return_data.size) + 260] = mem[_7759]
                                                                        idx = 0
                                                                        s = _7759 + ceil32(return_data.size) + 292
                                                                        t = _7759 + 32
                                                                        while idx < mem[_7759]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7759 + ceil32(return_data.size) + 260 len (32 * mem[_7759]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_7759 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_7759 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[_7759 + ceil32(return_data.size) + 228] = 0
                                                                        mem[_7759 + ceil32(return_data.size) + 260] = 0
                                                                        mem[_7759 + ceil32(return_data.size) + 292] = 0
                                                                        mem[_7759 + ceil32(return_data.size) + 324] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        mem[_7759 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        require return_data.size >= 96
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[_7759 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                        mem[_7759 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7759 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7759 + (4 * ceil32(return_data.size)) + 256
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[_7759 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                        idx = 0
                                                                        s = _7759 + (4 * ceil32(return_data.size)) + 452
                                                                        t = _7759 + (2 * ceil32(return_data.size)) + 192
                                                                        while idx < mem[_7759 + (2 * ceil32(return_data.size)) + 160]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                        mem[_7759 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7759 + (4 * ceil32(return_data.size)) + (32 * mem[_7759 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5512 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5512] = 26
                                                                mem[_5512 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5804 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5804] = 26
                                                                    mem[_5804 + 32] = 'SafeMath: division by zero'
                                                                    _6039 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6039] = 30
                                                                    mem[_6039 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                    mem[0] = this.address
                                                                    _6736 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6736] = 30
                                                                    mem[_6736 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _7027 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7027] = 26
                                                                        mem[_7027 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7262 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7262 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7262]:
                                                                            revert with 0, 50
                                                                        mem[_7262 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7262 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7262 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7262]:
                                                                            revert with 0, 50
                                                                        mem[_7262 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7262 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7262 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7262 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7262 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7262 + ceil32(return_data.size) + 260] = mem[_7262]
                                                                        idx = 0
                                                                        s = _7262 + ceil32(return_data.size) + 292
                                                                        t = _7262 + 32
                                                                        while idx < mem[_7262]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7262 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7262 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7262 + ceil32(return_data.size) + (32 * mem[_7262]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _7146 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7146] = 26
                                                                        mem[_7146 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7449 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7449 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7449]:
                                                                                revert with 0, 50
                                                                            mem[_7449 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7449 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7449 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7449]:
                                                                                revert with 0, 50
                                                                            mem[_7449 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7449 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7449 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7449 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7449 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7449 + ceil32(return_data.size) + 260] = mem[_7449]
                                                                            idx = 0
                                                                            s = _7449 + ceil32(return_data.size) + 292
                                                                            t = _7449 + 32
                                                                            while idx < mem[_7449]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7449 + ceil32(return_data.size) + 260 len (32 * mem[_7449]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            _7395 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7395] = 26
                                                                            mem[_7395 + 32] = 'SafeMath: division by zero'
                                                                            _7705 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7705] = 30
                                                                            mem[_7705 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _8005 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_8005 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_8005]:
                                                                                revert with 0, 50
                                                                            mem[_8005 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_8005 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _8005 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_8005]:
                                                                                revert with 0, 50
                                                                            mem[_8005 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_8005 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_8005 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_8005 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_8005 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_8005 + ceil32(return_data.size) + 260] = mem[_8005]
                                                                            idx = 0
                                                                            s = _8005 + ceil32(return_data.size) + 292
                                                                            t = _8005 + 32
                                                                            while idx < mem[_8005]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_8005 + ceil32(return_data.size) + 260 len (32 * mem[_8005]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_8005 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_8005 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_8005 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_8005 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_8005 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_8005 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_8005 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_8005 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_8005 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_8005 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _8005 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_8005 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _8005 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _8005 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_8005 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_8005 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_8005 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if not this.address:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if stor33[address(msg.sender)]:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if stor33[address(this.address)]:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 292] = 27
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 'SafeMath: addition overflow'
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                                mem[_8005 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                                revert with memory
                                                                                  from _8005 + (4 * ceil32(return_data.size)) + 320
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 324] = msg.sender
                                                                            mem[_8005 + (4 * ceil32(return_data.size)) + 356] = uint8(cd[4])
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args mem[_8005 + (4 * ceil32(return_data.size)) + 324 len (5 * ceil32(return_data.size)) + 64]
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5950 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5950] = 26
                                                                    mem[_5950 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _6215 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6215] = 30
                                                                        mem[_6215 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _6897 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6897] = 30
                                                                        mem[_6897 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _7145 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7145] = 26
                                                                            mem[_7145 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7441 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7441 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7441]:
                                                                                revert with 0, 50
                                                                            mem[_7441 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7441 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7441 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7441]:
                                                                                revert with 0, 50
                                                                            mem[_7441 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7441 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7441 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7441 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7441 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7441 + ceil32(return_data.size) + 260] = mem[_7441]
                                                                            idx = 0
                                                                            s = _7441 + ceil32(return_data.size) + 292
                                                                            t = _7441 + 32
                                                                            while idx < mem[_7441]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7441 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7441 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7441 + ceil32(return_data.size) + (32 * mem[_7441]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _7297 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7297] = 26
                                                                            mem[_7297 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _7665 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7665 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7665]:
                                                                                    revert with 0, 50
                                                                                mem[_7665 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7665 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7665 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7665]:
                                                                                    revert with 0, 50
                                                                                mem[_7665 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7665 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7665 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_7665 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7665 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7665 + ceil32(return_data.size) + 260] = mem[_7665]
                                                                                idx = 0
                                                                                s = _7665 + ceil32(return_data.size) + 292
                                                                                t = _7665 + 32
                                                                                while idx < mem[_7665]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7665 + ceil32(return_data.size) + 260 len (32 * mem[_7665]) + 32]
                                                                            else:
                                                                                _7623 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7623] = 26
                                                                                mem[_7623 + 32] = 'SafeMath: division by zero'
                                                                                _7907 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7907] = 30
                                                                                mem[_7907 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _8258 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_8258 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_8258]:
                                                                                    revert with 0, 50
                                                                                mem[_8258 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_8258 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _8258 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_8258]:
                                                                                    revert with 0, 50
                                                                                mem[_8258 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_8258 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_8258 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_8258 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_8258 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_8258 + ceil32(return_data.size) + 260] = mem[_8258]
                                                                                idx = 0
                                                                                s = _8258 + ceil32(return_data.size) + 292
                                                                                t = _8258 + 32
                                                                                while idx < mem[_8258]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_8258 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_8258 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _8258 + ceil32(return_data.size) + (32 * mem[_8258]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _10264 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10264] = 30
                                                                                mem[_10264 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _12091 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_12091 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_12091]:
                                                                                    revert with 0, 50
                                                                                mem[_12091 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_12091 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _12091 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_12091]:
                                                                                    revert with 0, 50
                                                                                mem[_12091 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_12091 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_12091 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_12091 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_12091 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_12091 + ceil32(return_data.size) + 260] = mem[_12091]
                                                                                idx = 0
                                                                                s = _12091 + ceil32(return_data.size) + 292
                                                                                t = _12091 + 32
                                                                                while idx < mem[_12091]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_12091 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_12091 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _12091 + ceil32(return_data.size) + (32 * mem[_12091]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _6257 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6257 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6257]:
                                                                            revert with 0, 50
                                                                        mem[_6257 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6257 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6257 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6257]:
                                                                            revert with 0, 50
                                                                        mem[_6257 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6257 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6257 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6257 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6257 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6257 + ceil32(return_data.size) + 260] = mem[_6257]
                                                                        idx = 0
                                                                        s = _6257 + ceil32(return_data.size) + 292
                                                                        t = _6257 + 32
                                                                        while idx < mem[_6257]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6257 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6257 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args swapTokensAmount * rewardsFee / 100 * stor29 / 100, 0, 160, address(this.address), block.timestamp, mem[_6257 + ceil32(return_data.size) + 260 len (32 * mem[_6257]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_6257 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_6257 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            mem[_6257 + ceil32(return_data.size) + 160] = 30
                                                                            mem[_6257 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[_6257 + ceil32(return_data.size) + 224] = 30
                                                                            mem[_6257 + ceil32(return_data.size) + 256] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6257 + ceil32(return_data.size) + 288] = 26
                                                                                mem[_6257 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                mem[_6257 + ceil32(return_data.size) + 352] = 2
                                                                                mem[_6257 + ceil32(return_data.size) + 384] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6257 + ceil32(return_data.size) + 448] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6257 + ceil32(return_data.size) + 416] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 452] = balanceOf[address(this.address)]
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 0
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 160
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 612] = 2
                                                                                idx = 0
                                                                                s = _6257 + (2 * ceil32(return_data.size)) + 644
                                                                                t = _6257 + ceil32(return_data.size) + 384
                                                                                while idx < mem[_6257 + ceil32(return_data.size) + 352]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 548] = this.address
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + 580] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6257 + (2 * ceil32(return_data.size)) + (32 * mem[_6257 + ceil32(return_data.size) + 352]) + -mem[64] + 640]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6257 + ceil32(return_data.size) + 288] = 26
                                                                                mem[_6257 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6257 + ceil32(return_data.size) + 352] = 2
                                                                                    mem[_6257 + ceil32(return_data.size) + 384] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + ceil32(return_data.size) + 448] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + ceil32(return_data.size) + 416] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 452] = balanceOf[address(this.address)]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 160
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 612] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (2 * ceil32(return_data.size)) + 644
                                                                                    t = _6257 + ceil32(return_data.size) + 384
                                                                                    while idx < mem[_6257 + ceil32(return_data.size) + 352]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 548] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 580] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6257 + (2 * ceil32(return_data.size)) + 612 len (32 * mem[_6257 + ceil32(return_data.size) + 352]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 37
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 548] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if not this.address:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 35
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 548] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 19
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 19
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 484] = 27
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 516] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 548] = 30
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 580] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 610] = 0
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 512
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 516] = msg.sender
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 548] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6257 + (2 * ceil32(return_data.size)) + 516 len ceil32(return_data.size) + 64]
                                                                                else:
                                                                                    mem[_6257 + ceil32(return_data.size) + 352] = 26
                                                                                    mem[_6257 + ceil32(return_data.size) + 384] = 'SafeMath: division by zero'
                                                                                    mem[_6257 + ceil32(return_data.size) + 416] = 30
                                                                                    mem[_6257 + ceil32(return_data.size) + 448] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6257 + ceil32(return_data.size) + 480] = 2
                                                                                    mem[_6257 + ceil32(return_data.size) + 512] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + ceil32(return_data.size) + 576] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (2 * ceil32(return_data.size)) + 576
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + ceil32(return_data.size) + 544] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 576] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 580] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 612] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 644] = 160
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 740] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (2 * ceil32(return_data.size)) + 772
                                                                                    t = _6257 + ceil32(return_data.size) + 512
                                                                                    while idx < mem[_6257 + ceil32(return_data.size) + 480]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 676] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 708] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6257 + (2 * ceil32(return_data.size)) + 740 len (32 * mem[_6257 + ceil32(return_data.size) + 480]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 576] = 30
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 608] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 640] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 644] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 676] = 30
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 708] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + 738] = 0
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + 640
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 644] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 676] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 740] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 772] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 804] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6257 + (2 * ceil32(return_data.size)) + 644 len ceil32(return_data.size) + 192]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + 640 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 640] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 672] = 0
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 704] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6257 + (4 * ceil32(return_data.size)) + 640 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 640] = 2
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 672] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (6 * ceil32(return_data.size)) + 736
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + 704] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 772] = 0
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 804] = 160
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 900] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (6 * ceil32(return_data.size)) + 932
                                                                                    t = _6257 + (4 * ceil32(return_data.size)) + 672
                                                                                    while idx < mem[_6257 + (4 * ceil32(return_data.size)) + 640]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 836] = this.address
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6257 + (6 * ceil32(return_data.size)) + 900 len (32 * mem[_6257 + (4 * ceil32(return_data.size)) + 640]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6257 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6257 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 'SafeMath: addition overflow', mem[_6257 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6257 + (6 * ceil32(return_data.size)) + 898] = 0
                                                                                        revert with 0, 
                                                                                                    'SafeMath: subtraction overflow',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + 898 len (9 * ceil32(return_data.size)) + 2]
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6257 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                        else:
                                                                            mem[_6257 + ceil32(return_data.size) + 160] = return_data.size
                                                                            mem[_6257 + ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 161] = 30
                                                                            mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 193] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 225] = 30
                                                                            mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 257] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 2
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = balanceOf[address(this.address)]
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 160
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 2
                                                                                idx = 0
                                                                                s = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645
                                                                                t = _6257 + ceil32(return_data.size) + ceil32(return_data.size) + 385
                                                                                while idx < mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = this.address
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613 len (32 * mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 37
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                       len ceil32(return_data.size) + 132
                                                                                if not this.address:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 35
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                       len ceil32(return_data.size) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 19
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                       len ceil32(return_data.size) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 19
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                       len ceil32(return_data.size) + 100
                                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 27
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'SafeMath: addition overflow'
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                       len ceil32(return_data.size) + 100
                                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 32
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 30
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = 'SafeMath: subtraction overflow'
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 611] = 0
                                                                                    revert with memory
                                                                                      from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513
                                                                                       len ceil32(return_data.size) + 100
                                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = msg.sender
                                                                                mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len ceil32(return_data.size) + 64]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 26
                                                                                mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 2
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = balanceOf[address(this.address)]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 160
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645
                                                                                    t = _6257 + ceil32(return_data.size) + ceil32(return_data.size) + 385
                                                                                    while idx < mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613 len (32 * mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 37
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if not this.address:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 35
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 19
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 19
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 27
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 'SafeMath: addition overflow'
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                           len ceil32(return_data.size) + 100
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 30
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 611] = 0
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = msg.sender
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len ceil32(return_data.size) + 64]
                                                                                else:
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 26
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = 'SafeMath: division by zero'
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = 30
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 481] = 2
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 513] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 577] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 545] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 160
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 773
                                                                                    t = _6257 + ceil32(return_data.size) + ceil32(return_data.size) + 513
                                                                                    while idx < mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 481]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741 len (32 * mem[_6257 + ceil32(return_data.size) + ceil32(return_data.size) + 481]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 30
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 609] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 32
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = 30
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 739] = 0
                                                                                        revert with memory
                                                                                          from _6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = this.address
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 773] = 0
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 805] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645 len ceil32(return_data.size) + 192]
                                                                                    mem[_6257 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = 0
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 705] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = 2
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 737] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 737
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 705] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 737] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = balanceOf[address(this.address)]
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 773] = 0
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 805] = 160
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 901] = 2
                                                                                    idx = 0
                                                                                    s = _6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 933
                                                                                    t = _6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673
                                                                                    while idx < mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837] = this.address
                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 901 len (32 * mem[_6257 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 
                                                                                                    'SafeMath: addition overflow',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 899] = 0
                                                                                        revert with 0, 
                                                                                                    'SafeMath: subtraction overflow',
                                                                                                    mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 899 len (9 * ceil32(return_data.size)) + 2]
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6257 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                        else:
                                                            _4275 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4275] = 26
                                                            mem[_4275 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor7] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[stor7] < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[32] = 2
                                                            mem[0] = this.address
                                                            _5033 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5033] = 30
                                                            mem[_5033 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < 0:
                                                                revert with 0, 17
                                                            mem[0] = this.address
                                                            mem[32] = 2
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5254 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5254] = 26
                                                                mem[_5254 + 32] = 'SafeMath: division by zero'
                                                                _5513 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5513] = 26
                                                                mem[_5513 + 32] = 'SafeMath: division by zero'
                                                                _5737 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5737] = 30
                                                                mem[_5737 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[32] = 2
                                                                mem[0] = this.address
                                                                _6326 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6326] = 30
                                                                mem[_6326 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < 0:
                                                                    revert with 0, 17
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6758 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6758] = 26
                                                                    mem[_6758 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _7004 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_7004 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_7004]:
                                                                        revert with 0, 50
                                                                    mem[_7004 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_7004 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _7004 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_7004]:
                                                                        revert with 0, 50
                                                                    mem[_7004 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_7004 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_7004 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_7004 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_7004 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_7004 + ceil32(return_data.size) + 260] = mem[_7004]
                                                                    idx = 0
                                                                    s = _7004 + ceil32(return_data.size) + 292
                                                                    t = _7004 + 32
                                                                    while idx < mem[_7004]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_7004 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_7004 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _7004 + ceil32(return_data.size) + (32 * mem[_7004]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        var238001 = 32
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6929 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6929] = 26
                                                                    mem[_6929 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7127 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7127 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7127]:
                                                                            revert with 0, 50
                                                                        mem[_7127 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7127 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7127 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7127]:
                                                                            revert with 0, 50
                                                                        mem[_7127 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7127 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7127 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7127 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7127 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7127 + ceil32(return_data.size) + 260] = mem[_7127]
                                                                        idx = 0
                                                                        s = _7127 + ceil32(return_data.size) + 292
                                                                        t = _7127 + 32
                                                                        while idx < mem[_7127]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7127 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7127 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7127 + ceil32(return_data.size) + (32 * mem[_7127]) + -mem[64] + 288]
                                                                    else:
                                                                        _7107 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7107] = 26
                                                                        mem[_7107 + 32] = 'SafeMath: division by zero'
                                                                        _7312 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7312] = 30
                                                                        mem[_7312 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _7563 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7563 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7563]:
                                                                            revert with 0, 50
                                                                        mem[_7563 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7563 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7563 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7563]:
                                                                            revert with 0, 50
                                                                        mem[_7563 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_7563 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7563 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_7563 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7563 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7563 + ceil32(return_data.size) + 260] = mem[_7563]
                                                                        idx = 0
                                                                        s = _7563 + ceil32(return_data.size) + 292
                                                                        t = _7563 + 32
                                                                        while idx < mem[_7563]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7563 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7563 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7563 + ceil32(return_data.size) + (32 * mem[_7563]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10271 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10271] = 30
                                                                        mem[_10271 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _12109 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_12109 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_12109]:
                                                                            revert with 0, 50
                                                                        mem[_12109 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_12109 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _12109 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_12109]:
                                                                            revert with 0, 50
                                                                        mem[_12109 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_12109 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_12109 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_12109 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_12109 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_12109 + ceil32(return_data.size) + 260] = mem[_12109]
                                                                        idx = 0
                                                                        s = _12109 + ceil32(return_data.size) + 292
                                                                        t = _12109 + 32
                                                                        while idx < mem[_12109]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_12109 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_12109 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _12109 + ceil32(return_data.size) + (32 * mem[_12109]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5371 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5371] = 26
                                                                mem[_5371 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5664 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5664] = 26
                                                                    mem[_5664 + 32] = 'SafeMath: division by zero'
                                                                    _5880 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5880] = 30
                                                                    mem[_5880 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                    mem[0] = this.address
                                                                    _6533 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6533] = 30
                                                                    mem[_6533 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6928 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6928] = 26
                                                                        mem[_6928 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7125 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7125 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7125]:
                                                                            revert with 0, 50
                                                                        mem[_7125 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7125 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7125 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7125]:
                                                                            revert with 0, 50
                                                                        mem[_7125 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7125 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7125 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7125 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7125 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7125 + ceil32(return_data.size) + 260] = mem[_7125]
                                                                        idx = 0
                                                                        s = _7125 + ceil32(return_data.size) + 292
                                                                        t = _7125 + 32
                                                                        while idx < mem[_7125]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7125 + ceil32(return_data.size) + 260 len (32 * mem[_7125]) + 32]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _7030 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7030] = 26
                                                                        mem[_7030 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7274 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7274 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7274]:
                                                                                revert with 0, 50
                                                                            mem[_7274 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7274 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7274 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7274]:
                                                                                revert with 0, 50
                                                                            mem[_7274 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7274 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7274 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7274 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7274 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7274 + ceil32(return_data.size) + 260] = mem[_7274]
                                                                            idx = 0
                                                                            s = _7274 + ceil32(return_data.size) + 292
                                                                            t = _7274 + 32
                                                                            while idx < mem[_7274]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7274 + ceil32(return_data.size) + 260 len (32 * mem[_7274]) + 32]
                                                                        else:
                                                                            _7238 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7238] = 26
                                                                            mem[_7238 + 32] = 'SafeMath: division by zero'
                                                                            _7502 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7502] = 30
                                                                            mem[_7502 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7768 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7768 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7768]:
                                                                                revert with 0, 50
                                                                            mem[_7768 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7768 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7768 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7768]:
                                                                                revert with 0, 50
                                                                            mem[_7768 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7768 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7768 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7768 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7768 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7768 + ceil32(return_data.size) + 260] = mem[_7768]
                                                                            idx = 0
                                                                            s = _7768 + ceil32(return_data.size) + 292
                                                                            t = _7768 + 32
                                                                            while idx < mem[_7768]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7768 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7768 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7768 + ceil32(return_data.size) + (32 * mem[_7768]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10270 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10270] = 30
                                                                            mem[_10270 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12107 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12107 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12107]:
                                                                                revert with 0, 50
                                                                            mem[_12107 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12107 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12107 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12107]:
                                                                                revert with 0, 50
                                                                            mem[_12107 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12107 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12107 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12107 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12107 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12107 + ceil32(return_data.size) + 260] = mem[_12107]
                                                                            idx = 0
                                                                            s = _12107 + ceil32(return_data.size) + 292
                                                                            t = _12107 + 32
                                                                            while idx < mem[_12107]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12107 + ceil32(return_data.size) + 260 len (32 * mem[_12107]) + 32]
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5805 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5805] = 26
                                                                    mem[_5805 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _6040 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6040] = 30
                                                                        mem[_6040 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _6737 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6737] = 30
                                                                        mem[_6737 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _7029 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7029] = 26
                                                                            mem[_7029 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7266 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7266 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7266]:
                                                                                revert with 0, 50
                                                                            mem[_7266 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7266 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7266 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7266]:
                                                                                revert with 0, 50
                                                                            mem[_7266 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7266 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7266 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7266 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7266 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7266 + ceil32(return_data.size) + 260] = mem[_7266]
                                                                            idx = 0
                                                                            s = _7266 + ceil32(return_data.size) + 292
                                                                            t = _7266 + 32
                                                                            while idx < mem[_7266]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7266 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7266 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7266 + ceil32(return_data.size) + (32 * mem[_7266]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _7149 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7149] = 26
                                                                            mem[_7149 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _7452 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7452 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7452]:
                                                                                    revert with 0, 50
                                                                                mem[_7452 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7452 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7452 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7452]:
                                                                                    revert with 0, 50
                                                                                mem[_7452 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7452 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7452 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_7452 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7452 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7452 + ceil32(return_data.size) + 260] = mem[_7452]
                                                                                idx = 0
                                                                                s = _7452 + ceil32(return_data.size) + 292
                                                                                t = _7452 + 32
                                                                                while idx < mem[_7452]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7452 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_7452 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _7452 + ceil32(return_data.size) + (32 * mem[_7452]) + -mem[64] + 288]
                                                                            else:
                                                                                _7401 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7401] = 26
                                                                                mem[_7401 + 32] = 'SafeMath: division by zero'
                                                                                _7706 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7706] = 30
                                                                                mem[_7706 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _8010 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_8010 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_8010]:
                                                                                    revert with 0, 50
                                                                                mem[_8010 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_8010 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _8010 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_8010]:
                                                                                    revert with 0, 50
                                                                                mem[_8010 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_8010 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_8010 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_8010 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_8010 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_8010 + ceil32(return_data.size) + 260] = mem[_8010]
                                                                                idx = 0
                                                                                s = _8010 + ceil32(return_data.size) + 292
                                                                                t = _8010 + 32
                                                                                while idx < mem[_8010]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_8010 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_8010 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _8010 + ceil32(return_data.size) + (32 * mem[_8010]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _10268 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10268] = 30
                                                                                mem[_10268 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _12101 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_12101 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_12101]:
                                                                                    revert with 0, 50
                                                                                mem[_12101 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_12101 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _12101 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_12101]:
                                                                                    revert with 0, 50
                                                                                mem[_12101 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_12101 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_12101 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_12101 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_12101 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_12101 + ceil32(return_data.size) + 260] = mem[_12101]
                                                                                idx = 0
                                                                                s = _12101 + ceil32(return_data.size) + 292
                                                                                t = _12101 + 32
                                                                                while idx < mem[_12101]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_12101 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_12101 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _12101 + ceil32(return_data.size) + (32 * mem[_12101]) + -mem[64] + 288]
                                                                    else:
                                                                        _6061 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6061 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6061]:
                                                                            revert with 0, 50
                                                                        mem[_6061 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6061 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6061 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6061]:
                                                                            revert with 0, 50
                                                                        mem[_6061 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6061 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6061 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6061 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6061 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6061 + ceil32(return_data.size) + 260] = mem[_6061]
                                                                        idx = 0
                                                                        s = _6061 + ceil32(return_data.size) + 292
                                                                        t = _6061 + 32
                                                                        while idx < mem[_6061]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6061 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6061 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6061 + ceil32(return_data.size) + (32 * mem[_6061]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10269 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10269] = 30
                                                                        mem[_10269 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            _11086 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_11086] = 30
                                                                            mem[_11086 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            mem[32] = 2
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[0] = this.address
                                                                            _12344 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12344] = 30
                                                                            mem[_12344 + 32] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _12655 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12655] = 26
                                                                                mem[_12655 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _13018 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_13018 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_13018]:
                                                                                    revert with 0, 50
                                                                                mem[_13018 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_13018 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _13018 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_13018]:
                                                                                    revert with 0, 50
                                                                                mem[_13018 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_13018 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_13018 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_13018 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_13018 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_13018 + ceil32(return_data.size) + 260] = mem[_13018]
                                                                                idx = 0
                                                                                s = _13018 + ceil32(return_data.size) + 292
                                                                                t = _13018 + 32
                                                                                while idx < mem[_13018]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13018 + ceil32(return_data.size) + 260 len (32 * mem[_13018]) + 32]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _12914 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12914] = 26
                                                                                mem[_12914 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13265 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13265 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13265]:
                                                                                        revert with 0, 50
                                                                                    mem[_13265 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13265 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13265 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13265]:
                                                                                        revert with 0, 50
                                                                                    mem[_13265 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13265 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13265 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13265 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13265 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13265 + ceil32(return_data.size) + 260] = mem[_13265]
                                                                                    idx = 0
                                                                                    s = _13265 + ceil32(return_data.size) + 292
                                                                                    t = _13265 + 32
                                                                                    while idx < mem[_13265]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13265 + ceil32(return_data.size) + 260 len (32 * mem[_13265]) + 32]
                                                                                else:
                                                                                    _13234 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13234] = 26
                                                                                    mem[_13234 + 32] = 'SafeMath: division by zero'
                                                                                    _13575 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13575] = 30
                                                                                    mem[_13575 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _13702 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13702 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13702]:
                                                                                        revert with 0, 50
                                                                                    mem[_13702 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13702 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13702 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13702]:
                                                                                        revert with 0, 50
                                                                                    mem[_13702 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_13702 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13702 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_13702 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13702 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13702 + ceil32(return_data.size) + 260] = mem[_13702]
                                                                                    idx = 0
                                                                                    s = _13702 + ceil32(return_data.size) + 292
                                                                                    t = _13702 + 32
                                                                                    while idx < mem[_13702]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13702 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13702 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13702 + ceil32(return_data.size) + (32 * mem[_13702]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _15150 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_15150] = 30
                                                                                    mem[_15150 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _16448 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_16448 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_16448]:
                                                                                        revert with 0, 50
                                                                                    mem[_16448 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_16448 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _16448 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_16448]:
                                                                                        revert with 0, 50
                                                                                    mem[_16448 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_16448 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_16448 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_16448 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_16448 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_16448 + ceil32(return_data.size) + 260] = mem[_16448]
                                                                                    idx = 0
                                                                                    s = _16448 + ceil32(return_data.size) + 292
                                                                                    t = _16448 + 32
                                                                                    while idx < mem[_16448]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_16448 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_16448 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _16448 + ceil32(return_data.size) + (32 * mem[_16448]) + -mem[64] + 288]
                                                                        else:
                                                                            _10933 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                            mem[_10933] = return_data.size
                                                                            mem[_10933 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            _11087 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_11087] = 30
                                                                            mem[_11087 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            mem[32] = 2
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[0] = this.address
                                                                            _12345 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12345] = 30
                                                                            mem[_12345 + 32] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _12656 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12656] = 26
                                                                                mem[_12656 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _13020 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_13020 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_13020]:
                                                                                    revert with 0, 50
                                                                                mem[_13020 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_13020 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _13020 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_13020]:
                                                                                    revert with 0, 50
                                                                                mem[_13020 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_13020 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_13020 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_13020 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_13020 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_13020 + ceil32(return_data.size) + 260] = mem[_13020]
                                                                                idx = 0
                                                                                s = _13020 + ceil32(return_data.size) + 292
                                                                                t = _13020 + 32
                                                                                while idx < mem[_13020]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_13020 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_13020 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _13020 + ceil32(return_data.size) + (32 * mem[_13020]) + -mem[64] + 288]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _12915 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12915] = 26
                                                                                mem[_12915 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13267 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13267 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13267]:
                                                                                        revert with 0, 50
                                                                                    mem[_13267 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13267 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13267 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13267]:
                                                                                        revert with 0, 50
                                                                                    mem[_13267 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13267 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13267 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13267 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13267 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13267 + ceil32(return_data.size) + 260] = mem[_13267]
                                                                                    idx = 0
                                                                                    s = _13267 + ceil32(return_data.size) + 292
                                                                                    t = _13267 + 32
                                                                                    while idx < mem[_13267]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13267 + ceil32(return_data.size) + 260 len (32 * mem[_13267]) + 32]
                                                                                else:
                                                                                    _13236 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13236] = 26
                                                                                    mem[_13236 + 32] = 'SafeMath: division by zero'
                                                                                    _13576 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13576] = 30
                                                                                    mem[_13576 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _13706 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13706 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13706]:
                                                                                        revert with 0, 50
                                                                                    mem[_13706 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13706 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13706 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13706]:
                                                                                        revert with 0, 50
                                                                                    mem[_13706 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_13706 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13706 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_13706 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13706 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13706 + ceil32(return_data.size) + 260] = mem[_13706]
                                                                                    idx = 0
                                                                                    s = _13706 + ceil32(return_data.size) + 292
                                                                                    t = _13706 + 32
                                                                                    while idx < mem[_13706]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13706 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13706 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13706 + ceil32(return_data.size) + (32 * mem[_13706]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _15151 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_15151] = 30
                                                                                    mem[_15151 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _16450 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_16450 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_16450]:
                                                                                        revert with 0, 50
                                                                                    mem[_16450 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_16450 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _16450 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_16450]:
                                                                                        revert with 0, 50
                                                                                    mem[_16450 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_16450 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_16450 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_16450 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_16450 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_16450 + ceil32(return_data.size) + 260] = mem[_16450]
                                                                                    idx = 0
                                                                                    s = _16450 + ceil32(return_data.size) + 292
                                                                                    t = _16450 + 32
                                                                                    while idx < mem[_16450]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_16450 + ceil32(return_data.size) + 260 len (32 * mem[_16450]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                            ('le', ('ext_call.return_data', 0, 32), ('stor', ('map', 'msg.sender', ('name', 'balanceOf', 2))))
                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                            require ext_code.size(nodeRewardManagementAddress)
                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, uint8(cd[4])
                                                    else:
                                                        _4026 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_4026] = return_data.size
                                                        mem[_4026 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not swapTokensAmount:
                                                            _4276 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4276] = 26
                                                            mem[_4276 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor7] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[stor7] < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[32] = 2
                                                            mem[0] = this.address
                                                            _5035 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5035] = 30
                                                            mem[_5035 + 32] = 'SafeMath: subtraction overflow'
                                                            if 0 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < 0:
                                                                revert with 0, 17
                                                            mem[0] = this.address
                                                            mem[32] = 2
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5259 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5259] = 26
                                                                mem[_5259 + 32] = 'SafeMath: division by zero'
                                                                _5515 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5515] = 26
                                                                mem[_5515 + 32] = 'SafeMath: division by zero'
                                                                _5738 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5738] = 30
                                                                mem[_5738 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[32] = 2
                                                                mem[0] = this.address
                                                                _6334 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6334] = 30
                                                                mem[_6334 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < 0:
                                                                    revert with 0, 17
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6768 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6768] = 26
                                                                    mem[_6768 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _7009 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_7009 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_7009]:
                                                                        revert with 0, 50
                                                                    mem[_7009 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_7009 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _7009 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_7009]:
                                                                        revert with 0, 50
                                                                    mem[_7009 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_7009 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_7009 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_7009 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_7009 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_7009 + ceil32(return_data.size) + 260] = mem[_7009]
                                                                    idx = 0
                                                                    s = _7009 + ceil32(return_data.size) + 292
                                                                    t = _7009 + 32
                                                                    while idx < mem[_7009]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_7009 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_7009 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _7009 + ceil32(return_data.size) + (32 * mem[_7009]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        var238001 = 32
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6940 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6940] = 26
                                                                    mem[_6940 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7135 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7135 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7135]:
                                                                            revert with 0, 50
                                                                        mem[_7135 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7135 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7135 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7135]:
                                                                            revert with 0, 50
                                                                        mem[_7135 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7135 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7135 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7135 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7135 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7135 + ceil32(return_data.size) + 260] = mem[_7135]
                                                                        idx = 0
                                                                        s = _7135 + ceil32(return_data.size) + 292
                                                                        t = _7135 + 32
                                                                        while idx < mem[_7135]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7135 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7135 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7135 + ceil32(return_data.size) + (32 * mem[_7135]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _7115 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7115] = 26
                                                                        mem[_7115 + 32] = 'SafeMath: division by zero'
                                                                        _7328 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7328] = 30
                                                                        mem[_7328 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _7590 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7590 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7590]:
                                                                            revert with 0, 50
                                                                        mem[_7590 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7590 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7590 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7590]:
                                                                            revert with 0, 50
                                                                        mem[_7590 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_7590 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7590 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_7590 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7590 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7590 + ceil32(return_data.size) + 260] = mem[_7590]
                                                                        idx = 0
                                                                        s = _7590 + ceil32(return_data.size) + 292
                                                                        t = _7590 + 32
                                                                        while idx < mem[_7590]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7590 + ceil32(return_data.size) + 260 len (32 * mem[_7590]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_7590 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_7590 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[_7590 + ceil32(return_data.size) + 228] = 0
                                                                        mem[_7590 + ceil32(return_data.size) + 260] = 0
                                                                        mem[_7590 + ceil32(return_data.size) + 292] = 0
                                                                        mem[_7590 + ceil32(return_data.size) + 324] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        mem[_7590 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        require return_data.size >= 96
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[_7590 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                        mem[_7590 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7590 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7590 + (4 * ceil32(return_data.size)) + 256
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[_7590 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                        idx = 0
                                                                        s = _7590 + (4 * ceil32(return_data.size)) + 452
                                                                        t = _7590 + (2 * ceil32(return_data.size)) + 192
                                                                        while idx < mem[_7590 + (2 * ceil32(return_data.size)) + 160]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7590 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_7590 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if not this.address:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if stor33[address(msg.sender)]:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if stor33[address(this.address)]:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 292] = 27
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 'SafeMath: addition overflow'
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                            mem[_7590 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                            revert with memory
                                                                              from _7590 + (4 * ceil32(return_data.size)) + 320
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 324] = msg.sender
                                                                        mem[_7590 + (4 * ceil32(return_data.size)) + 356] = uint8(cd[4])
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args mem[_7590 + (4 * ceil32(return_data.size)) + 324 len (5 * ceil32(return_data.size)) + 64]
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5373 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5373] = 26
                                                                mem[_5373 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5666 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5666] = 26
                                                                    mem[_5666 + 32] = 'SafeMath: division by zero'
                                                                    _5882 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5882] = 30
                                                                    mem[_5882 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                    mem[0] = this.address
                                                                    _6538 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6538] = 30
                                                                    mem[_6538 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6939 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6939] = 26
                                                                        mem[_6939 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7133 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7133 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7133]:
                                                                            revert with 0, 50
                                                                        mem[_7133 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7133 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7133 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7133]:
                                                                            revert with 0, 50
                                                                        mem[_7133 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7133 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7133 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7133 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7133 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7133 + ceil32(return_data.size) + 260] = mem[_7133]
                                                                        idx = 0
                                                                        s = _7133 + ceil32(return_data.size) + 292
                                                                        t = _7133 + 32
                                                                        while idx < mem[_7133]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7133 + ceil32(return_data.size) + 260 len (32 * mem[_7133]) + 32]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _7040 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7040] = 26
                                                                        mem[_7040 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7290 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7290 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7290]:
                                                                                revert with 0, 50
                                                                            mem[_7290 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7290 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7290 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7290]:
                                                                                revert with 0, 50
                                                                            mem[_7290 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7290 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7290 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7290 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7290 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7290 + ceil32(return_data.size) + 260] = mem[_7290]
                                                                            idx = 0
                                                                            s = _7290 + ceil32(return_data.size) + 292
                                                                            t = _7290 + 32
                                                                            while idx < mem[_7290]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7290 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7290 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7290 + ceil32(return_data.size) + (32 * mem[_7290]) + -mem[64] + 288]
                                                                        else:
                                                                            _7251 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7251] = 26
                                                                            mem[_7251 + 32] = 'SafeMath: division by zero'
                                                                            _7514 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7514] = 30
                                                                            mem[_7514 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7793 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7793 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7793]:
                                                                                revert with 0, 50
                                                                            mem[_7793 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7793 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7793 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7793]:
                                                                                revert with 0, 50
                                                                            mem[_7793 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7793 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7793 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7793 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7793 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7793 + ceil32(return_data.size) + 260] = mem[_7793]
                                                                            idx = 0
                                                                            s = _7793 + ceil32(return_data.size) + 292
                                                                            t = _7793 + 32
                                                                            while idx < mem[_7793]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7793 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7793 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7793 + ceil32(return_data.size) + (32 * mem[_7793]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10278 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10278] = 30
                                                                            mem[_10278 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12127 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12127 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12127]:
                                                                                revert with 0, 50
                                                                            mem[_12127 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12127 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12127 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12127]:
                                                                                revert with 0, 50
                                                                            mem[_12127 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12127 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12127 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12127 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12127 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12127 + ceil32(return_data.size) + 260] = mem[_12127]
                                                                            idx = 0
                                                                            s = _12127 + ceil32(return_data.size) + 292
                                                                            t = _12127 + 32
                                                                            while idx < mem[_12127]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12127 + ceil32(return_data.size) + 260 len (32 * mem[_12127]) + 32]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5807 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5807] = 26
                                                                    mem[_5807 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _6043 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6043] = 30
                                                                        mem[_6043 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _6740 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6740] = 30
                                                                        mem[_6740 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _7039 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7039] = 26
                                                                            mem[_7039 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7282 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7282 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7282]:
                                                                                revert with 0, 50
                                                                            mem[_7282 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7282 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7282 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7282]:
                                                                                revert with 0, 50
                                                                            mem[_7282 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7282 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7282 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7282 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7282 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7282 + ceil32(return_data.size) + 260] = mem[_7282]
                                                                            idx = 0
                                                                            s = _7282 + ceil32(return_data.size) + 292
                                                                            t = _7282 + 32
                                                                            while idx < mem[_7282]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7282 + ceil32(return_data.size) + 260 len (32 * mem[_7282]) + 32]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _7160 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7160] = 26
                                                                            mem[_7160 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _7469 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7469 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7469]:
                                                                                    revert with 0, 50
                                                                                mem[_7469 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7469 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7469 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7469]:
                                                                                    revert with 0, 50
                                                                                mem[_7469 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7469 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7469 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_7469 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7469 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7469 + ceil32(return_data.size) + 260] = mem[_7469]
                                                                                idx = 0
                                                                                s = _7469 + ceil32(return_data.size) + 292
                                                                                t = _7469 + 32
                                                                                while idx < mem[_7469]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7469 + ceil32(return_data.size) + 260 len (32 * mem[_7469]) + 32]
                                                                            else:
                                                                                _7419 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7419] = 26
                                                                                mem[_7419 + 32] = 'SafeMath: division by zero'
                                                                                _7715 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7715] = 30
                                                                                mem[_7715 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _8028 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_8028 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_8028]:
                                                                                    revert with 0, 50
                                                                                mem[_8028 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_8028 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _8028 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_8028]:
                                                                                    revert with 0, 50
                                                                                mem[_8028 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_8028 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_8028 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_8028 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_8028 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_8028 + ceil32(return_data.size) + 260] = mem[_8028]
                                                                                idx = 0
                                                                                s = _8028 + ceil32(return_data.size) + 292
                                                                                t = _8028 + 32
                                                                                while idx < mem[_8028]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_8028 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_8028 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _8028 + ceil32(return_data.size) + (32 * mem[_8028]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _10276 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10276] = 30
                                                                                mem[_10276 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _12121 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_12121 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_12121]:
                                                                                    revert with 0, 50
                                                                                mem[_12121 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_12121 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _12121 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_12121]:
                                                                                    revert with 0, 50
                                                                                mem[_12121 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_12121 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_12121 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_12121 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_12121 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_12121 + ceil32(return_data.size) + 260] = mem[_12121]
                                                                                idx = 0
                                                                                s = _12121 + ceil32(return_data.size) + 292
                                                                                t = _12121 + 32
                                                                                while idx < mem[_12121]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_12121 + ceil32(return_data.size) + 260 len (32 * mem[_12121]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _6067 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6067 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6067]:
                                                                            revert with 0, 50
                                                                        mem[_6067 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6067 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6067 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6067]:
                                                                            revert with 0, 50
                                                                        mem[_6067 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6067 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6067 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6067 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6067 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6067 + ceil32(return_data.size) + 260] = mem[_6067]
                                                                        idx = 0
                                                                        s = _6067 + ceil32(return_data.size) + 292
                                                                        t = _6067 + 32
                                                                        while idx < mem[_6067]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6067 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6067 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args swapTokensAmount * rewardsFee / 100 * stor29 / 100, 0, 160, address(this.address), block.timestamp, mem[_6067 + ceil32(return_data.size) + 260 len (32 * mem[_6067]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_6067 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_6067 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            mem[_6067 + ceil32(return_data.size) + 160] = 30
                                                                            mem[_6067 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[_6067 + ceil32(return_data.size) + 224] = 30
                                                                            mem[_6067 + ceil32(return_data.size) + 256] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6067 + ceil32(return_data.size) + 288] = 26
                                                                                mem[_6067 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                mem[_6067 + ceil32(return_data.size) + 352] = 2
                                                                                mem[_6067 + ceil32(return_data.size) + 384] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6067 + ceil32(return_data.size) + 448] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6067 + ceil32(return_data.size) + 416] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 452] = balanceOf[address(this.address)]
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 0
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 160
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 612] = 2
                                                                                idx = 0
                                                                                s = _6067 + (2 * ceil32(return_data.size)) + 644
                                                                                t = _6067 + ceil32(return_data.size) + 384
                                                                                while idx < mem[_6067 + ceil32(return_data.size) + 352]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 548] = this.address
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + 580] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6067 + (2 * ceil32(return_data.size)) + (32 * mem[_6067 + ceil32(return_data.size) + 352]) + -mem[64] + 640]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6067 + ceil32(return_data.size) + 288] = 26
                                                                                mem[_6067 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6067 + ceil32(return_data.size) + 352] = 2
                                                                                    mem[_6067 + ceil32(return_data.size) + 384] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + ceil32(return_data.size) + 448] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + ceil32(return_data.size) + 416] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 452] = balanceOf[address(this.address)]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 160
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 612] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (2 * ceil32(return_data.size)) + 644
                                                                                    t = _6067 + ceil32(return_data.size) + 384
                                                                                    while idx < mem[_6067 + ceil32(return_data.size) + 352]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 548] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 580] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6067 + (2 * ceil32(return_data.size)) + 612 len (32 * mem[_6067 + ceil32(return_data.size) + 352]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 37
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 548] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if not this.address:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 35
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 548] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 19
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 19
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 448] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 452] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 484] = 27
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 'SafeMath: addition overflow'
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 448
                                                                                           len ceil32(return_data.size) + 100
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 516] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 548] = 30
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 580] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 610] = 0
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 512
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 516] = msg.sender
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 548] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6067 + (2 * ceil32(return_data.size)) + 516 len ceil32(return_data.size) + 64]
                                                                                else:
                                                                                    mem[_6067 + ceil32(return_data.size) + 352] = 26
                                                                                    mem[_6067 + ceil32(return_data.size) + 384] = 'SafeMath: division by zero'
                                                                                    mem[_6067 + ceil32(return_data.size) + 416] = 30
                                                                                    mem[_6067 + ceil32(return_data.size) + 448] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6067 + ceil32(return_data.size) + 480] = 2
                                                                                    mem[_6067 + ceil32(return_data.size) + 512] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + ceil32(return_data.size) + 576] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (2 * ceil32(return_data.size)) + 576
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + ceil32(return_data.size) + 544] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 576] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 580] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 612] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 644] = 160
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 740] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (2 * ceil32(return_data.size)) + 772
                                                                                    t = _6067 + ceil32(return_data.size) + 512
                                                                                    while idx < mem[_6067 + ceil32(return_data.size) + 480]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 676] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 708] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6067 + (2 * ceil32(return_data.size)) + 740 len (32 * mem[_6067 + ceil32(return_data.size) + 480]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 576] = 30
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 608] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 640] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 644] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 676] = 30
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 708] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + 738] = 0
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + 640
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 644] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 676] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 740] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 772] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 804] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6067 + (2 * ceil32(return_data.size)) + 644 len ceil32(return_data.size) + 192]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + 640 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 640] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 672] = 0
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 704] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6067 + (4 * ceil32(return_data.size)) + 640 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 640] = 2
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 672] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (6 * ceil32(return_data.size)) + 736
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + 704] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 740] = balanceOf[address(this.address)]
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 772] = 0
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 804] = 160
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 900] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (6 * ceil32(return_data.size)) + 932
                                                                                    t = _6067 + (4 * ceil32(return_data.size)) + 672
                                                                                    while idx < mem[_6067 + (4 * ceil32(return_data.size)) + 640]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 836] = this.address
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6067 + (6 * ceil32(return_data.size)) + 900 len (32 * mem[_6067 + (4 * ceil32(return_data.size)) + 640]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6067 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6067 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 'SafeMath: addition overflow', mem[_6067 + (6 * ceil32(return_data.size)) + 836 len 9 * ceil32(return_data.size)]
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6067 + (6 * ceil32(return_data.size)) + 898] = 0
                                                                                        revert with 0, 
                                                                                                    'SafeMath: subtraction overflow',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + 898 len (9 * ceil32(return_data.size)) + 2]
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6067 + (6 * ceil32(return_data.size)) + 868 len 9 * ceil32(return_data.size)]
                                                                        else:
                                                                            mem[_6067 + ceil32(return_data.size) + 160] = return_data.size
                                                                            mem[_6067 + ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 161] = 30
                                                                            mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 193] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 225] = 30
                                                                            mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 257] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 26
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = 'SafeMath: division by zero'
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 2
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = balanceOf[address(this.address)]
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 160
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 2
                                                                                idx = 0
                                                                                s = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645
                                                                                t = _6067 + ceil32(return_data.size) + ceil32(return_data.size) + 385
                                                                                while idx < mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = this.address
                                                                                mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353]) + -mem[64] + 641]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 26
                                                                                mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 2
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = balanceOf[address(this.address)]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = 160
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645
                                                                                    t = _6067 + ceil32(return_data.size) + ceil32(return_data.size) + 385
                                                                                    while idx < mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353]) + -mem[64] + 641]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                                else:
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 26
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = 'SafeMath: division by zero'
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = 30
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 481] = 2
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 513] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 577] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 545] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 160
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 773
                                                                                    t = _6067 + ceil32(return_data.size) + ceil32(return_data.size) + 513
                                                                                    while idx < mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 481]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741 len (32 * mem[_6067 + ceil32(return_data.size) + ceil32(return_data.size) + 481]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 30
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 609] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 32
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = 30
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 739] = 0
                                                                                        revert with memory
                                                                                          from _6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = this.address
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 773] = 0
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 805] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645 len ceil32(return_data.size) + 192]
                                                                                    mem[_6067 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 641 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = 0
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 705] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = 2
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 737] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 737
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 705] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 737] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = balanceOf[address(this.address)]
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 773] = 0
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 805] = 160
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 901] = 2
                                                                                    idx = 0
                                                                                    s = _6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 933
                                                                                    t = _6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673
                                                                                    while idx < mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837] = this.address
                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 901 len (32 * mem[_6067 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 
                                                                                                    'SafeMath: addition overflow',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len 9 * ceil32(return_data.size)]
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 899] = 0
                                                                                        revert with 0, 
                                                                                                    'SafeMath: subtraction overflow',
                                                                                                    mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 899 len (9 * ceil32(return_data.size)) + 2]
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6067 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869 len 9 * ceil32(return_data.size)]
                                                        else:
                                                            if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _4636 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4636] = 26
                                                            mem[_4636 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            if balanceOf[stor7] > !(swapTokensAmount * burnFee / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (swapTokensAmount * burnFee / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[32] = 2
                                                            balanceOf[stor7] += swapTokensAmount * burnFee / 100
                                                            mem[0] = this.address
                                                            _5170 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5170] = 30
                                                            mem[_5170 + 32] = 'SafeMath: subtraction overflow'
                                                            if swapTokensAmount * burnFee / 100 > balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] < swapTokensAmount * burnFee / 100:
                                                                revert with 0, 17
                                                            mem[0] = this.address
                                                            mem[32] = 2
                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * burnFee / 100)
                                                            emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5372 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5372] = 26
                                                                mem[_5372 + 32] = 'SafeMath: division by zero'
                                                                _5665 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5665] = 26
                                                                mem[_5665 + 32] = 'SafeMath: division by zero'
                                                                _5881 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5881] = 30
                                                                mem[_5881 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if balanceOf[stor24] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[stor24] < balanceOf[stor24]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[32] = 2
                                                                mem[0] = this.address
                                                                _6536 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6536] = 30
                                                                mem[_6536 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if balanceOf[this.address] < 0:
                                                                    revert with 0, 17
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6934 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6934] = 26
                                                                    mem[_6934 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _7130 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_7130 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_7130]:
                                                                        revert with 0, 50
                                                                    mem[_7130 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_7130 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _7130 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_7130]:
                                                                        revert with 0, 50
                                                                    mem[_7130 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_7130 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_7130 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_7130 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_7130 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_7130 + ceil32(return_data.size) + 260] = mem[_7130]
                                                                    idx = 0
                                                                    s = _7130 + ceil32(return_data.size) + 292
                                                                    t = _7130 + 32
                                                                    while idx < mem[_7130]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7130 + ceil32(return_data.size) + 260 len (32 * mem[_7130]) + 32]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _7038 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_7038] = 26
                                                                    mem[_7038 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7280 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7280 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7280]:
                                                                            revert with 0, 50
                                                                        mem[_7280 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7280 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7280 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7280]:
                                                                            revert with 0, 50
                                                                        mem[_7280 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7280 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7280 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7280 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7280 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7280 + ceil32(return_data.size) + 260] = mem[_7280]
                                                                        idx = 0
                                                                        s = _7280 + ceil32(return_data.size) + 292
                                                                        t = _7280 + 32
                                                                        while idx < mem[_7280]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7280 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7280 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7280 + ceil32(return_data.size) + (32 * mem[_7280]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _7247 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7247] = 26
                                                                        mem[_7247 + 32] = 'SafeMath: division by zero'
                                                                        _7511 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7511] = 30
                                                                        mem[_7511 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _7784 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7784 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7784]:
                                                                            revert with 0, 50
                                                                        mem[_7784 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7784 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7784 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7784]:
                                                                            revert with 0, 50
                                                                        mem[_7784 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_7784 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7784 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_7784 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7784 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7784 + ceil32(return_data.size) + 260] = mem[_7784]
                                                                        idx = 0
                                                                        s = _7784 + ceil32(return_data.size) + 292
                                                                        t = _7784 + 32
                                                                        while idx < mem[_7784]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7784 + ceil32(return_data.size) + 260 len (32 * mem[_7784]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_7784 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_7784 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[_7784 + ceil32(return_data.size) + 228] = 0
                                                                        mem[_7784 + ceil32(return_data.size) + 260] = 0
                                                                        mem[_7784 + ceil32(return_data.size) + 292] = 0
                                                                        mem[_7784 + ceil32(return_data.size) + 324] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        mem[_7784 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        require return_data.size >= 96
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[_7784 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                        mem[_7784 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7784 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7784 + (4 * ceil32(return_data.size)) + 256
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[_7784 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                        idx = 0
                                                                        s = _7784 + (4 * ceil32(return_data.size)) + 452
                                                                        t = _7784 + (2 * ceil32(return_data.size)) + 192
                                                                        while idx < mem[_7784 + (2 * ceil32(return_data.size)) + 160]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7784 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_7784 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if not this.address:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if stor33[address(msg.sender)]:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if stor33[address(this.address)]:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 292] = 27
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 'SafeMath: addition overflow'
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                            mem[_7784 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                            revert with memory
                                                                              from _7784 + (4 * ceil32(return_data.size)) + 320
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 324] = msg.sender
                                                                        mem[_7784 + (4 * ceil32(return_data.size)) + 356] = uint8(cd[4])
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args mem[_7784 + (4 * ceil32(return_data.size)) + 324 len (5 * ceil32(return_data.size)) + 64]
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5514 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5514] = 26
                                                                mem[_5514 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5806 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5806] = 26
                                                                    mem[_5806 + 32] = 'SafeMath: division by zero'
                                                                    _6042 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6042] = 30
                                                                    mem[_6042 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[stor24] > !(swapTokensAmount * rewardsFee / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) < balanceOf[stor24]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[32] = 2
                                                                    balanceOf[stor24] += swapTokensAmount * rewardsFee / 100
                                                                    mem[0] = this.address
                                                                    _6739 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6739] = 30
                                                                    mem[_6739 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 > balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[this.address] < swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100)
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _7037 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7037] = 26
                                                                        mem[_7037 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _7278 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7278 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7278]:
                                                                            revert with 0, 50
                                                                        mem[_7278 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7278 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7278 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7278]:
                                                                            revert with 0, 50
                                                                        mem[_7278 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7278 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7278 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_7278 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7278 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7278 + ceil32(return_data.size) + 260] = mem[_7278]
                                                                        idx = 0
                                                                        s = _7278 + ceil32(return_data.size) + 292
                                                                        t = _7278 + 32
                                                                        while idx < mem[_7278]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7278 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_7278 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7278 + ceil32(return_data.size) + (32 * mem[_7278]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _7157 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_7157] = 26
                                                                        mem[_7157 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7466 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7466 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7466]:
                                                                                revert with 0, 50
                                                                            mem[_7466 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7466 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7466 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7466]:
                                                                                revert with 0, 50
                                                                            mem[_7466 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7466 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7466 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7466 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7466 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7466 + ceil32(return_data.size) + 260] = mem[_7466]
                                                                            idx = 0
                                                                            s = _7466 + ceil32(return_data.size) + 292
                                                                            t = _7466 + 32
                                                                            while idx < mem[_7466]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7466 + ceil32(return_data.size) + 260 len (32 * mem[_7466]) + 32]
                                                                        else:
                                                                            _7413 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7413] = 26
                                                                            mem[_7413 + 32] = 'SafeMath: division by zero'
                                                                            _7714 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7714] = 30
                                                                            mem[_7714 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _8023 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_8023 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_8023]:
                                                                                revert with 0, 50
                                                                            mem[_8023 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_8023 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _8023 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_8023]:
                                                                                revert with 0, 50
                                                                            mem[_8023 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_8023 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_8023 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_8023 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_8023 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_8023 + ceil32(return_data.size) + 260] = mem[_8023]
                                                                            idx = 0
                                                                            s = _8023 + ceil32(return_data.size) + 292
                                                                            t = _8023 + 32
                                                                            while idx < mem[_8023]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_8023 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_8023 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _8023 + ceil32(return_data.size) + (32 * mem[_8023]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _10274 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10274] = 30
                                                                            mem[_10274 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _12117 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_12117 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_12117]:
                                                                                revert with 0, 50
                                                                            mem[_12117 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_12117 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _12117 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_12117]:
                                                                                revert with 0, 50
                                                                            mem[_12117 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_12117 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_12117 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_12117 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_12117 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_12117 + ceil32(return_data.size) + 260] = mem[_12117]
                                                                            idx = 0
                                                                            s = _12117 + ceil32(return_data.size) + 292
                                                                            t = _12117 + 32
                                                                            while idx < mem[_12117]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_12117 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_12117 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _12117 + ceil32(return_data.size) + (32 * mem[_12117]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5953 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5953] = 26
                                                                    mem[_5953 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _6220 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6220] = 30
                                                                        mem[_6220 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                            revert with 0, 17
                                                                        if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        mem[32] = 2
                                                                        balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        mem[0] = this.address
                                                                        _6900 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6900] = 30
                                                                        mem[_6900 + 32] = 'SafeMath: subtraction overflow'
                                                                        if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                            revert with 0, 17
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _7156 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7156] = 26
                                                                            mem[_7156 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _7458 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7458 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7458]:
                                                                                revert with 0, 50
                                                                            mem[_7458 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7458 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7458 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7458]:
                                                                                revert with 0, 50
                                                                            mem[_7458 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7458 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7458 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_7458 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7458 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7458 + ceil32(return_data.size) + 260] = mem[_7458]
                                                                            idx = 0
                                                                            s = _7458 + ceil32(return_data.size) + 292
                                                                            t = _7458 + 32
                                                                            while idx < mem[_7458]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7458 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7458 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7458 + ceil32(return_data.size) + (32 * mem[_7458]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _7313 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_7313] = 26
                                                                            mem[_7313 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _7680 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7680 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7680]:
                                                                                    revert with 0, 50
                                                                                mem[_7680 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7680 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7680 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7680]:
                                                                                    revert with 0, 50
                                                                                mem[_7680 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7680 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7680 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_7680 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7680 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7680 + ceil32(return_data.size) + 260] = mem[_7680]
                                                                                idx = 0
                                                                                s = _7680 + ceil32(return_data.size) + 292
                                                                                t = _7680 + 32
                                                                                while idx < mem[_7680]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7680 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_7680 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _7680 + ceil32(return_data.size) + (32 * mem[_7680]) + -mem[64] + 288]
                                                                            else:
                                                                                _7642 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7642] = 26
                                                                                mem[_7642 + 32] = 'SafeMath: division by zero'
                                                                                _7919 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7919] = 30
                                                                                mem[_7919 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _8274 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_8274 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_8274]:
                                                                                    revert with 0, 50
                                                                                mem[_8274 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_8274 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _8274 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_8274]:
                                                                                    revert with 0, 50
                                                                                mem[_8274 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_8274 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_8274 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_8274 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_8274 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_8274 + ceil32(return_data.size) + 260] = mem[_8274]
                                                                                idx = 0
                                                                                s = _8274 + ceil32(return_data.size) + 292
                                                                                t = _8274 + 32
                                                                                while idx < mem[_8274]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_8274 + ceil32(return_data.size) + 260 len (32 * mem[_8274]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_8274 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_8274 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_8274 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_8274 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_8274 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_8274 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_8274 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_8274 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_8274 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_8274 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _8274 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_8274 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _8274 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _8274 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_8274 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_8274 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _8274 + (4 * ceil32(return_data.size)) + (32 * mem[_8274 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                        if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                            revert with 0, 17
                                                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _6270 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6270 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6270]:
                                                                            revert with 0, 50
                                                                        mem[_6270 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6270 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6270 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6270]:
                                                                            revert with 0, 50
                                                                        mem[_6270 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6270 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6270 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6270 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6270 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6270 + ceil32(return_data.size) + 260] = mem[_6270]
                                                                        idx = 0
                                                                        s = _6270 + ceil32(return_data.size) + 292
                                                                        t = _6270 + 32
                                                                        while idx < mem[_6270]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6270 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6270 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6270 + ceil32(return_data.size) + (32 * mem[_6270]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _10273 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_10273] = 30
                                                                        mem[_10273 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if return_data.size:
                                                                            _10938 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                            mem[_10938] = return_data.size
                                                                            mem[_10938 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            _11095 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_11095] = 30
                                                                            mem[_11095 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            mem[32] = 2
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[0] = this.address
                                                                            _12350 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12350] = 30
                                                                            mem[_12350 + 32] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _12658 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12658] = 26
                                                                                mem[_12658 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _13027 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_13027 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_13027]:
                                                                                    revert with 0, 50
                                                                                mem[_13027 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_13027 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _13027 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_13027]:
                                                                                    revert with 0, 50
                                                                                mem[_13027 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_13027 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_13027 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_13027 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_13027 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_13027 + ceil32(return_data.size) + 260] = mem[_13027]
                                                                                idx = 0
                                                                                s = _13027 + ceil32(return_data.size) + 292
                                                                                t = _13027 + 32
                                                                                while idx < mem[_13027]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13027 + ceil32(return_data.size) + 260 len (32 * mem[_13027]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                    revert with 0, 17
                                                                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _12926 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12926] = 26
                                                                                mem[_12926 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13271 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13271 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13271]:
                                                                                        revert with 0, 50
                                                                                    mem[_13271 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13271 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13271 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13271]:
                                                                                        revert with 0, 50
                                                                                    mem[_13271 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13271 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13271 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13271 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13271 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13271 + ceil32(return_data.size) + 260] = mem[_13271]
                                                                                    idx = 0
                                                                                    s = _13271 + ceil32(return_data.size) + 292
                                                                                    t = _13271 + 32
                                                                                    while idx < mem[_13271]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13271 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13271 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13271 + ceil32(return_data.size) + (32 * mem[_13271]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                                else:
                                                                                    _13243 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13243] = 26
                                                                                    mem[_13243 + 32] = 'SafeMath: division by zero'
                                                                                    _13578 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13578] = 30
                                                                                    mem[_13578 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _13714 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13714 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13714]:
                                                                                        revert with 0, 50
                                                                                    mem[_13714 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13714 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13714 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13714]:
                                                                                        revert with 0, 50
                                                                                    mem[_13714 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_13714 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13714 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_13714 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13714 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13714 + ceil32(return_data.size) + 260] = mem[_13714]
                                                                                    idx = 0
                                                                                    s = _13714 + ceil32(return_data.size) + 292
                                                                                    t = _13714 + 32
                                                                                    while idx < mem[_13714]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_13714 + ceil32(return_data.size) + 260 len (32 * mem[_13714]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_13714 + ceil32(return_data.size) + 96] = 30
                                                                                    mem[_13714 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_13714 + ceil32(return_data.size) + 228] = 0
                                                                                    mem[_13714 + ceil32(return_data.size) + 260] = 0
                                                                                    mem[_13714 + ceil32(return_data.size) + 292] = 0
                                                                                    mem[_13714 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    mem[_13714 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[_13714 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                    mem[_13714 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13714 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_13714 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                    idx = 0
                                                                                    s = _13714 + (4 * ceil32(return_data.size)) + 452
                                                                                    t = _13714 + (2 * ceil32(return_data.size)) + 192
                                                                                    while idx < mem[_13714 + (2 * ceil32(return_data.size)) + 160]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13714 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_13714 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 132
                                                                                    if not this.address:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 292] = 27
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 'SafeMath: addition overflow'
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                                    if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                                        mem[_13714 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                                        revert with memory
                                                                                          from _13714 + (4 * ceil32(return_data.size)) + 320
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                        revert with 0, 17
                                                                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 324] = msg.sender
                                                                                    mem[_13714 + (4 * ceil32(return_data.size)) + 356] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_13714 + (4 * ceil32(return_data.size)) + 324 len (5 * ceil32(return_data.size)) + 64]
                                                                        else:
                                                                            _11094 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_11094] = 30
                                                                            mem[_11094 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[stor24] > !((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)):
                                                                                revert with 0, 17
                                                                            if balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) < balanceOf[stor24]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            mem[32] = 2
                                                                            balanceOf[stor24] = balanceOf[stor24] + (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            mem[0] = this.address
                                                                            _12349 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12349] = 30
                                                                            mem[_12349 + 32] = 'SafeMath: subtraction overflow'
                                                                            if (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100) > balanceOf[this.address]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[this.address] < (swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100):
                                                                                revert with 0, 17
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            balanceOf[address(this.address)] = balanceOf[this.address] - (swapTokensAmount * rewardsFee / 100) + (swapTokensAmount * rewardsFee / 100 * stor29 / 100)
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _12657 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12657] = 26
                                                                                mem[_12657 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _13025 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_13025 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_13025]:
                                                                                    revert with 0, 50
                                                                                mem[_13025 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_13025 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _13025 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_13025]:
                                                                                    revert with 0, 50
                                                                                mem[_13025 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_13025 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_13025 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_13025 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_13025 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_13025 + ceil32(return_data.size) + 260] = mem[_13025]
                                                                                idx = 0
                                                                                s = _13025 + ceil32(return_data.size) + 292
                                                                                t = _13025 + 32
                                                                                while idx < mem[_13025]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_13025 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_13025 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _13025 + ceil32(return_data.size) + (32 * mem[_13025]) + -mem[64] + 288]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _12925 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_12925] = 26
                                                                                mem[_12925 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13269 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13269 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13269]:
                                                                                        revert with 0, 50
                                                                                    mem[_13269 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13269 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13269 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13269]:
                                                                                        revert with 0, 50
                                                                                    mem[_13269 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13269 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13269 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13269 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13269 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13269 + ceil32(return_data.size) + 260] = mem[_13269]
                                                                                    idx = 0
                                                                                    s = _13269 + ceil32(return_data.size) + 292
                                                                                    t = _13269 + 32
                                                                                    while idx < mem[_13269]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13269 + ceil32(return_data.size) + 260 len (32 * mem[_13269]) + 32]
                                                                                else:
                                                                                    _13241 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13241] = 26
                                                                                    mem[_13241 + 32] = 'SafeMath: division by zero'
                                                                                    _13577 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_13577] = 30
                                                                                    mem[_13577 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _13710 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13710 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13710]:
                                                                                        revert with 0, 50
                                                                                    mem[_13710 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13710 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13710 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13710]:
                                                                                        revert with 0, 50
                                                                                    mem[_13710 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_13710 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13710 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_13710 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13710 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13710 + ceil32(return_data.size) + 260] = mem[_13710]
                                                                                    idx = 0
                                                                                    s = _13710 + ceil32(return_data.size) + 292
                                                                                    t = _13710 + 32
                                                                                    while idx < mem[_13710]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13710 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13710 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13710 + ceil32(return_data.size) + (32 * mem[_13710]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _15152 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_15152] = 30
                                                                                    mem[_15152 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _16452 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_16452 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_16452]:
                                                                                        revert with 0, 50
                                                                                    mem[_16452 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_16452 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _16452 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_16452]:
                                                                                        revert with 0, 50
                                                                                    mem[_16452 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_16452 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_16452 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_16452 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_16452 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_16452 + ceil32(return_data.size) + 260] = mem[_16452]
                                                                                    idx = 0
                                                                                    s = _16452 + ceil32(return_data.size) + 292
                                                                                    t = _16452 + 32
                                                                                    while idx < mem[_16452]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_16452 + ceil32(return_data.size) + 260 len (32 * mem[_16452]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if balanceOf[address(this.address)] > !ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            if balanceOf[address(this.address)] + ext_call.return_data[0] < balanceOf[address(this.address)]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            balanceOf[address(this.address)] += ext_call.return_data[0]
                                                                            if ext_call.return_data[0] > balanceOf[msg.sender]:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if balanceOf[msg.sender] < ext_call.return_data[0]:
                                                                                revert with 0, 17
                                                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] - ext_call.return_data[0]
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
}



}

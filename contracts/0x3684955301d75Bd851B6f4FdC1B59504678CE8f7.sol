contract main {




// =====================  Runtime code  =====================


function _fallback() payable {
    revert
}

function checkAavePosition(address arg1, address arg2, address arg3, uint256[] arg4, address arg5, address arg6, uint256[] arg7, uint256 arg8, bool arg9) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require calldata.size + -arg2 - 4 >= 64
    require arg2.length <= test266151307()
    require arg2 + arg2.length + 35 < calldata.size
    if cd[(arg2 + arg2.length + 4)] > test266151307():
        revert with 'NH{q', 65
    if floor32(cd[(arg2 + arg2.length + 4)]) + 161 > test266151307() or floor32(cd[(arg2 + arg2.length + 4)]) + 161 < 160:
        revert with 'NH{q', 65
    mem[64] = floor32(cd[(arg2 + arg2.length + 4)]) + 161
    require arg2 + arg2.length + (96 * cd[(arg2 + arg2.length + 4)]) + 36 <= calldata.size
    idx = 0
    s = arg2 + arg2.length + 36
    t = 192
    while idx < cd[(arg2 + arg2.length + 4)]:
        require calldata.size - s >= 96
        _18 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_18] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_18 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == cd[(s + 64)]
        mem[_18 + 64] = cd[(s + 64)]
        mem[t] = _18
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    require cd[(arg2 + 36)] <= test266151307()
    require arg2 + cd[(arg2 + 36)] + 35 < calldata.size
    if cd[(arg2 + cd[(arg2 + 36)] + 4)] > test266151307():
        revert with 'NH{q', 65
    _19 = mem[64]
    if mem[64] + floor32(cd[(arg2 + cd[(arg2 + 36)] + 4)]) + 1 > test266151307() or mem[64] + floor32(cd[(arg2 + cd[(arg2 + 36)] + 4)]) + 1 < mem[64]:
        revert with 'NH{q', 65
    mem[64] = mem[64] + floor32(cd[(arg2 + cd[(arg2 + 36)] + 4)]) + 1
    mem[_19] = cd[(arg2 + cd[(arg2 + 36)] + 4)]
    require arg2 + cd[(arg2 + 36)] + (96 * cd[(arg2 + cd[(arg2 + 36)] + 4)]) + 36 <= calldata.size
    idx = 0
    s = arg2 + cd[(arg2 + 36)] + 36
    t = _19 + 32
    while idx < cd[(arg2 + cd[(arg2 + 36)] + 4)]:
        require calldata.size - s >= 96
        _33 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_33] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_33 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == cd[(s + 64)]
        mem[_33 + 64] = cd[(s + 64)]
        mem[t] = _33
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    require arg3 == arg3
    require arg4 == bool(arg4)
    return 1, 0, 0, 0, 0, 0, 0, 0, 0
}

function checkLiquidity(address arg1, address[] arg2, address arg3, address arg4, uint256[] arg5, address arg6, address arg7, uint256[] arg8, uint256 arg9, bool arg10) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + 97 > test266151307() or floor32(arg2.length) + 97 < 96:
        revert with 'NH{q', 65
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 <= test266151307()
    require calldata.size + -arg3 - 4 >= 64
    if not bool(floor32(arg2.length) + 161 <= test266151307()):
        revert with 'NH{q', 65
    require arg3.length <= test266151307()
    require arg3 + arg3.length + 35 < calldata.size
    if cd[(arg3 + arg3.length + 4)] > test266151307():
        revert with 'NH{q', 65
    if floor32(arg2.length) + floor32(cd[(arg3 + arg3.length + 4)]) + 162 > test266151307() or floor32(cd[(arg3 + arg3.length + 4)]) + 162 < 161:
        revert with 'NH{q', 65
    mem[64] = floor32(arg2.length) + floor32(cd[(arg3 + arg3.length + 4)]) + 162
    require arg3 + arg3.length + (96 * cd[(arg3 + arg3.length + 4)]) + 36 <= calldata.size
    idx = 0
    s = arg3 + arg3.length + 36
    t = floor32(arg2.length) + 193
    while idx < cd[(arg3 + arg3.length + 4)]:
        require calldata.size - s >= 96
        _36 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_36] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_36 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == cd[(s + 64)]
        mem[_36 + 64] = cd[(s + 64)]
        mem[t] = _36
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    require cd[(arg3 + 36)] <= test266151307()
    require arg3 + cd[(arg3 + 36)] + 35 < calldata.size
    if cd[(arg3 + cd[(arg3 + 36)] + 4)] > test266151307():
        revert with 'NH{q', 65
    _37 = mem[64]
    if mem[64] + floor32(cd[(arg3 + cd[(arg3 + 36)] + 4)]) + 1 > test266151307() or mem[64] + floor32(cd[(arg3 + cd[(arg3 + 36)] + 4)]) + 1 < mem[64]:
        revert with 'NH{q', 65
    mem[64] = mem[64] + floor32(cd[(arg3 + cd[(arg3 + 36)] + 4)]) + 1
    mem[_37] = cd[(arg3 + cd[(arg3 + 36)] + 4)]
    require arg3 + cd[(arg3 + 36)] + (96 * cd[(arg3 + cd[(arg3 + 36)] + 4)]) + 36 <= calldata.size
    idx = 0
    s = arg3 + cd[(arg3 + 36)] + 36
    t = _37 + 32
    while idx < cd[(arg3 + cd[(arg3 + 36)] + 4)]:
        require calldata.size - s >= 96
        _51 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_51] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_51 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == cd[(s + 64)]
        mem[_51 + 64] = cd[(s + 64)]
        mem[t] = _51
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    require arg4 == arg4
    require arg5 == bool(arg5)
    return 1, 0, 0, 0, 0, 0, 0, 0, 0
}



}
